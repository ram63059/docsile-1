
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Doctors
 * 
 */
export type Doctors = $Result.DefaultSelection<Prisma.$DoctorsPayload>
/**
 * Model AchievementsAwards
 * 
 */
export type AchievementsAwards = $Result.DefaultSelection<Prisma.$AchievementsAwardsPayload>
/**
 * Model Organisations
 * 
 */
export type Organisations = $Result.DefaultSelection<Prisma.$OrganisationsPayload>
/**
 * Model Jobs
 * 
 */
export type Jobs = $Result.DefaultSelection<Prisma.$JobsPayload>
/**
 * Model Conferrences
 * 
 */
export type Conferrences = $Result.DefaultSelection<Prisma.$ConferrencesPayload>
/**
 * Model Skills
 * 
 */
export type Skills = $Result.DefaultSelection<Prisma.$SkillsPayload>
/**
 * Model Posts
 * 
 */
export type Posts = $Result.DefaultSelection<Prisma.$PostsPayload>
/**
 * Model PostImageLinks
 * 
 */
export type PostImageLinks = $Result.DefaultSelection<Prisma.$PostImageLinksPayload>
/**
 * Model Comments
 * 
 */
export type Comments = $Result.DefaultSelection<Prisma.$CommentsPayload>
/**
 * Model Likes
 * 
 */
export type Likes = $Result.DefaultSelection<Prisma.$LikesPayload>
/**
 * Model Reposts
 * 
 */
export type Reposts = $Result.DefaultSelection<Prisma.$RepostsPayload>
/**
 * Model Shares
 * 
 */
export type Shares = $Result.DefaultSelection<Prisma.$SharesPayload>
/**
 * Model Questions
 * 
 */
export type Questions = $Result.DefaultSelection<Prisma.$QuestionsPayload>
/**
 * Model QuestionReferences
 * 
 */
export type QuestionReferences = $Result.DefaultSelection<Prisma.$QuestionReferencesPayload>
/**
 * Model QuestionComments
 * 
 */
export type QuestionComments = $Result.DefaultSelection<Prisma.$QuestionCommentsPayload>
/**
 * Model Answers
 * 
 */
export type Answers = $Result.DefaultSelection<Prisma.$AnswersPayload>
/**
 * Model Answer_Image_Links
 * 
 */
export type Answer_Image_Links = $Result.DefaultSelection<Prisma.$Answer_Image_LinksPayload>
/**
 * Model QuestionImageLinks
 * 
 */
export type QuestionImageLinks = $Result.DefaultSelection<Prisma.$QuestionImageLinksPayload>
/**
 * Model Insightful
 * 
 */
export type Insightful = $Result.DefaultSelection<Prisma.$InsightfulPayload>
/**
 * Model Friends
 * 
 */
export type Friends = $Result.DefaultSelection<Prisma.$FriendsPayload>
/**
 * Model Certifications
 * 
 */
export type Certifications = $Result.DefaultSelection<Prisma.$CertificationsPayload>
/**
 * Model Memberships
 * 
 */
export type Memberships = $Result.DefaultSelection<Prisma.$MembershipsPayload>
/**
 * Model Education
 * 
 */
export type Education = $Result.DefaultSelection<Prisma.$EducationPayload>
/**
 * Model ProfessionalExperience
 * 
 */
export type ProfessionalExperience = $Result.DefaultSelection<Prisma.$ProfessionalExperiencePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.doctors`: Exposes CRUD operations for the **Doctors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctors.findMany()
    * ```
    */
  get doctors(): Prisma.DoctorsDelegate<ExtArgs>;

  /**
   * `prisma.achievementsAwards`: Exposes CRUD operations for the **AchievementsAwards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AchievementsAwards
    * const achievementsAwards = await prisma.achievementsAwards.findMany()
    * ```
    */
  get achievementsAwards(): Prisma.AchievementsAwardsDelegate<ExtArgs>;

  /**
   * `prisma.organisations`: Exposes CRUD operations for the **Organisations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organisations
    * const organisations = await prisma.organisations.findMany()
    * ```
    */
  get organisations(): Prisma.OrganisationsDelegate<ExtArgs>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **Jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.JobsDelegate<ExtArgs>;

  /**
   * `prisma.conferrences`: Exposes CRUD operations for the **Conferrences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conferrences
    * const conferrences = await prisma.conferrences.findMany()
    * ```
    */
  get conferrences(): Prisma.ConferrencesDelegate<ExtArgs>;

  /**
   * `prisma.skills`: Exposes CRUD operations for the **Skills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skills.findMany()
    * ```
    */
  get skills(): Prisma.SkillsDelegate<ExtArgs>;

  /**
   * `prisma.posts`: Exposes CRUD operations for the **Posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.posts.findMany()
    * ```
    */
  get posts(): Prisma.PostsDelegate<ExtArgs>;

  /**
   * `prisma.postImageLinks`: Exposes CRUD operations for the **PostImageLinks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostImageLinks
    * const postImageLinks = await prisma.postImageLinks.findMany()
    * ```
    */
  get postImageLinks(): Prisma.PostImageLinksDelegate<ExtArgs>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **Comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.CommentsDelegate<ExtArgs>;

  /**
   * `prisma.likes`: Exposes CRUD operations for the **Likes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.likes.findMany()
    * ```
    */
  get likes(): Prisma.LikesDelegate<ExtArgs>;

  /**
   * `prisma.reposts`: Exposes CRUD operations for the **Reposts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reposts
    * const reposts = await prisma.reposts.findMany()
    * ```
    */
  get reposts(): Prisma.RepostsDelegate<ExtArgs>;

  /**
   * `prisma.shares`: Exposes CRUD operations for the **Shares** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shares
    * const shares = await prisma.shares.findMany()
    * ```
    */
  get shares(): Prisma.SharesDelegate<ExtArgs>;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **Questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.QuestionsDelegate<ExtArgs>;

  /**
   * `prisma.questionReferences`: Exposes CRUD operations for the **QuestionReferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionReferences
    * const questionReferences = await prisma.questionReferences.findMany()
    * ```
    */
  get questionReferences(): Prisma.QuestionReferencesDelegate<ExtArgs>;

  /**
   * `prisma.questionComments`: Exposes CRUD operations for the **QuestionComments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionComments
    * const questionComments = await prisma.questionComments.findMany()
    * ```
    */
  get questionComments(): Prisma.QuestionCommentsDelegate<ExtArgs>;

  /**
   * `prisma.answers`: Exposes CRUD operations for the **Answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answers.findMany()
    * ```
    */
  get answers(): Prisma.AnswersDelegate<ExtArgs>;

  /**
   * `prisma.answer_Image_Links`: Exposes CRUD operations for the **Answer_Image_Links** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answer_Image_Links
    * const answer_Image_Links = await prisma.answer_Image_Links.findMany()
    * ```
    */
  get answer_Image_Links(): Prisma.Answer_Image_LinksDelegate<ExtArgs>;

  /**
   * `prisma.questionImageLinks`: Exposes CRUD operations for the **QuestionImageLinks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionImageLinks
    * const questionImageLinks = await prisma.questionImageLinks.findMany()
    * ```
    */
  get questionImageLinks(): Prisma.QuestionImageLinksDelegate<ExtArgs>;

  /**
   * `prisma.insightful`: Exposes CRUD operations for the **Insightful** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insightfuls
    * const insightfuls = await prisma.insightful.findMany()
    * ```
    */
  get insightful(): Prisma.InsightfulDelegate<ExtArgs>;

  /**
   * `prisma.friends`: Exposes CRUD operations for the **Friends** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friends
    * const friends = await prisma.friends.findMany()
    * ```
    */
  get friends(): Prisma.FriendsDelegate<ExtArgs>;

  /**
   * `prisma.certifications`: Exposes CRUD operations for the **Certifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certifications
    * const certifications = await prisma.certifications.findMany()
    * ```
    */
  get certifications(): Prisma.CertificationsDelegate<ExtArgs>;

  /**
   * `prisma.memberships`: Exposes CRUD operations for the **Memberships** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memberships
    * const memberships = await prisma.memberships.findMany()
    * ```
    */
  get memberships(): Prisma.MembershipsDelegate<ExtArgs>;

  /**
   * `prisma.education`: Exposes CRUD operations for the **Education** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Educations
    * const educations = await prisma.education.findMany()
    * ```
    */
  get education(): Prisma.EducationDelegate<ExtArgs>;

  /**
   * `prisma.professionalExperience`: Exposes CRUD operations for the **ProfessionalExperience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfessionalExperiences
    * const professionalExperiences = await prisma.professionalExperience.findMany()
    * ```
    */
  get professionalExperience(): Prisma.ProfessionalExperienceDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.1.0
   * Query Engine version: 11f085a2012c0f4778414c8db2651556ee0ef959
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Doctors: 'Doctors',
    AchievementsAwards: 'AchievementsAwards',
    Organisations: 'Organisations',
    Jobs: 'Jobs',
    Conferrences: 'Conferrences',
    Skills: 'Skills',
    Posts: 'Posts',
    PostImageLinks: 'PostImageLinks',
    Comments: 'Comments',
    Likes: 'Likes',
    Reposts: 'Reposts',
    Shares: 'Shares',
    Questions: 'Questions',
    QuestionReferences: 'QuestionReferences',
    QuestionComments: 'QuestionComments',
    Answers: 'Answers',
    Answer_Image_Links: 'Answer_Image_Links',
    QuestionImageLinks: 'QuestionImageLinks',
    Insightful: 'Insightful',
    Friends: 'Friends',
    Certifications: 'Certifications',
    Memberships: 'Memberships',
    Education: 'Education',
    ProfessionalExperience: 'ProfessionalExperience'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "doctors" | "achievementsAwards" | "organisations" | "jobs" | "conferrences" | "skills" | "posts" | "postImageLinks" | "comments" | "likes" | "reposts" | "shares" | "questions" | "questionReferences" | "questionComments" | "answers" | "answer_Image_Links" | "questionImageLinks" | "insightful" | "friends" | "certifications" | "memberships" | "education" | "professionalExperience"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Doctors: {
        payload: Prisma.$DoctorsPayload<ExtArgs>
        fields: Prisma.DoctorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          findFirst: {
            args: Prisma.DoctorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          findMany: {
            args: Prisma.DoctorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>[]
          }
          create: {
            args: Prisma.DoctorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          createMany: {
            args: Prisma.DoctorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>[]
          }
          delete: {
            args: Prisma.DoctorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          update: {
            args: Prisma.DoctorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          deleteMany: {
            args: Prisma.DoctorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          aggregate: {
            args: Prisma.DoctorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctors>
          }
          groupBy: {
            args: Prisma.DoctorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorsCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorsCountAggregateOutputType> | number
          }
        }
      }
      AchievementsAwards: {
        payload: Prisma.$AchievementsAwardsPayload<ExtArgs>
        fields: Prisma.AchievementsAwardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementsAwardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementsAwardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload>
          }
          findFirst: {
            args: Prisma.AchievementsAwardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementsAwardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload>
          }
          findMany: {
            args: Prisma.AchievementsAwardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload>[]
          }
          create: {
            args: Prisma.AchievementsAwardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload>
          }
          createMany: {
            args: Prisma.AchievementsAwardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementsAwardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload>[]
          }
          delete: {
            args: Prisma.AchievementsAwardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload>
          }
          update: {
            args: Prisma.AchievementsAwardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload>
          }
          deleteMany: {
            args: Prisma.AchievementsAwardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementsAwardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementsAwardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementsAwardsPayload>
          }
          aggregate: {
            args: Prisma.AchievementsAwardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievementsAwards>
          }
          groupBy: {
            args: Prisma.AchievementsAwardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementsAwardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementsAwardsCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementsAwardsCountAggregateOutputType> | number
          }
        }
      }
      Organisations: {
        payload: Prisma.$OrganisationsPayload<ExtArgs>
        fields: Prisma.OrganisationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganisationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganisationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload>
          }
          findFirst: {
            args: Prisma.OrganisationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganisationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload>
          }
          findMany: {
            args: Prisma.OrganisationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload>[]
          }
          create: {
            args: Prisma.OrganisationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload>
          }
          createMany: {
            args: Prisma.OrganisationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganisationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload>[]
          }
          delete: {
            args: Prisma.OrganisationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload>
          }
          update: {
            args: Prisma.OrganisationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload>
          }
          deleteMany: {
            args: Prisma.OrganisationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganisationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganisationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationsPayload>
          }
          aggregate: {
            args: Prisma.OrganisationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisations>
          }
          groupBy: {
            args: Prisma.OrganisationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganisationsCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationsCountAggregateOutputType> | number
          }
        }
      }
      Jobs: {
        payload: Prisma.$JobsPayload<ExtArgs>
        fields: Prisma.JobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findFirst: {
            args: Prisma.JobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findMany: {
            args: Prisma.JobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>[]
          }
          create: {
            args: Prisma.JobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          createMany: {
            args: Prisma.JobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>[]
          }
          delete: {
            args: Prisma.JobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          update: {
            args: Prisma.JobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          deleteMany: {
            args: Prisma.JobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.JobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      Conferrences: {
        payload: Prisma.$ConferrencesPayload<ExtArgs>
        fields: Prisma.ConferrencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferrencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferrencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload>
          }
          findFirst: {
            args: Prisma.ConferrencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferrencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload>
          }
          findMany: {
            args: Prisma.ConferrencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload>[]
          }
          create: {
            args: Prisma.ConferrencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload>
          }
          createMany: {
            args: Prisma.ConferrencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferrencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload>[]
          }
          delete: {
            args: Prisma.ConferrencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload>
          }
          update: {
            args: Prisma.ConferrencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload>
          }
          deleteMany: {
            args: Prisma.ConferrencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferrencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConferrencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferrencesPayload>
          }
          aggregate: {
            args: Prisma.ConferrencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferrences>
          }
          groupBy: {
            args: Prisma.ConferrencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferrencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferrencesCountArgs<ExtArgs>
            result: $Utils.Optional<ConferrencesCountAggregateOutputType> | number
          }
        }
      }
      Skills: {
        payload: Prisma.$SkillsPayload<ExtArgs>
        fields: Prisma.SkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          findFirst: {
            args: Prisma.SkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          findMany: {
            args: Prisma.SkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>[]
          }
          create: {
            args: Prisma.SkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          createMany: {
            args: Prisma.SkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>[]
          }
          delete: {
            args: Prisma.SkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          update: {
            args: Prisma.SkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          deleteMany: {
            args: Prisma.SkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsPayload>
          }
          aggregate: {
            args: Prisma.SkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkills>
          }
          groupBy: {
            args: Prisma.SkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillsCountArgs<ExtArgs>
            result: $Utils.Optional<SkillsCountAggregateOutputType> | number
          }
        }
      }
      Posts: {
        payload: Prisma.$PostsPayload<ExtArgs>
        fields: Prisma.PostsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          findFirst: {
            args: Prisma.PostsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          findMany: {
            args: Prisma.PostsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>[]
          }
          create: {
            args: Prisma.PostsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          createMany: {
            args: Prisma.PostsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>[]
          }
          delete: {
            args: Prisma.PostsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          update: {
            args: Prisma.PostsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          deleteMany: {
            args: Prisma.PostsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          aggregate: {
            args: Prisma.PostsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosts>
          }
          groupBy: {
            args: Prisma.PostsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostsCountArgs<ExtArgs>
            result: $Utils.Optional<PostsCountAggregateOutputType> | number
          }
        }
      }
      PostImageLinks: {
        payload: Prisma.$PostImageLinksPayload<ExtArgs>
        fields: Prisma.PostImageLinksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostImageLinksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostImageLinksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload>
          }
          findFirst: {
            args: Prisma.PostImageLinksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostImageLinksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload>
          }
          findMany: {
            args: Prisma.PostImageLinksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload>[]
          }
          create: {
            args: Prisma.PostImageLinksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload>
          }
          createMany: {
            args: Prisma.PostImageLinksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostImageLinksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload>[]
          }
          delete: {
            args: Prisma.PostImageLinksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload>
          }
          update: {
            args: Prisma.PostImageLinksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload>
          }
          deleteMany: {
            args: Prisma.PostImageLinksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostImageLinksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostImageLinksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImageLinksPayload>
          }
          aggregate: {
            args: Prisma.PostImageLinksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostImageLinks>
          }
          groupBy: {
            args: Prisma.PostImageLinksGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostImageLinksGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostImageLinksCountArgs<ExtArgs>
            result: $Utils.Optional<PostImageLinksCountAggregateOutputType> | number
          }
        }
      }
      Comments: {
        payload: Prisma.$CommentsPayload<ExtArgs>
        fields: Prisma.CommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          findFirst: {
            args: Prisma.CommentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          findMany: {
            args: Prisma.CommentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>[]
          }
          create: {
            args: Prisma.CommentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          createMany: {
            args: Prisma.CommentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>[]
          }
          delete: {
            args: Prisma.CommentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          update: {
            args: Prisma.CommentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          deleteMany: {
            args: Prisma.CommentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.CommentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      Likes: {
        payload: Prisma.$LikesPayload<ExtArgs>
        fields: Prisma.LikesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload>
          }
          findFirst: {
            args: Prisma.LikesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload>
          }
          findMany: {
            args: Prisma.LikesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload>[]
          }
          create: {
            args: Prisma.LikesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload>
          }
          createMany: {
            args: Prisma.LikesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload>[]
          }
          delete: {
            args: Prisma.LikesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload>
          }
          update: {
            args: Prisma.LikesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload>
          }
          deleteMany: {
            args: Prisma.LikesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikesPayload>
          }
          aggregate: {
            args: Prisma.LikesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLikes>
          }
          groupBy: {
            args: Prisma.LikesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikesCountArgs<ExtArgs>
            result: $Utils.Optional<LikesCountAggregateOutputType> | number
          }
        }
      }
      Reposts: {
        payload: Prisma.$RepostsPayload<ExtArgs>
        fields: Prisma.RepostsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepostsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepostsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload>
          }
          findFirst: {
            args: Prisma.RepostsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepostsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload>
          }
          findMany: {
            args: Prisma.RepostsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload>[]
          }
          create: {
            args: Prisma.RepostsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload>
          }
          createMany: {
            args: Prisma.RepostsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RepostsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload>[]
          }
          delete: {
            args: Prisma.RepostsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload>
          }
          update: {
            args: Prisma.RepostsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload>
          }
          deleteMany: {
            args: Prisma.RepostsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepostsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RepostsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostsPayload>
          }
          aggregate: {
            args: Prisma.RepostsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReposts>
          }
          groupBy: {
            args: Prisma.RepostsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepostsCountArgs<ExtArgs>
            result: $Utils.Optional<RepostsCountAggregateOutputType> | number
          }
        }
      }
      Shares: {
        payload: Prisma.$SharesPayload<ExtArgs>
        fields: Prisma.SharesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload>
          }
          findFirst: {
            args: Prisma.SharesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload>
          }
          findMany: {
            args: Prisma.SharesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload>[]
          }
          create: {
            args: Prisma.SharesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload>
          }
          createMany: {
            args: Prisma.SharesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload>[]
          }
          delete: {
            args: Prisma.SharesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload>
          }
          update: {
            args: Prisma.SharesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload>
          }
          deleteMany: {
            args: Prisma.SharesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SharesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharesPayload>
          }
          aggregate: {
            args: Prisma.SharesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShares>
          }
          groupBy: {
            args: Prisma.SharesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharesCountArgs<ExtArgs>
            result: $Utils.Optional<SharesCountAggregateOutputType> | number
          }
        }
      }
      Questions: {
        payload: Prisma.$QuestionsPayload<ExtArgs>
        fields: Prisma.QuestionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          findFirst: {
            args: Prisma.QuestionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          findMany: {
            args: Prisma.QuestionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>[]
          }
          create: {
            args: Prisma.QuestionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          createMany: {
            args: Prisma.QuestionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>[]
          }
          delete: {
            args: Prisma.QuestionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          update: {
            args: Prisma.QuestionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          deleteMany: {
            args: Prisma.QuestionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          aggregate: {
            args: Prisma.QuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions>
          }
          groupBy: {
            args: Prisma.QuestionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsCountAggregateOutputType> | number
          }
        }
      }
      QuestionReferences: {
        payload: Prisma.$QuestionReferencesPayload<ExtArgs>
        fields: Prisma.QuestionReferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionReferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionReferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload>
          }
          findFirst: {
            args: Prisma.QuestionReferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionReferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload>
          }
          findMany: {
            args: Prisma.QuestionReferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload>[]
          }
          create: {
            args: Prisma.QuestionReferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload>
          }
          createMany: {
            args: Prisma.QuestionReferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionReferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload>[]
          }
          delete: {
            args: Prisma.QuestionReferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload>
          }
          update: {
            args: Prisma.QuestionReferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload>
          }
          deleteMany: {
            args: Prisma.QuestionReferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionReferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionReferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionReferencesPayload>
          }
          aggregate: {
            args: Prisma.QuestionReferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionReferences>
          }
          groupBy: {
            args: Prisma.QuestionReferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionReferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionReferencesCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionReferencesCountAggregateOutputType> | number
          }
        }
      }
      QuestionComments: {
        payload: Prisma.$QuestionCommentsPayload<ExtArgs>
        fields: Prisma.QuestionCommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionCommentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionCommentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload>
          }
          findFirst: {
            args: Prisma.QuestionCommentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionCommentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload>
          }
          findMany: {
            args: Prisma.QuestionCommentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload>[]
          }
          create: {
            args: Prisma.QuestionCommentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload>
          }
          createMany: {
            args: Prisma.QuestionCommentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCommentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload>[]
          }
          delete: {
            args: Prisma.QuestionCommentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload>
          }
          update: {
            args: Prisma.QuestionCommentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload>
          }
          deleteMany: {
            args: Prisma.QuestionCommentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionCommentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionCommentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionCommentsPayload>
          }
          aggregate: {
            args: Prisma.QuestionCommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionComments>
          }
          groupBy: {
            args: Prisma.QuestionCommentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionCommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCommentsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCommentsCountAggregateOutputType> | number
          }
        }
      }
      Answers: {
        payload: Prisma.$AnswersPayload<ExtArgs>
        fields: Prisma.AnswersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          findFirst: {
            args: Prisma.AnswersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          findMany: {
            args: Prisma.AnswersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>[]
          }
          create: {
            args: Prisma.AnswersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          createMany: {
            args: Prisma.AnswersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnswersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>[]
          }
          delete: {
            args: Prisma.AnswersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          update: {
            args: Prisma.AnswersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          deleteMany: {
            args: Prisma.AnswersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnswersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnswersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          aggregate: {
            args: Prisma.AnswersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswers>
          }
          groupBy: {
            args: Prisma.AnswersGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswersGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswersCountArgs<ExtArgs>
            result: $Utils.Optional<AnswersCountAggregateOutputType> | number
          }
        }
      }
      Answer_Image_Links: {
        payload: Prisma.$Answer_Image_LinksPayload<ExtArgs>
        fields: Prisma.Answer_Image_LinksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Answer_Image_LinksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Answer_Image_LinksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload>
          }
          findFirst: {
            args: Prisma.Answer_Image_LinksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Answer_Image_LinksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload>
          }
          findMany: {
            args: Prisma.Answer_Image_LinksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload>[]
          }
          create: {
            args: Prisma.Answer_Image_LinksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload>
          }
          createMany: {
            args: Prisma.Answer_Image_LinksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Answer_Image_LinksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload>[]
          }
          delete: {
            args: Prisma.Answer_Image_LinksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload>
          }
          update: {
            args: Prisma.Answer_Image_LinksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload>
          }
          deleteMany: {
            args: Prisma.Answer_Image_LinksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Answer_Image_LinksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Answer_Image_LinksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Answer_Image_LinksPayload>
          }
          aggregate: {
            args: Prisma.Answer_Image_LinksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswer_Image_Links>
          }
          groupBy: {
            args: Prisma.Answer_Image_LinksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Answer_Image_LinksGroupByOutputType>[]
          }
          count: {
            args: Prisma.Answer_Image_LinksCountArgs<ExtArgs>
            result: $Utils.Optional<Answer_Image_LinksCountAggregateOutputType> | number
          }
        }
      }
      QuestionImageLinks: {
        payload: Prisma.$QuestionImageLinksPayload<ExtArgs>
        fields: Prisma.QuestionImageLinksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionImageLinksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionImageLinksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload>
          }
          findFirst: {
            args: Prisma.QuestionImageLinksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionImageLinksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload>
          }
          findMany: {
            args: Prisma.QuestionImageLinksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload>[]
          }
          create: {
            args: Prisma.QuestionImageLinksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload>
          }
          createMany: {
            args: Prisma.QuestionImageLinksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionImageLinksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload>[]
          }
          delete: {
            args: Prisma.QuestionImageLinksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload>
          }
          update: {
            args: Prisma.QuestionImageLinksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload>
          }
          deleteMany: {
            args: Prisma.QuestionImageLinksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionImageLinksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionImageLinksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImageLinksPayload>
          }
          aggregate: {
            args: Prisma.QuestionImageLinksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionImageLinks>
          }
          groupBy: {
            args: Prisma.QuestionImageLinksGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionImageLinksGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionImageLinksCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionImageLinksCountAggregateOutputType> | number
          }
        }
      }
      Insightful: {
        payload: Prisma.$InsightfulPayload<ExtArgs>
        fields: Prisma.InsightfulFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightfulFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightfulFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload>
          }
          findFirst: {
            args: Prisma.InsightfulFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightfulFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload>
          }
          findMany: {
            args: Prisma.InsightfulFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload>[]
          }
          create: {
            args: Prisma.InsightfulCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload>
          }
          createMany: {
            args: Prisma.InsightfulCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightfulCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload>[]
          }
          delete: {
            args: Prisma.InsightfulDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload>
          }
          update: {
            args: Prisma.InsightfulUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload>
          }
          deleteMany: {
            args: Prisma.InsightfulDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightfulUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsightfulUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightfulPayload>
          }
          aggregate: {
            args: Prisma.InsightfulAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsightful>
          }
          groupBy: {
            args: Prisma.InsightfulGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightfulGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightfulCountArgs<ExtArgs>
            result: $Utils.Optional<InsightfulCountAggregateOutputType> | number
          }
        }
      }
      Friends: {
        payload: Prisma.$FriendsPayload<ExtArgs>
        fields: Prisma.FriendsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          findFirst: {
            args: Prisma.FriendsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          findMany: {
            args: Prisma.FriendsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>[]
          }
          create: {
            args: Prisma.FriendsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          createMany: {
            args: Prisma.FriendsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>[]
          }
          delete: {
            args: Prisma.FriendsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          update: {
            args: Prisma.FriendsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          deleteMany: {
            args: Prisma.FriendsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          aggregate: {
            args: Prisma.FriendsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriends>
          }
          groupBy: {
            args: Prisma.FriendsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendsCountArgs<ExtArgs>
            result: $Utils.Optional<FriendsCountAggregateOutputType> | number
          }
        }
      }
      Certifications: {
        payload: Prisma.$CertificationsPayload<ExtArgs>
        fields: Prisma.CertificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload>
          }
          findFirst: {
            args: Prisma.CertificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload>
          }
          findMany: {
            args: Prisma.CertificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload>[]
          }
          create: {
            args: Prisma.CertificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload>
          }
          createMany: {
            args: Prisma.CertificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload>[]
          }
          delete: {
            args: Prisma.CertificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload>
          }
          update: {
            args: Prisma.CertificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload>
          }
          deleteMany: {
            args: Prisma.CertificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationsPayload>
          }
          aggregate: {
            args: Prisma.CertificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertifications>
          }
          groupBy: {
            args: Prisma.CertificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationsCountArgs<ExtArgs>
            result: $Utils.Optional<CertificationsCountAggregateOutputType> | number
          }
        }
      }
      Memberships: {
        payload: Prisma.$MembershipsPayload<ExtArgs>
        fields: Prisma.MembershipsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload>
          }
          findFirst: {
            args: Prisma.MembershipsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload>
          }
          findMany: {
            args: Prisma.MembershipsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload>[]
          }
          create: {
            args: Prisma.MembershipsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload>
          }
          createMany: {
            args: Prisma.MembershipsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload>[]
          }
          delete: {
            args: Prisma.MembershipsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload>
          }
          update: {
            args: Prisma.MembershipsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload>
          }
          deleteMany: {
            args: Prisma.MembershipsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MembershipsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipsPayload>
          }
          aggregate: {
            args: Prisma.MembershipsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberships>
          }
          groupBy: {
            args: Prisma.MembershipsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipsCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipsCountAggregateOutputType> | number
          }
        }
      }
      Education: {
        payload: Prisma.$EducationPayload<ExtArgs>
        fields: Prisma.EducationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findFirst: {
            args: Prisma.EducationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findMany: {
            args: Prisma.EducationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          create: {
            args: Prisma.EducationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          createMany: {
            args: Prisma.EducationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EducationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          delete: {
            args: Prisma.EducationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          update: {
            args: Prisma.EducationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          deleteMany: {
            args: Prisma.EducationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EducationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          aggregate: {
            args: Prisma.EducationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducation>
          }
          groupBy: {
            args: Prisma.EducationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationCountArgs<ExtArgs>
            result: $Utils.Optional<EducationCountAggregateOutputType> | number
          }
        }
      }
      ProfessionalExperience: {
        payload: Prisma.$ProfessionalExperiencePayload<ExtArgs>
        fields: Prisma.ProfessionalExperienceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfessionalExperienceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfessionalExperienceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload>
          }
          findFirst: {
            args: Prisma.ProfessionalExperienceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfessionalExperienceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload>
          }
          findMany: {
            args: Prisma.ProfessionalExperienceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload>[]
          }
          create: {
            args: Prisma.ProfessionalExperienceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload>
          }
          createMany: {
            args: Prisma.ProfessionalExperienceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfessionalExperienceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload>[]
          }
          delete: {
            args: Prisma.ProfessionalExperienceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload>
          }
          update: {
            args: Prisma.ProfessionalExperienceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload>
          }
          deleteMany: {
            args: Prisma.ProfessionalExperienceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfessionalExperienceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfessionalExperienceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalExperiencePayload>
          }
          aggregate: {
            args: Prisma.ProfessionalExperienceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfessionalExperience>
          }
          groupBy: {
            args: Prisma.ProfessionalExperienceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfessionalExperienceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfessionalExperienceCountArgs<ExtArgs>
            result: $Utils.Optional<ProfessionalExperienceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    skills: number
    posts: number
    questions: number
    friends: number
    certifications: number
    memberships: number
    education: number
    professionalExperience: number
    jobs: number
    conferrences: number
    achievementsAwards: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | UserCountOutputTypeCountSkillsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    questions?: boolean | UserCountOutputTypeCountQuestionsArgs
    friends?: boolean | UserCountOutputTypeCountFriendsArgs
    certifications?: boolean | UserCountOutputTypeCountCertificationsArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    education?: boolean | UserCountOutputTypeCountEducationArgs
    professionalExperience?: boolean | UserCountOutputTypeCountProfessionalExperienceArgs
    jobs?: boolean | UserCountOutputTypeCountJobsArgs
    conferrences?: boolean | UserCountOutputTypeCountConferrencesArgs
    achievementsAwards?: boolean | UserCountOutputTypeCountAchievementsAwardsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfessionalExperienceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfessionalExperienceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConferrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferrencesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsAwardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementsAwardsWhereInput
  }


  /**
   * Count Type PostsCountOutputType
   */

  export type PostsCountOutputType = {
    postImageLinks: number
    comments: number
    likes: number
    reposts: number
    shares: number
  }

  export type PostsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postImageLinks?: boolean | PostsCountOutputTypeCountPostImageLinksArgs
    comments?: boolean | PostsCountOutputTypeCountCommentsArgs
    likes?: boolean | PostsCountOutputTypeCountLikesArgs
    reposts?: boolean | PostsCountOutputTypeCountRepostsArgs
    shares?: boolean | PostsCountOutputTypeCountSharesArgs
  }

  // Custom InputTypes
  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsCountOutputType
     */
    select?: PostsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountPostImageLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostImageLinksWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikesWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountRepostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepostsWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharesWhereInput
  }


  /**
   * Count Type QuestionsCountOutputType
   */

  export type QuestionsCountOutputType = {
    question_image_links: number
    insightful: number
    answers: number
    questionComments: number
    questionReferences: number
  }

  export type QuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question_image_links?: boolean | QuestionsCountOutputTypeCountQuestion_image_linksArgs
    insightful?: boolean | QuestionsCountOutputTypeCountInsightfulArgs
    answers?: boolean | QuestionsCountOutputTypeCountAnswersArgs
    questionComments?: boolean | QuestionsCountOutputTypeCountQuestionCommentsArgs
    questionReferences?: boolean | QuestionsCountOutputTypeCountQuestionReferencesArgs
  }

  // Custom InputTypes
  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsCountOutputType
     */
    select?: QuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountQuestion_image_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionImageLinksWhereInput
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountInsightfulArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightfulWhereInput
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswersWhereInput
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountQuestionCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionCommentsWhereInput
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountQuestionReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionReferencesWhereInput
  }


  /**
   * Count Type AnswersCountOutputType
   */

  export type AnswersCountOutputType = {
    answer_image_links: number
  }

  export type AnswersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answer_image_links?: boolean | AnswersCountOutputTypeCountAnswer_image_linksArgs
  }

  // Custom InputTypes
  /**
   * AnswersCountOutputType without action
   */
  export type AnswersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswersCountOutputType
     */
    select?: AnswersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnswersCountOutputType without action
   */
  export type AnswersCountOutputTypeCountAnswer_image_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Answer_Image_LinksWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    category: string | null
    email: string | null
    password: string | null
    name: string | null
    gender: string | null
    department: string | null
    country: string | null
    city: string | null
    organisation_name: string | null
    specialisation_field_of_study: string | null
    register_number: string | null
    verified: boolean | null
    date_of_birth: Date | null
    created_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    category: string | null
    email: string | null
    password: string | null
    name: string | null
    gender: string | null
    department: string | null
    country: string | null
    city: string | null
    organisation_name: string | null
    specialisation_field_of_study: string | null
    register_number: string | null
    verified: boolean | null
    date_of_birth: Date | null
    created_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    category: number
    email: number
    password: number
    name: number
    gender: number
    department: number
    country: number
    city: number
    organisation_name: number
    specialisation_field_of_study: number
    register_number: number
    verified: number
    date_of_birth: number
    created_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    category?: true
    email?: true
    password?: true
    name?: true
    gender?: true
    department?: true
    country?: true
    city?: true
    organisation_name?: true
    specialisation_field_of_study?: true
    register_number?: true
    verified?: true
    date_of_birth?: true
    created_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    category?: true
    email?: true
    password?: true
    name?: true
    gender?: true
    department?: true
    country?: true
    city?: true
    organisation_name?: true
    specialisation_field_of_study?: true
    register_number?: true
    verified?: true
    date_of_birth?: true
    created_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    category?: true
    email?: true
    password?: true
    name?: true
    gender?: true
    department?: true
    country?: true
    city?: true
    organisation_name?: true
    specialisation_field_of_study?: true
    register_number?: true
    verified?: true
    date_of_birth?: true
    created_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    category: string
    email: string
    password: string
    name: string | null
    gender: string | null
    department: string | null
    country: string | null
    city: string | null
    organisation_name: string | null
    specialisation_field_of_study: string | null
    register_number: string | null
    verified: boolean
    date_of_birth: Date | null
    created_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    gender?: boolean
    department?: boolean
    country?: boolean
    city?: boolean
    organisation_name?: boolean
    specialisation_field_of_study?: boolean
    register_number?: boolean
    verified?: boolean
    date_of_birth?: boolean
    created_at?: boolean
    skills?: boolean | User$skillsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    questions?: boolean | User$questionsArgs<ExtArgs>
    friends?: boolean | User$friendsArgs<ExtArgs>
    certifications?: boolean | User$certificationsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    education?: boolean | User$educationArgs<ExtArgs>
    professionalExperience?: boolean | User$professionalExperienceArgs<ExtArgs>
    jobs?: boolean | User$jobsArgs<ExtArgs>
    conferrences?: boolean | User$conferrencesArgs<ExtArgs>
    achievementsAwards?: boolean | User$achievementsAwardsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    gender?: boolean
    department?: boolean
    country?: boolean
    city?: boolean
    organisation_name?: boolean
    specialisation_field_of_study?: boolean
    register_number?: boolean
    verified?: boolean
    date_of_birth?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    category?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    gender?: boolean
    department?: boolean
    country?: boolean
    city?: boolean
    organisation_name?: boolean
    specialisation_field_of_study?: boolean
    register_number?: boolean
    verified?: boolean
    date_of_birth?: boolean
    created_at?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | User$skillsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    questions?: boolean | User$questionsArgs<ExtArgs>
    friends?: boolean | User$friendsArgs<ExtArgs>
    certifications?: boolean | User$certificationsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    education?: boolean | User$educationArgs<ExtArgs>
    professionalExperience?: boolean | User$professionalExperienceArgs<ExtArgs>
    jobs?: boolean | User$jobsArgs<ExtArgs>
    conferrences?: boolean | User$conferrencesArgs<ExtArgs>
    achievementsAwards?: boolean | User$achievementsAwardsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      skills: Prisma.$SkillsPayload<ExtArgs>[]
      posts: Prisma.$PostsPayload<ExtArgs>[]
      questions: Prisma.$QuestionsPayload<ExtArgs>[]
      friends: Prisma.$FriendsPayload<ExtArgs>[]
      certifications: Prisma.$CertificationsPayload<ExtArgs>[]
      memberships: Prisma.$MembershipsPayload<ExtArgs>[]
      education: Prisma.$EducationPayload<ExtArgs>[]
      professionalExperience: Prisma.$ProfessionalExperiencePayload<ExtArgs>[]
      jobs: Prisma.$JobsPayload<ExtArgs>[]
      conferrences: Prisma.$ConferrencesPayload<ExtArgs>[]
      achievementsAwards: Prisma.$AchievementsAwardsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string
      email: string
      password: string
      name: string | null
      gender: string | null
      department: string | null
      country: string | null
      city: string | null
      organisation_name: string | null
      specialisation_field_of_study: string | null
      register_number: string | null
      verified: boolean
      date_of_birth: Date | null
      created_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skills<T extends User$skillsArgs<ExtArgs> = {}>(args?: Subset<T, User$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findMany"> | Null>
    questions<T extends User$questionsArgs<ExtArgs> = {}>(args?: Subset<T, User$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findMany"> | Null>
    friends<T extends User$friendsArgs<ExtArgs> = {}>(args?: Subset<T, User$friendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany"> | Null>
    certifications<T extends User$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "findMany"> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "findMany"> | Null>
    education<T extends User$educationArgs<ExtArgs> = {}>(args?: Subset<T, User$educationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany"> | Null>
    professionalExperience<T extends User$professionalExperienceArgs<ExtArgs> = {}>(args?: Subset<T, User$professionalExperienceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "findMany"> | Null>
    jobs<T extends User$jobsArgs<ExtArgs> = {}>(args?: Subset<T, User$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany"> | Null>
    conferrences<T extends User$conferrencesArgs<ExtArgs> = {}>(args?: Subset<T, User$conferrencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "findMany"> | Null>
    achievementsAwards<T extends User$achievementsAwardsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsAwardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly category: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly organisation_name: FieldRef<"User", 'String'>
    readonly specialisation_field_of_study: FieldRef<"User", 'String'>
    readonly register_number: FieldRef<"User", 'String'>
    readonly verified: FieldRef<"User", 'Boolean'>
    readonly date_of_birth: FieldRef<"User", 'DateTime'>
    readonly created_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.skills
   */
  export type User$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    where?: SkillsWhereInput
    orderBy?: SkillsOrderByWithRelationInput | SkillsOrderByWithRelationInput[]
    cursor?: SkillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    cursor?: PostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * User.questions
   */
  export type User$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    where?: QuestionsWhereInput
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    cursor?: QuestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * User.friends
   */
  export type User$friendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    cursor?: FriendsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * User.certifications
   */
  export type User$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    where?: CertificationsWhereInput
    orderBy?: CertificationsOrderByWithRelationInput | CertificationsOrderByWithRelationInput[]
    cursor?: CertificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationsScalarFieldEnum | CertificationsScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    where?: MembershipsWhereInput
    orderBy?: MembershipsOrderByWithRelationInput | MembershipsOrderByWithRelationInput[]
    cursor?: MembershipsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipsScalarFieldEnum | MembershipsScalarFieldEnum[]
  }

  /**
   * User.education
   */
  export type User$educationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    cursor?: EducationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * User.professionalExperience
   */
  export type User$professionalExperienceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    where?: ProfessionalExperienceWhereInput
    orderBy?: ProfessionalExperienceOrderByWithRelationInput | ProfessionalExperienceOrderByWithRelationInput[]
    cursor?: ProfessionalExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfessionalExperienceScalarFieldEnum | ProfessionalExperienceScalarFieldEnum[]
  }

  /**
   * User.jobs
   */
  export type User$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * User.conferrences
   */
  export type User$conferrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    where?: ConferrencesWhereInput
    orderBy?: ConferrencesOrderByWithRelationInput | ConferrencesOrderByWithRelationInput[]
    cursor?: ConferrencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferrencesScalarFieldEnum | ConferrencesScalarFieldEnum[]
  }

  /**
   * User.achievementsAwards
   */
  export type User$achievementsAwardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    where?: AchievementsAwardsWhereInput
    orderBy?: AchievementsAwardsOrderByWithRelationInput | AchievementsAwardsOrderByWithRelationInput[]
    cursor?: AchievementsAwardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementsAwardsScalarFieldEnum | AchievementsAwardsScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Doctors
   */

  export type AggregateDoctors = {
    _count: DoctorsCountAggregateOutputType | null
    _avg: DoctorsAvgAggregateOutputType | null
    _sum: DoctorsSumAggregateOutputType | null
    _min: DoctorsMinAggregateOutputType | null
    _max: DoctorsMaxAggregateOutputType | null
  }

  export type DoctorsAvgAggregateOutputType = {
    id: number | null
  }

  export type DoctorsSumAggregateOutputType = {
    id: number | null
  }

  export type DoctorsMinAggregateOutputType = {
    id: number | null
    registrationNo: string | null
    doctors: string | null
  }

  export type DoctorsMaxAggregateOutputType = {
    id: number | null
    registrationNo: string | null
    doctors: string | null
  }

  export type DoctorsCountAggregateOutputType = {
    id: number
    registrationNo: number
    doctors: number
    _all: number
  }


  export type DoctorsAvgAggregateInputType = {
    id?: true
  }

  export type DoctorsSumAggregateInputType = {
    id?: true
  }

  export type DoctorsMinAggregateInputType = {
    id?: true
    registrationNo?: true
    doctors?: true
  }

  export type DoctorsMaxAggregateInputType = {
    id?: true
    registrationNo?: true
    doctors?: true
  }

  export type DoctorsCountAggregateInputType = {
    id?: true
    registrationNo?: true
    doctors?: true
    _all?: true
  }

  export type DoctorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to aggregate.
     */
    where?: DoctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorsOrderByWithRelationInput | DoctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorsMaxAggregateInputType
  }

  export type GetDoctorsAggregateType<T extends DoctorsAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctors[P]>
      : GetScalarType<T[P], AggregateDoctors[P]>
  }




  export type DoctorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorsWhereInput
    orderBy?: DoctorsOrderByWithAggregationInput | DoctorsOrderByWithAggregationInput[]
    by: DoctorsScalarFieldEnum[] | DoctorsScalarFieldEnum
    having?: DoctorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorsCountAggregateInputType | true
    _avg?: DoctorsAvgAggregateInputType
    _sum?: DoctorsSumAggregateInputType
    _min?: DoctorsMinAggregateInputType
    _max?: DoctorsMaxAggregateInputType
  }

  export type DoctorsGroupByOutputType = {
    id: number
    registrationNo: string
    doctors: string
    _count: DoctorsCountAggregateOutputType | null
    _avg: DoctorsAvgAggregateOutputType | null
    _sum: DoctorsSumAggregateOutputType | null
    _min: DoctorsMinAggregateOutputType | null
    _max: DoctorsMaxAggregateOutputType | null
  }

  type GetDoctorsGroupByPayload<T extends DoctorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorsGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorsGroupByOutputType[P]>
        }
      >
    >


  export type DoctorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registrationNo?: boolean
    doctors?: boolean
  }, ExtArgs["result"]["doctors"]>

  export type DoctorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registrationNo?: boolean
    doctors?: boolean
  }, ExtArgs["result"]["doctors"]>

  export type DoctorsSelectScalar = {
    id?: boolean
    registrationNo?: boolean
    doctors?: boolean
  }


  export type $DoctorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctors"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      registrationNo: string
      doctors: string
    }, ExtArgs["result"]["doctors"]>
    composites: {}
  }

  type DoctorsGetPayload<S extends boolean | null | undefined | DoctorsDefaultArgs> = $Result.GetResult<Prisma.$DoctorsPayload, S>

  type DoctorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorsCountAggregateInputType | true
    }

  export interface DoctorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctors'], meta: { name: 'Doctors' } }
    /**
     * Find zero or one Doctors that matches the filter.
     * @param {DoctorsFindUniqueArgs} args - Arguments to find a Doctors
     * @example
     * // Get one Doctors
     * const doctors = await prisma.doctors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorsFindUniqueArgs>(args: SelectSubset<T, DoctorsFindUniqueArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Doctors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctorsFindUniqueOrThrowArgs} args - Arguments to find a Doctors
     * @example
     * // Get one Doctors
     * const doctors = await prisma.doctors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorsFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsFindFirstArgs} args - Arguments to find a Doctors
     * @example
     * // Get one Doctors
     * const doctors = await prisma.doctors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorsFindFirstArgs>(args?: SelectSubset<T, DoctorsFindFirstArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Doctors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsFindFirstOrThrowArgs} args - Arguments to find a Doctors
     * @example
     * // Get one Doctors
     * const doctors = await prisma.doctors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorsFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctors.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorsWithIdOnly = await prisma.doctors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorsFindManyArgs>(args?: SelectSubset<T, DoctorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Doctors.
     * @param {DoctorsCreateArgs} args - Arguments to create a Doctors.
     * @example
     * // Create one Doctors
     * const Doctors = await prisma.doctors.create({
     *   data: {
     *     // ... data to create a Doctors
     *   }
     * })
     * 
     */
    create<T extends DoctorsCreateArgs>(args: SelectSubset<T, DoctorsCreateArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Doctors.
     * @param {DoctorsCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctors = await prisma.doctors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorsCreateManyArgs>(args?: SelectSubset<T, DoctorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {DoctorsCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctors = await prisma.doctors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doctors and only return the `id`
     * const doctorsWithIdOnly = await prisma.doctors.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorsCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Doctors.
     * @param {DoctorsDeleteArgs} args - Arguments to delete one Doctors.
     * @example
     * // Delete one Doctors
     * const Doctors = await prisma.doctors.delete({
     *   where: {
     *     // ... filter to delete one Doctors
     *   }
     * })
     * 
     */
    delete<T extends DoctorsDeleteArgs>(args: SelectSubset<T, DoctorsDeleteArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Doctors.
     * @param {DoctorsUpdateArgs} args - Arguments to update one Doctors.
     * @example
     * // Update one Doctors
     * const doctors = await prisma.doctors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorsUpdateArgs>(args: SelectSubset<T, DoctorsUpdateArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorsDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorsDeleteManyArgs>(args?: SelectSubset<T, DoctorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctors = await prisma.doctors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorsUpdateManyArgs>(args: SelectSubset<T, DoctorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctors.
     * @param {DoctorsUpsertArgs} args - Arguments to update or create a Doctors.
     * @example
     * // Update or create a Doctors
     * const doctors = await prisma.doctors.upsert({
     *   create: {
     *     // ... data to create a Doctors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctors we want to update
     *   }
     * })
     */
    upsert<T extends DoctorsUpsertArgs>(args: SelectSubset<T, DoctorsUpsertArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctors.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorsCountArgs>(
      args?: Subset<T, DoctorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorsAggregateArgs>(args: Subset<T, DoctorsAggregateArgs>): Prisma.PrismaPromise<GetDoctorsAggregateType<T>>

    /**
     * Group by Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorsGroupByArgs['orderBy'] }
        : { orderBy?: DoctorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctors model
   */
  readonly fields: DoctorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doctors model
   */ 
  interface DoctorsFieldRefs {
    readonly id: FieldRef<"Doctors", 'Int'>
    readonly registrationNo: FieldRef<"Doctors", 'String'>
    readonly doctors: FieldRef<"Doctors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Doctors findUnique
   */
  export type DoctorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where: DoctorsWhereUniqueInput
  }

  /**
   * Doctors findUniqueOrThrow
   */
  export type DoctorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where: DoctorsWhereUniqueInput
  }

  /**
   * Doctors findFirst
   */
  export type DoctorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorsOrderByWithRelationInput | DoctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorsScalarFieldEnum | DoctorsScalarFieldEnum[]
  }

  /**
   * Doctors findFirstOrThrow
   */
  export type DoctorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorsOrderByWithRelationInput | DoctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorsScalarFieldEnum | DoctorsScalarFieldEnum[]
  }

  /**
   * Doctors findMany
   */
  export type DoctorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorsOrderByWithRelationInput | DoctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: DoctorsScalarFieldEnum | DoctorsScalarFieldEnum[]
  }

  /**
   * Doctors create
   */
  export type DoctorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * The data needed to create a Doctors.
     */
    data: XOR<DoctorsCreateInput, DoctorsUncheckedCreateInput>
  }

  /**
   * Doctors createMany
   */
  export type DoctorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorsCreateManyInput | DoctorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctors createManyAndReturn
   */
  export type DoctorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Doctors.
     */
    data: DoctorsCreateManyInput | DoctorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctors update
   */
  export type DoctorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * The data needed to update a Doctors.
     */
    data: XOR<DoctorsUpdateInput, DoctorsUncheckedUpdateInput>
    /**
     * Choose, which Doctors to update.
     */
    where: DoctorsWhereUniqueInput
  }

  /**
   * Doctors updateMany
   */
  export type DoctorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorsUpdateManyMutationInput, DoctorsUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorsWhereInput
  }

  /**
   * Doctors upsert
   */
  export type DoctorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * The filter to search for the Doctors to update in case it exists.
     */
    where: DoctorsWhereUniqueInput
    /**
     * In case the Doctors found by the `where` argument doesn't exist, create a new Doctors with this data.
     */
    create: XOR<DoctorsCreateInput, DoctorsUncheckedCreateInput>
    /**
     * In case the Doctors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorsUpdateInput, DoctorsUncheckedUpdateInput>
  }

  /**
   * Doctors delete
   */
  export type DoctorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Filter which Doctors to delete.
     */
    where: DoctorsWhereUniqueInput
  }

  /**
   * Doctors deleteMany
   */
  export type DoctorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorsWhereInput
  }

  /**
   * Doctors without action
   */
  export type DoctorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
  }


  /**
   * Model AchievementsAwards
   */

  export type AggregateAchievementsAwards = {
    _count: AchievementsAwardsCountAggregateOutputType | null
    _avg: AchievementsAwardsAvgAggregateOutputType | null
    _sum: AchievementsAwardsSumAggregateOutputType | null
    _min: AchievementsAwardsMinAggregateOutputType | null
    _max: AchievementsAwardsMaxAggregateOutputType | null
  }

  export type AchievementsAwardsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AchievementsAwardsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AchievementsAwardsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    awardName: string | null
    awardedBy: string | null
    awardedOn: string | null
    descreption: string | null
  }

  export type AchievementsAwardsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    awardName: string | null
    awardedBy: string | null
    awardedOn: string | null
    descreption: string | null
  }

  export type AchievementsAwardsCountAggregateOutputType = {
    id: number
    userId: number
    awardName: number
    awardedBy: number
    awardedOn: number
    descreption: number
    _all: number
  }


  export type AchievementsAwardsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AchievementsAwardsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AchievementsAwardsMinAggregateInputType = {
    id?: true
    userId?: true
    awardName?: true
    awardedBy?: true
    awardedOn?: true
    descreption?: true
  }

  export type AchievementsAwardsMaxAggregateInputType = {
    id?: true
    userId?: true
    awardName?: true
    awardedBy?: true
    awardedOn?: true
    descreption?: true
  }

  export type AchievementsAwardsCountAggregateInputType = {
    id?: true
    userId?: true
    awardName?: true
    awardedBy?: true
    awardedOn?: true
    descreption?: true
    _all?: true
  }

  export type AchievementsAwardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementsAwards to aggregate.
     */
    where?: AchievementsAwardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementsAwards to fetch.
     */
    orderBy?: AchievementsAwardsOrderByWithRelationInput | AchievementsAwardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementsAwardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementsAwards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementsAwards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AchievementsAwards
    **/
    _count?: true | AchievementsAwardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementsAwardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementsAwardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementsAwardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementsAwardsMaxAggregateInputType
  }

  export type GetAchievementsAwardsAggregateType<T extends AchievementsAwardsAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievementsAwards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievementsAwards[P]>
      : GetScalarType<T[P], AggregateAchievementsAwards[P]>
  }




  export type AchievementsAwardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementsAwardsWhereInput
    orderBy?: AchievementsAwardsOrderByWithAggregationInput | AchievementsAwardsOrderByWithAggregationInput[]
    by: AchievementsAwardsScalarFieldEnum[] | AchievementsAwardsScalarFieldEnum
    having?: AchievementsAwardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementsAwardsCountAggregateInputType | true
    _avg?: AchievementsAwardsAvgAggregateInputType
    _sum?: AchievementsAwardsSumAggregateInputType
    _min?: AchievementsAwardsMinAggregateInputType
    _max?: AchievementsAwardsMaxAggregateInputType
  }

  export type AchievementsAwardsGroupByOutputType = {
    id: number
    userId: number | null
    awardName: string | null
    awardedBy: string | null
    awardedOn: string | null
    descreption: string | null
    _count: AchievementsAwardsCountAggregateOutputType | null
    _avg: AchievementsAwardsAvgAggregateOutputType | null
    _sum: AchievementsAwardsSumAggregateOutputType | null
    _min: AchievementsAwardsMinAggregateOutputType | null
    _max: AchievementsAwardsMaxAggregateOutputType | null
  }

  type GetAchievementsAwardsGroupByPayload<T extends AchievementsAwardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementsAwardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementsAwardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementsAwardsGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementsAwardsGroupByOutputType[P]>
        }
      >
    >


  export type AchievementsAwardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    awardName?: boolean
    awardedBy?: boolean
    awardedOn?: boolean
    descreption?: boolean
    User?: boolean | AchievementsAwards$UserArgs<ExtArgs>
  }, ExtArgs["result"]["achievementsAwards"]>

  export type AchievementsAwardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    awardName?: boolean
    awardedBy?: boolean
    awardedOn?: boolean
    descreption?: boolean
    User?: boolean | AchievementsAwards$UserArgs<ExtArgs>
  }, ExtArgs["result"]["achievementsAwards"]>

  export type AchievementsAwardsSelectScalar = {
    id?: boolean
    userId?: boolean
    awardName?: boolean
    awardedBy?: boolean
    awardedOn?: boolean
    descreption?: boolean
  }

  export type AchievementsAwardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | AchievementsAwards$UserArgs<ExtArgs>
  }
  export type AchievementsAwardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | AchievementsAwards$UserArgs<ExtArgs>
  }

  export type $AchievementsAwardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AchievementsAwards"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      awardName: string | null
      awardedBy: string | null
      awardedOn: string | null
      descreption: string | null
    }, ExtArgs["result"]["achievementsAwards"]>
    composites: {}
  }

  type AchievementsAwardsGetPayload<S extends boolean | null | undefined | AchievementsAwardsDefaultArgs> = $Result.GetResult<Prisma.$AchievementsAwardsPayload, S>

  type AchievementsAwardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementsAwardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementsAwardsCountAggregateInputType | true
    }

  export interface AchievementsAwardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AchievementsAwards'], meta: { name: 'AchievementsAwards' } }
    /**
     * Find zero or one AchievementsAwards that matches the filter.
     * @param {AchievementsAwardsFindUniqueArgs} args - Arguments to find a AchievementsAwards
     * @example
     * // Get one AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementsAwardsFindUniqueArgs>(args: SelectSubset<T, AchievementsAwardsFindUniqueArgs<ExtArgs>>): Prisma__AchievementsAwardsClient<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AchievementsAwards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementsAwardsFindUniqueOrThrowArgs} args - Arguments to find a AchievementsAwards
     * @example
     * // Get one AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementsAwardsFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementsAwardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementsAwardsClient<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AchievementsAwards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementsAwardsFindFirstArgs} args - Arguments to find a AchievementsAwards
     * @example
     * // Get one AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementsAwardsFindFirstArgs>(args?: SelectSubset<T, AchievementsAwardsFindFirstArgs<ExtArgs>>): Prisma__AchievementsAwardsClient<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AchievementsAwards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementsAwardsFindFirstOrThrowArgs} args - Arguments to find a AchievementsAwards
     * @example
     * // Get one AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementsAwardsFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementsAwardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementsAwardsClient<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AchievementsAwards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementsAwardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.findMany()
     * 
     * // Get first 10 AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementsAwardsWithIdOnly = await prisma.achievementsAwards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementsAwardsFindManyArgs>(args?: SelectSubset<T, AchievementsAwardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AchievementsAwards.
     * @param {AchievementsAwardsCreateArgs} args - Arguments to create a AchievementsAwards.
     * @example
     * // Create one AchievementsAwards
     * const AchievementsAwards = await prisma.achievementsAwards.create({
     *   data: {
     *     // ... data to create a AchievementsAwards
     *   }
     * })
     * 
     */
    create<T extends AchievementsAwardsCreateArgs>(args: SelectSubset<T, AchievementsAwardsCreateArgs<ExtArgs>>): Prisma__AchievementsAwardsClient<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AchievementsAwards.
     * @param {AchievementsAwardsCreateManyArgs} args - Arguments to create many AchievementsAwards.
     * @example
     * // Create many AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementsAwardsCreateManyArgs>(args?: SelectSubset<T, AchievementsAwardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AchievementsAwards and returns the data saved in the database.
     * @param {AchievementsAwardsCreateManyAndReturnArgs} args - Arguments to create many AchievementsAwards.
     * @example
     * // Create many AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AchievementsAwards and only return the `id`
     * const achievementsAwardsWithIdOnly = await prisma.achievementsAwards.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementsAwardsCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementsAwardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AchievementsAwards.
     * @param {AchievementsAwardsDeleteArgs} args - Arguments to delete one AchievementsAwards.
     * @example
     * // Delete one AchievementsAwards
     * const AchievementsAwards = await prisma.achievementsAwards.delete({
     *   where: {
     *     // ... filter to delete one AchievementsAwards
     *   }
     * })
     * 
     */
    delete<T extends AchievementsAwardsDeleteArgs>(args: SelectSubset<T, AchievementsAwardsDeleteArgs<ExtArgs>>): Prisma__AchievementsAwardsClient<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AchievementsAwards.
     * @param {AchievementsAwardsUpdateArgs} args - Arguments to update one AchievementsAwards.
     * @example
     * // Update one AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementsAwardsUpdateArgs>(args: SelectSubset<T, AchievementsAwardsUpdateArgs<ExtArgs>>): Prisma__AchievementsAwardsClient<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AchievementsAwards.
     * @param {AchievementsAwardsDeleteManyArgs} args - Arguments to filter AchievementsAwards to delete.
     * @example
     * // Delete a few AchievementsAwards
     * const { count } = await prisma.achievementsAwards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementsAwardsDeleteManyArgs>(args?: SelectSubset<T, AchievementsAwardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AchievementsAwards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementsAwardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementsAwardsUpdateManyArgs>(args: SelectSubset<T, AchievementsAwardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AchievementsAwards.
     * @param {AchievementsAwardsUpsertArgs} args - Arguments to update or create a AchievementsAwards.
     * @example
     * // Update or create a AchievementsAwards
     * const achievementsAwards = await prisma.achievementsAwards.upsert({
     *   create: {
     *     // ... data to create a AchievementsAwards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AchievementsAwards we want to update
     *   }
     * })
     */
    upsert<T extends AchievementsAwardsUpsertArgs>(args: SelectSubset<T, AchievementsAwardsUpsertArgs<ExtArgs>>): Prisma__AchievementsAwardsClient<$Result.GetResult<Prisma.$AchievementsAwardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AchievementsAwards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementsAwardsCountArgs} args - Arguments to filter AchievementsAwards to count.
     * @example
     * // Count the number of AchievementsAwards
     * const count = await prisma.achievementsAwards.count({
     *   where: {
     *     // ... the filter for the AchievementsAwards we want to count
     *   }
     * })
    **/
    count<T extends AchievementsAwardsCountArgs>(
      args?: Subset<T, AchievementsAwardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementsAwardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AchievementsAwards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementsAwardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementsAwardsAggregateArgs>(args: Subset<T, AchievementsAwardsAggregateArgs>): Prisma.PrismaPromise<GetAchievementsAwardsAggregateType<T>>

    /**
     * Group by AchievementsAwards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementsAwardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementsAwardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementsAwardsGroupByArgs['orderBy'] }
        : { orderBy?: AchievementsAwardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementsAwardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementsAwardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AchievementsAwards model
   */
  readonly fields: AchievementsAwardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AchievementsAwards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementsAwardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends AchievementsAwards$UserArgs<ExtArgs> = {}>(args?: Subset<T, AchievementsAwards$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AchievementsAwards model
   */ 
  interface AchievementsAwardsFieldRefs {
    readonly id: FieldRef<"AchievementsAwards", 'Int'>
    readonly userId: FieldRef<"AchievementsAwards", 'Int'>
    readonly awardName: FieldRef<"AchievementsAwards", 'String'>
    readonly awardedBy: FieldRef<"AchievementsAwards", 'String'>
    readonly awardedOn: FieldRef<"AchievementsAwards", 'String'>
    readonly descreption: FieldRef<"AchievementsAwards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AchievementsAwards findUnique
   */
  export type AchievementsAwardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    /**
     * Filter, which AchievementsAwards to fetch.
     */
    where: AchievementsAwardsWhereUniqueInput
  }

  /**
   * AchievementsAwards findUniqueOrThrow
   */
  export type AchievementsAwardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    /**
     * Filter, which AchievementsAwards to fetch.
     */
    where: AchievementsAwardsWhereUniqueInput
  }

  /**
   * AchievementsAwards findFirst
   */
  export type AchievementsAwardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    /**
     * Filter, which AchievementsAwards to fetch.
     */
    where?: AchievementsAwardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementsAwards to fetch.
     */
    orderBy?: AchievementsAwardsOrderByWithRelationInput | AchievementsAwardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementsAwards.
     */
    cursor?: AchievementsAwardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementsAwards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementsAwards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementsAwards.
     */
    distinct?: AchievementsAwardsScalarFieldEnum | AchievementsAwardsScalarFieldEnum[]
  }

  /**
   * AchievementsAwards findFirstOrThrow
   */
  export type AchievementsAwardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    /**
     * Filter, which AchievementsAwards to fetch.
     */
    where?: AchievementsAwardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementsAwards to fetch.
     */
    orderBy?: AchievementsAwardsOrderByWithRelationInput | AchievementsAwardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementsAwards.
     */
    cursor?: AchievementsAwardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementsAwards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementsAwards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementsAwards.
     */
    distinct?: AchievementsAwardsScalarFieldEnum | AchievementsAwardsScalarFieldEnum[]
  }

  /**
   * AchievementsAwards findMany
   */
  export type AchievementsAwardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    /**
     * Filter, which AchievementsAwards to fetch.
     */
    where?: AchievementsAwardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementsAwards to fetch.
     */
    orderBy?: AchievementsAwardsOrderByWithRelationInput | AchievementsAwardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AchievementsAwards.
     */
    cursor?: AchievementsAwardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementsAwards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementsAwards.
     */
    skip?: number
    distinct?: AchievementsAwardsScalarFieldEnum | AchievementsAwardsScalarFieldEnum[]
  }

  /**
   * AchievementsAwards create
   */
  export type AchievementsAwardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    /**
     * The data needed to create a AchievementsAwards.
     */
    data?: XOR<AchievementsAwardsCreateInput, AchievementsAwardsUncheckedCreateInput>
  }

  /**
   * AchievementsAwards createMany
   */
  export type AchievementsAwardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AchievementsAwards.
     */
    data: AchievementsAwardsCreateManyInput | AchievementsAwardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AchievementsAwards createManyAndReturn
   */
  export type AchievementsAwardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AchievementsAwards.
     */
    data: AchievementsAwardsCreateManyInput | AchievementsAwardsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AchievementsAwards update
   */
  export type AchievementsAwardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    /**
     * The data needed to update a AchievementsAwards.
     */
    data: XOR<AchievementsAwardsUpdateInput, AchievementsAwardsUncheckedUpdateInput>
    /**
     * Choose, which AchievementsAwards to update.
     */
    where: AchievementsAwardsWhereUniqueInput
  }

  /**
   * AchievementsAwards updateMany
   */
  export type AchievementsAwardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AchievementsAwards.
     */
    data: XOR<AchievementsAwardsUpdateManyMutationInput, AchievementsAwardsUncheckedUpdateManyInput>
    /**
     * Filter which AchievementsAwards to update
     */
    where?: AchievementsAwardsWhereInput
  }

  /**
   * AchievementsAwards upsert
   */
  export type AchievementsAwardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    /**
     * The filter to search for the AchievementsAwards to update in case it exists.
     */
    where: AchievementsAwardsWhereUniqueInput
    /**
     * In case the AchievementsAwards found by the `where` argument doesn't exist, create a new AchievementsAwards with this data.
     */
    create: XOR<AchievementsAwardsCreateInput, AchievementsAwardsUncheckedCreateInput>
    /**
     * In case the AchievementsAwards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementsAwardsUpdateInput, AchievementsAwardsUncheckedUpdateInput>
  }

  /**
   * AchievementsAwards delete
   */
  export type AchievementsAwardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
    /**
     * Filter which AchievementsAwards to delete.
     */
    where: AchievementsAwardsWhereUniqueInput
  }

  /**
   * AchievementsAwards deleteMany
   */
  export type AchievementsAwardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementsAwards to delete
     */
    where?: AchievementsAwardsWhereInput
  }

  /**
   * AchievementsAwards.User
   */
  export type AchievementsAwards$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AchievementsAwards without action
   */
  export type AchievementsAwardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementsAwards
     */
    select?: AchievementsAwardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementsAwardsInclude<ExtArgs> | null
  }


  /**
   * Model Organisations
   */

  export type AggregateOrganisations = {
    _count: OrganisationsCountAggregateOutputType | null
    _avg: OrganisationsAvgAggregateOutputType | null
    _sum: OrganisationsSumAggregateOutputType | null
    _min: OrganisationsMinAggregateOutputType | null
    _max: OrganisationsMaxAggregateOutputType | null
  }

  export type OrganisationsAvgAggregateOutputType = {
    id: number | null
  }

  export type OrganisationsSumAggregateOutputType = {
    id: number | null
  }

  export type OrganisationsMinAggregateOutputType = {
    id: number | null
    category: string | null
    email: string | null
    password: string | null
    organisation_name: string | null
    country: string | null
    city: string | null
    organisation_type: string | null
    register_number: string | null
    verified: boolean | null
    founding_year: Date | null
    created_at: Date | null
  }

  export type OrganisationsMaxAggregateOutputType = {
    id: number | null
    category: string | null
    email: string | null
    password: string | null
    organisation_name: string | null
    country: string | null
    city: string | null
    organisation_type: string | null
    register_number: string | null
    verified: boolean | null
    founding_year: Date | null
    created_at: Date | null
  }

  export type OrganisationsCountAggregateOutputType = {
    id: number
    category: number
    email: number
    password: number
    organisation_name: number
    country: number
    city: number
    organisation_type: number
    register_number: number
    verified: number
    founding_year: number
    created_at: number
    _all: number
  }


  export type OrganisationsAvgAggregateInputType = {
    id?: true
  }

  export type OrganisationsSumAggregateInputType = {
    id?: true
  }

  export type OrganisationsMinAggregateInputType = {
    id?: true
    category?: true
    email?: true
    password?: true
    organisation_name?: true
    country?: true
    city?: true
    organisation_type?: true
    register_number?: true
    verified?: true
    founding_year?: true
    created_at?: true
  }

  export type OrganisationsMaxAggregateInputType = {
    id?: true
    category?: true
    email?: true
    password?: true
    organisation_name?: true
    country?: true
    city?: true
    organisation_type?: true
    register_number?: true
    verified?: true
    founding_year?: true
    created_at?: true
  }

  export type OrganisationsCountAggregateInputType = {
    id?: true
    category?: true
    email?: true
    password?: true
    organisation_name?: true
    country?: true
    city?: true
    organisation_type?: true
    register_number?: true
    verified?: true
    founding_year?: true
    created_at?: true
    _all?: true
  }

  export type OrganisationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisations to aggregate.
     */
    where?: OrganisationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationsOrderByWithRelationInput | OrganisationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganisationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organisations
    **/
    _count?: true | OrganisationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganisationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganisationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationsMaxAggregateInputType
  }

  export type GetOrganisationsAggregateType<T extends OrganisationsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisations[P]>
      : GetScalarType<T[P], AggregateOrganisations[P]>
  }




  export type OrganisationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationsWhereInput
    orderBy?: OrganisationsOrderByWithAggregationInput | OrganisationsOrderByWithAggregationInput[]
    by: OrganisationsScalarFieldEnum[] | OrganisationsScalarFieldEnum
    having?: OrganisationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationsCountAggregateInputType | true
    _avg?: OrganisationsAvgAggregateInputType
    _sum?: OrganisationsSumAggregateInputType
    _min?: OrganisationsMinAggregateInputType
    _max?: OrganisationsMaxAggregateInputType
  }

  export type OrganisationsGroupByOutputType = {
    id: number
    category: string
    email: string
    password: string
    organisation_name: string | null
    country: string | null
    city: string | null
    organisation_type: string | null
    register_number: string | null
    verified: boolean
    founding_year: Date | null
    created_at: Date
    _count: OrganisationsCountAggregateOutputType | null
    _avg: OrganisationsAvgAggregateOutputType | null
    _sum: OrganisationsSumAggregateOutputType | null
    _min: OrganisationsMinAggregateOutputType | null
    _max: OrganisationsMaxAggregateOutputType | null
  }

  type GetOrganisationsGroupByPayload<T extends OrganisationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationsGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationsGroupByOutputType[P]>
        }
      >
    >


  export type OrganisationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    email?: boolean
    password?: boolean
    organisation_name?: boolean
    country?: boolean
    city?: boolean
    organisation_type?: boolean
    register_number?: boolean
    verified?: boolean
    founding_year?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["organisations"]>

  export type OrganisationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    email?: boolean
    password?: boolean
    organisation_name?: boolean
    country?: boolean
    city?: boolean
    organisation_type?: boolean
    register_number?: boolean
    verified?: boolean
    founding_year?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["organisations"]>

  export type OrganisationsSelectScalar = {
    id?: boolean
    category?: boolean
    email?: boolean
    password?: boolean
    organisation_name?: boolean
    country?: boolean
    city?: boolean
    organisation_type?: boolean
    register_number?: boolean
    verified?: boolean
    founding_year?: boolean
    created_at?: boolean
  }


  export type $OrganisationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organisations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string
      email: string
      password: string
      organisation_name: string | null
      country: string | null
      city: string | null
      organisation_type: string | null
      register_number: string | null
      verified: boolean
      founding_year: Date | null
      created_at: Date
    }, ExtArgs["result"]["organisations"]>
    composites: {}
  }

  type OrganisationsGetPayload<S extends boolean | null | undefined | OrganisationsDefaultArgs> = $Result.GetResult<Prisma.$OrganisationsPayload, S>

  type OrganisationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganisationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganisationsCountAggregateInputType | true
    }

  export interface OrganisationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organisations'], meta: { name: 'Organisations' } }
    /**
     * Find zero or one Organisations that matches the filter.
     * @param {OrganisationsFindUniqueArgs} args - Arguments to find a Organisations
     * @example
     * // Get one Organisations
     * const organisations = await prisma.organisations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganisationsFindUniqueArgs>(args: SelectSubset<T, OrganisationsFindUniqueArgs<ExtArgs>>): Prisma__OrganisationsClient<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organisations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganisationsFindUniqueOrThrowArgs} args - Arguments to find a Organisations
     * @example
     * // Get one Organisations
     * const organisations = await prisma.organisations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganisationsFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganisationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganisationsClient<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationsFindFirstArgs} args - Arguments to find a Organisations
     * @example
     * // Get one Organisations
     * const organisations = await prisma.organisations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganisationsFindFirstArgs>(args?: SelectSubset<T, OrganisationsFindFirstArgs<ExtArgs>>): Prisma__OrganisationsClient<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organisations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationsFindFirstOrThrowArgs} args - Arguments to find a Organisations
     * @example
     * // Get one Organisations
     * const organisations = await prisma.organisations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganisationsFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganisationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganisationsClient<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organisations
     * const organisations = await prisma.organisations.findMany()
     * 
     * // Get first 10 Organisations
     * const organisations = await prisma.organisations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationsWithIdOnly = await prisma.organisations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganisationsFindManyArgs>(args?: SelectSubset<T, OrganisationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organisations.
     * @param {OrganisationsCreateArgs} args - Arguments to create a Organisations.
     * @example
     * // Create one Organisations
     * const Organisations = await prisma.organisations.create({
     *   data: {
     *     // ... data to create a Organisations
     *   }
     * })
     * 
     */
    create<T extends OrganisationsCreateArgs>(args: SelectSubset<T, OrganisationsCreateArgs<ExtArgs>>): Prisma__OrganisationsClient<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organisations.
     * @param {OrganisationsCreateManyArgs} args - Arguments to create many Organisations.
     * @example
     * // Create many Organisations
     * const organisations = await prisma.organisations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganisationsCreateManyArgs>(args?: SelectSubset<T, OrganisationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organisations and returns the data saved in the database.
     * @param {OrganisationsCreateManyAndReturnArgs} args - Arguments to create many Organisations.
     * @example
     * // Create many Organisations
     * const organisations = await prisma.organisations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organisations and only return the `id`
     * const organisationsWithIdOnly = await prisma.organisations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganisationsCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganisationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organisations.
     * @param {OrganisationsDeleteArgs} args - Arguments to delete one Organisations.
     * @example
     * // Delete one Organisations
     * const Organisations = await prisma.organisations.delete({
     *   where: {
     *     // ... filter to delete one Organisations
     *   }
     * })
     * 
     */
    delete<T extends OrganisationsDeleteArgs>(args: SelectSubset<T, OrganisationsDeleteArgs<ExtArgs>>): Prisma__OrganisationsClient<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organisations.
     * @param {OrganisationsUpdateArgs} args - Arguments to update one Organisations.
     * @example
     * // Update one Organisations
     * const organisations = await prisma.organisations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganisationsUpdateArgs>(args: SelectSubset<T, OrganisationsUpdateArgs<ExtArgs>>): Prisma__OrganisationsClient<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organisations.
     * @param {OrganisationsDeleteManyArgs} args - Arguments to filter Organisations to delete.
     * @example
     * // Delete a few Organisations
     * const { count } = await prisma.organisations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganisationsDeleteManyArgs>(args?: SelectSubset<T, OrganisationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organisations
     * const organisations = await prisma.organisations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganisationsUpdateManyArgs>(args: SelectSubset<T, OrganisationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organisations.
     * @param {OrganisationsUpsertArgs} args - Arguments to update or create a Organisations.
     * @example
     * // Update or create a Organisations
     * const organisations = await prisma.organisations.upsert({
     *   create: {
     *     // ... data to create a Organisations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organisations we want to update
     *   }
     * })
     */
    upsert<T extends OrganisationsUpsertArgs>(args: SelectSubset<T, OrganisationsUpsertArgs<ExtArgs>>): Prisma__OrganisationsClient<$Result.GetResult<Prisma.$OrganisationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationsCountArgs} args - Arguments to filter Organisations to count.
     * @example
     * // Count the number of Organisations
     * const count = await prisma.organisations.count({
     *   where: {
     *     // ... the filter for the Organisations we want to count
     *   }
     * })
    **/
    count<T extends OrganisationsCountArgs>(
      args?: Subset<T, OrganisationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationsAggregateArgs>(args: Subset<T, OrganisationsAggregateArgs>): Prisma.PrismaPromise<GetOrganisationsAggregateType<T>>

    /**
     * Group by Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganisationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganisationsGroupByArgs['orderBy'] }
        : { orderBy?: OrganisationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganisationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organisations model
   */
  readonly fields: OrganisationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organisations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganisationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organisations model
   */ 
  interface OrganisationsFieldRefs {
    readonly id: FieldRef<"Organisations", 'Int'>
    readonly category: FieldRef<"Organisations", 'String'>
    readonly email: FieldRef<"Organisations", 'String'>
    readonly password: FieldRef<"Organisations", 'String'>
    readonly organisation_name: FieldRef<"Organisations", 'String'>
    readonly country: FieldRef<"Organisations", 'String'>
    readonly city: FieldRef<"Organisations", 'String'>
    readonly organisation_type: FieldRef<"Organisations", 'String'>
    readonly register_number: FieldRef<"Organisations", 'String'>
    readonly verified: FieldRef<"Organisations", 'Boolean'>
    readonly founding_year: FieldRef<"Organisations", 'DateTime'>
    readonly created_at: FieldRef<"Organisations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organisations findUnique
   */
  export type OrganisationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
    /**
     * Filter, which Organisations to fetch.
     */
    where: OrganisationsWhereUniqueInput
  }

  /**
   * Organisations findUniqueOrThrow
   */
  export type OrganisationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
    /**
     * Filter, which Organisations to fetch.
     */
    where: OrganisationsWhereUniqueInput
  }

  /**
   * Organisations findFirst
   */
  export type OrganisationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
    /**
     * Filter, which Organisations to fetch.
     */
    where?: OrganisationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationsOrderByWithRelationInput | OrganisationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationsScalarFieldEnum | OrganisationsScalarFieldEnum[]
  }

  /**
   * Organisations findFirstOrThrow
   */
  export type OrganisationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
    /**
     * Filter, which Organisations to fetch.
     */
    where?: OrganisationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationsOrderByWithRelationInput | OrganisationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationsScalarFieldEnum | OrganisationsScalarFieldEnum[]
  }

  /**
   * Organisations findMany
   */
  export type OrganisationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
    /**
     * Filter, which Organisations to fetch.
     */
    where?: OrganisationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationsOrderByWithRelationInput | OrganisationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organisations.
     */
    cursor?: OrganisationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    distinct?: OrganisationsScalarFieldEnum | OrganisationsScalarFieldEnum[]
  }

  /**
   * Organisations create
   */
  export type OrganisationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
    /**
     * The data needed to create a Organisations.
     */
    data: XOR<OrganisationsCreateInput, OrganisationsUncheckedCreateInput>
  }

  /**
   * Organisations createMany
   */
  export type OrganisationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organisations.
     */
    data: OrganisationsCreateManyInput | OrganisationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organisations createManyAndReturn
   */
  export type OrganisationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organisations.
     */
    data: OrganisationsCreateManyInput | OrganisationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organisations update
   */
  export type OrganisationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
    /**
     * The data needed to update a Organisations.
     */
    data: XOR<OrganisationsUpdateInput, OrganisationsUncheckedUpdateInput>
    /**
     * Choose, which Organisations to update.
     */
    where: OrganisationsWhereUniqueInput
  }

  /**
   * Organisations updateMany
   */
  export type OrganisationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organisations.
     */
    data: XOR<OrganisationsUpdateManyMutationInput, OrganisationsUncheckedUpdateManyInput>
    /**
     * Filter which Organisations to update
     */
    where?: OrganisationsWhereInput
  }

  /**
   * Organisations upsert
   */
  export type OrganisationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
    /**
     * The filter to search for the Organisations to update in case it exists.
     */
    where: OrganisationsWhereUniqueInput
    /**
     * In case the Organisations found by the `where` argument doesn't exist, create a new Organisations with this data.
     */
    create: XOR<OrganisationsCreateInput, OrganisationsUncheckedCreateInput>
    /**
     * In case the Organisations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganisationsUpdateInput, OrganisationsUncheckedUpdateInput>
  }

  /**
   * Organisations delete
   */
  export type OrganisationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
    /**
     * Filter which Organisations to delete.
     */
    where: OrganisationsWhereUniqueInput
  }

  /**
   * Organisations deleteMany
   */
  export type OrganisationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisations to delete
     */
    where?: OrganisationsWhereInput
  }

  /**
   * Organisations without action
   */
  export type OrganisationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisations
     */
    select?: OrganisationsSelect<ExtArgs> | null
  }


  /**
   * Model Jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type JobsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type JobsMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type JobsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type JobsCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type JobsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type JobsMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type JobsMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type JobsCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to aggregate.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type JobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithAggregationInput | JobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: JobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    id: number
    userId: number | null
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends JobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type JobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    User?: boolean | Jobs$UserArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type JobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    User?: boolean | Jobs$UserArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type JobsSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type JobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Jobs$UserArgs<ExtArgs>
  }
  export type JobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Jobs$UserArgs<ExtArgs>
  }

  export type $JobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jobs"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type JobsGetPayload<S extends boolean | null | undefined | JobsDefaultArgs> = $Result.GetResult<Prisma.$JobsPayload, S>

  type JobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface JobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jobs'], meta: { name: 'Jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {JobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobsFindUniqueArgs>(args: SelectSubset<T, JobsFindUniqueArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobsFindUniqueOrThrowArgs>(args: SelectSubset<T, JobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobsFindFirstArgs>(args?: SelectSubset<T, JobsFindFirstArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobsFindFirstOrThrowArgs>(args?: SelectSubset<T, JobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobsWithIdOnly = await prisma.jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobsFindManyArgs>(args?: SelectSubset<T, JobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Jobs.
     * @param {JobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends JobsCreateArgs>(args: SelectSubset<T, JobsCreateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Jobs.
     * @param {JobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobsCreateManyArgs>(args?: SelectSubset<T, JobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobsCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobsWithIdOnly = await prisma.jobs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobsCreateManyAndReturnArgs>(args?: SelectSubset<T, JobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Jobs.
     * @param {JobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends JobsDeleteArgs>(args: SelectSubset<T, JobsDeleteArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Jobs.
     * @param {JobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobsUpdateArgs>(args: SelectSubset<T, JobsUpdateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Jobs.
     * @param {JobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobsDeleteManyArgs>(args?: SelectSubset<T, JobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobsUpdateManyArgs>(args: SelectSubset<T, JobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobs.
     * @param {JobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends JobsUpsertArgs>(args: SelectSubset<T, JobsUpsertArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobsCountArgs>(
      args?: Subset<T, JobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobsGroupByArgs['orderBy'] }
        : { orderBy?: JobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jobs model
   */
  readonly fields: JobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Jobs$UserArgs<ExtArgs> = {}>(args?: Subset<T, Jobs$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jobs model
   */ 
  interface JobsFieldRefs {
    readonly id: FieldRef<"Jobs", 'Int'>
    readonly userId: FieldRef<"Jobs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Jobs findUnique
   */
  export type JobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findUniqueOrThrow
   */
  export type JobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findFirst
   */
  export type JobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findFirstOrThrow
   */
  export type JobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findMany
   */
  export type JobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs create
   */
  export type JobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The data needed to create a Jobs.
     */
    data?: XOR<JobsCreateInput, JobsUncheckedCreateInput>
  }

  /**
   * Jobs createMany
   */
  export type JobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobsCreateManyInput | JobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jobs createManyAndReturn
   */
  export type JobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobsCreateManyInput | JobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Jobs update
   */
  export type JobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The data needed to update a Jobs.
     */
    data: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
    /**
     * Choose, which Jobs to update.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs updateMany
   */
  export type JobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobsWhereInput
  }

  /**
   * Jobs upsert
   */
  export type JobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The filter to search for the Jobs to update in case it exists.
     */
    where: JobsWhereUniqueInput
    /**
     * In case the Jobs found by the `where` argument doesn't exist, create a new Jobs with this data.
     */
    create: XOR<JobsCreateInput, JobsUncheckedCreateInput>
    /**
     * In case the Jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
  }

  /**
   * Jobs delete
   */
  export type JobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter which Jobs to delete.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs deleteMany
   */
  export type JobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobsWhereInput
  }

  /**
   * Jobs.User
   */
  export type Jobs$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Jobs without action
   */
  export type JobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
  }


  /**
   * Model Conferrences
   */

  export type AggregateConferrences = {
    _count: ConferrencesCountAggregateOutputType | null
    _avg: ConferrencesAvgAggregateOutputType | null
    _sum: ConferrencesSumAggregateOutputType | null
    _min: ConferrencesMinAggregateOutputType | null
    _max: ConferrencesMaxAggregateOutputType | null
  }

  export type ConferrencesAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConferrencesSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConferrencesMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConferrencesMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ConferrencesCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type ConferrencesAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConferrencesSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConferrencesMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConferrencesMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ConferrencesCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type ConferrencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conferrences to aggregate.
     */
    where?: ConferrencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferrences to fetch.
     */
    orderBy?: ConferrencesOrderByWithRelationInput | ConferrencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferrencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conferrences
    **/
    _count?: true | ConferrencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferrencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferrencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferrencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferrencesMaxAggregateInputType
  }

  export type GetConferrencesAggregateType<T extends ConferrencesAggregateArgs> = {
        [P in keyof T & keyof AggregateConferrences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferrences[P]>
      : GetScalarType<T[P], AggregateConferrences[P]>
  }




  export type ConferrencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferrencesWhereInput
    orderBy?: ConferrencesOrderByWithAggregationInput | ConferrencesOrderByWithAggregationInput[]
    by: ConferrencesScalarFieldEnum[] | ConferrencesScalarFieldEnum
    having?: ConferrencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferrencesCountAggregateInputType | true
    _avg?: ConferrencesAvgAggregateInputType
    _sum?: ConferrencesSumAggregateInputType
    _min?: ConferrencesMinAggregateInputType
    _max?: ConferrencesMaxAggregateInputType
  }

  export type ConferrencesGroupByOutputType = {
    id: number
    userId: number | null
    _count: ConferrencesCountAggregateOutputType | null
    _avg: ConferrencesAvgAggregateOutputType | null
    _sum: ConferrencesSumAggregateOutputType | null
    _min: ConferrencesMinAggregateOutputType | null
    _max: ConferrencesMaxAggregateOutputType | null
  }

  type GetConferrencesGroupByPayload<T extends ConferrencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferrencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferrencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferrencesGroupByOutputType[P]>
            : GetScalarType<T[P], ConferrencesGroupByOutputType[P]>
        }
      >
    >


  export type ConferrencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    User?: boolean | Conferrences$UserArgs<ExtArgs>
  }, ExtArgs["result"]["conferrences"]>

  export type ConferrencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    User?: boolean | Conferrences$UserArgs<ExtArgs>
  }, ExtArgs["result"]["conferrences"]>

  export type ConferrencesSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type ConferrencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Conferrences$UserArgs<ExtArgs>
  }
  export type ConferrencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Conferrences$UserArgs<ExtArgs>
  }

  export type $ConferrencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conferrences"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
    }, ExtArgs["result"]["conferrences"]>
    composites: {}
  }

  type ConferrencesGetPayload<S extends boolean | null | undefined | ConferrencesDefaultArgs> = $Result.GetResult<Prisma.$ConferrencesPayload, S>

  type ConferrencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConferrencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConferrencesCountAggregateInputType | true
    }

  export interface ConferrencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conferrences'], meta: { name: 'Conferrences' } }
    /**
     * Find zero or one Conferrences that matches the filter.
     * @param {ConferrencesFindUniqueArgs} args - Arguments to find a Conferrences
     * @example
     * // Get one Conferrences
     * const conferrences = await prisma.conferrences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferrencesFindUniqueArgs>(args: SelectSubset<T, ConferrencesFindUniqueArgs<ExtArgs>>): Prisma__ConferrencesClient<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conferrences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConferrencesFindUniqueOrThrowArgs} args - Arguments to find a Conferrences
     * @example
     * // Get one Conferrences
     * const conferrences = await prisma.conferrences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferrencesFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferrencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferrencesClient<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conferrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferrencesFindFirstArgs} args - Arguments to find a Conferrences
     * @example
     * // Get one Conferrences
     * const conferrences = await prisma.conferrences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferrencesFindFirstArgs>(args?: SelectSubset<T, ConferrencesFindFirstArgs<ExtArgs>>): Prisma__ConferrencesClient<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conferrences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferrencesFindFirstOrThrowArgs} args - Arguments to find a Conferrences
     * @example
     * // Get one Conferrences
     * const conferrences = await prisma.conferrences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferrencesFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferrencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferrencesClient<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conferrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferrencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conferrences
     * const conferrences = await prisma.conferrences.findMany()
     * 
     * // Get first 10 Conferrences
     * const conferrences = await prisma.conferrences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferrencesWithIdOnly = await prisma.conferrences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferrencesFindManyArgs>(args?: SelectSubset<T, ConferrencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conferrences.
     * @param {ConferrencesCreateArgs} args - Arguments to create a Conferrences.
     * @example
     * // Create one Conferrences
     * const Conferrences = await prisma.conferrences.create({
     *   data: {
     *     // ... data to create a Conferrences
     *   }
     * })
     * 
     */
    create<T extends ConferrencesCreateArgs>(args: SelectSubset<T, ConferrencesCreateArgs<ExtArgs>>): Prisma__ConferrencesClient<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conferrences.
     * @param {ConferrencesCreateManyArgs} args - Arguments to create many Conferrences.
     * @example
     * // Create many Conferrences
     * const conferrences = await prisma.conferrences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferrencesCreateManyArgs>(args?: SelectSubset<T, ConferrencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conferrences and returns the data saved in the database.
     * @param {ConferrencesCreateManyAndReturnArgs} args - Arguments to create many Conferrences.
     * @example
     * // Create many Conferrences
     * const conferrences = await prisma.conferrences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conferrences and only return the `id`
     * const conferrencesWithIdOnly = await prisma.conferrences.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferrencesCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferrencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conferrences.
     * @param {ConferrencesDeleteArgs} args - Arguments to delete one Conferrences.
     * @example
     * // Delete one Conferrences
     * const Conferrences = await prisma.conferrences.delete({
     *   where: {
     *     // ... filter to delete one Conferrences
     *   }
     * })
     * 
     */
    delete<T extends ConferrencesDeleteArgs>(args: SelectSubset<T, ConferrencesDeleteArgs<ExtArgs>>): Prisma__ConferrencesClient<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conferrences.
     * @param {ConferrencesUpdateArgs} args - Arguments to update one Conferrences.
     * @example
     * // Update one Conferrences
     * const conferrences = await prisma.conferrences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferrencesUpdateArgs>(args: SelectSubset<T, ConferrencesUpdateArgs<ExtArgs>>): Prisma__ConferrencesClient<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conferrences.
     * @param {ConferrencesDeleteManyArgs} args - Arguments to filter Conferrences to delete.
     * @example
     * // Delete a few Conferrences
     * const { count } = await prisma.conferrences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferrencesDeleteManyArgs>(args?: SelectSubset<T, ConferrencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conferrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferrencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conferrences
     * const conferrences = await prisma.conferrences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferrencesUpdateManyArgs>(args: SelectSubset<T, ConferrencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conferrences.
     * @param {ConferrencesUpsertArgs} args - Arguments to update or create a Conferrences.
     * @example
     * // Update or create a Conferrences
     * const conferrences = await prisma.conferrences.upsert({
     *   create: {
     *     // ... data to create a Conferrences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conferrences we want to update
     *   }
     * })
     */
    upsert<T extends ConferrencesUpsertArgs>(args: SelectSubset<T, ConferrencesUpsertArgs<ExtArgs>>): Prisma__ConferrencesClient<$Result.GetResult<Prisma.$ConferrencesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conferrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferrencesCountArgs} args - Arguments to filter Conferrences to count.
     * @example
     * // Count the number of Conferrences
     * const count = await prisma.conferrences.count({
     *   where: {
     *     // ... the filter for the Conferrences we want to count
     *   }
     * })
    **/
    count<T extends ConferrencesCountArgs>(
      args?: Subset<T, ConferrencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferrencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conferrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferrencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferrencesAggregateArgs>(args: Subset<T, ConferrencesAggregateArgs>): Prisma.PrismaPromise<GetConferrencesAggregateType<T>>

    /**
     * Group by Conferrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferrencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferrencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferrencesGroupByArgs['orderBy'] }
        : { orderBy?: ConferrencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferrencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferrencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conferrences model
   */
  readonly fields: ConferrencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conferrences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferrencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Conferrences$UserArgs<ExtArgs> = {}>(args?: Subset<T, Conferrences$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conferrences model
   */ 
  interface ConferrencesFieldRefs {
    readonly id: FieldRef<"Conferrences", 'Int'>
    readonly userId: FieldRef<"Conferrences", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Conferrences findUnique
   */
  export type ConferrencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferrences to fetch.
     */
    where: ConferrencesWhereUniqueInput
  }

  /**
   * Conferrences findUniqueOrThrow
   */
  export type ConferrencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferrences to fetch.
     */
    where: ConferrencesWhereUniqueInput
  }

  /**
   * Conferrences findFirst
   */
  export type ConferrencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferrences to fetch.
     */
    where?: ConferrencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferrences to fetch.
     */
    orderBy?: ConferrencesOrderByWithRelationInput | ConferrencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conferrences.
     */
    cursor?: ConferrencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conferrences.
     */
    distinct?: ConferrencesScalarFieldEnum | ConferrencesScalarFieldEnum[]
  }

  /**
   * Conferrences findFirstOrThrow
   */
  export type ConferrencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferrences to fetch.
     */
    where?: ConferrencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferrences to fetch.
     */
    orderBy?: ConferrencesOrderByWithRelationInput | ConferrencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conferrences.
     */
    cursor?: ConferrencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conferrences.
     */
    distinct?: ConferrencesScalarFieldEnum | ConferrencesScalarFieldEnum[]
  }

  /**
   * Conferrences findMany
   */
  export type ConferrencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferrences to fetch.
     */
    where?: ConferrencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferrences to fetch.
     */
    orderBy?: ConferrencesOrderByWithRelationInput | ConferrencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conferrences.
     */
    cursor?: ConferrencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferrences.
     */
    skip?: number
    distinct?: ConferrencesScalarFieldEnum | ConferrencesScalarFieldEnum[]
  }

  /**
   * Conferrences create
   */
  export type ConferrencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    /**
     * The data needed to create a Conferrences.
     */
    data?: XOR<ConferrencesCreateInput, ConferrencesUncheckedCreateInput>
  }

  /**
   * Conferrences createMany
   */
  export type ConferrencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conferrences.
     */
    data: ConferrencesCreateManyInput | ConferrencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conferrences createManyAndReturn
   */
  export type ConferrencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conferrences.
     */
    data: ConferrencesCreateManyInput | ConferrencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conferrences update
   */
  export type ConferrencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    /**
     * The data needed to update a Conferrences.
     */
    data: XOR<ConferrencesUpdateInput, ConferrencesUncheckedUpdateInput>
    /**
     * Choose, which Conferrences to update.
     */
    where: ConferrencesWhereUniqueInput
  }

  /**
   * Conferrences updateMany
   */
  export type ConferrencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conferrences.
     */
    data: XOR<ConferrencesUpdateManyMutationInput, ConferrencesUncheckedUpdateManyInput>
    /**
     * Filter which Conferrences to update
     */
    where?: ConferrencesWhereInput
  }

  /**
   * Conferrences upsert
   */
  export type ConferrencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    /**
     * The filter to search for the Conferrences to update in case it exists.
     */
    where: ConferrencesWhereUniqueInput
    /**
     * In case the Conferrences found by the `where` argument doesn't exist, create a new Conferrences with this data.
     */
    create: XOR<ConferrencesCreateInput, ConferrencesUncheckedCreateInput>
    /**
     * In case the Conferrences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferrencesUpdateInput, ConferrencesUncheckedUpdateInput>
  }

  /**
   * Conferrences delete
   */
  export type ConferrencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
    /**
     * Filter which Conferrences to delete.
     */
    where: ConferrencesWhereUniqueInput
  }

  /**
   * Conferrences deleteMany
   */
  export type ConferrencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conferrences to delete
     */
    where?: ConferrencesWhereInput
  }

  /**
   * Conferrences.User
   */
  export type Conferrences$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Conferrences without action
   */
  export type ConferrencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferrences
     */
    select?: ConferrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferrencesInclude<ExtArgs> | null
  }


  /**
   * Model Skills
   */

  export type AggregateSkills = {
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  export type SkillsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SkillsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SkillsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    skill: string | null
  }

  export type SkillsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    skill: string | null
  }

  export type SkillsCountAggregateOutputType = {
    id: number
    userId: number
    skill: number
    _all: number
  }


  export type SkillsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SkillsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SkillsMinAggregateInputType = {
    id?: true
    userId?: true
    skill?: true
  }

  export type SkillsMaxAggregateInputType = {
    id?: true
    userId?: true
    skill?: true
  }

  export type SkillsCountAggregateInputType = {
    id?: true
    userId?: true
    skill?: true
    _all?: true
  }

  export type SkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to aggregate.
     */
    where?: SkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillsOrderByWithRelationInput | SkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillsMaxAggregateInputType
  }

  export type GetSkillsAggregateType<T extends SkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkills[P]>
      : GetScalarType<T[P], AggregateSkills[P]>
  }




  export type SkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillsWhereInput
    orderBy?: SkillsOrderByWithAggregationInput | SkillsOrderByWithAggregationInput[]
    by: SkillsScalarFieldEnum[] | SkillsScalarFieldEnum
    having?: SkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillsCountAggregateInputType | true
    _avg?: SkillsAvgAggregateInputType
    _sum?: SkillsSumAggregateInputType
    _min?: SkillsMinAggregateInputType
    _max?: SkillsMaxAggregateInputType
  }

  export type SkillsGroupByOutputType = {
    id: number
    userId: number | null
    skill: string
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  type GetSkillsGroupByPayload<T extends SkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillsGroupByOutputType[P]>
            : GetScalarType<T[P], SkillsGroupByOutputType[P]>
        }
      >
    >


  export type SkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skill?: boolean
    User?: boolean | Skills$UserArgs<ExtArgs>
  }, ExtArgs["result"]["skills"]>

  export type SkillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skill?: boolean
    User?: boolean | Skills$UserArgs<ExtArgs>
  }, ExtArgs["result"]["skills"]>

  export type SkillsSelectScalar = {
    id?: boolean
    userId?: boolean
    skill?: boolean
  }

  export type SkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Skills$UserArgs<ExtArgs>
  }
  export type SkillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Skills$UserArgs<ExtArgs>
  }

  export type $SkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skills"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      skill: string
    }, ExtArgs["result"]["skills"]>
    composites: {}
  }

  type SkillsGetPayload<S extends boolean | null | undefined | SkillsDefaultArgs> = $Result.GetResult<Prisma.$SkillsPayload, S>

  type SkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillsCountAggregateInputType | true
    }

  export interface SkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skills'], meta: { name: 'Skills' } }
    /**
     * Find zero or one Skills that matches the filter.
     * @param {SkillsFindUniqueArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillsFindUniqueArgs>(args: SelectSubset<T, SkillsFindUniqueArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skills that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillsFindUniqueOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsFindFirstArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillsFindFirstArgs>(args?: SelectSubset<T, SkillsFindFirstArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsFindFirstOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skills.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillsWithIdOnly = await prisma.skills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillsFindManyArgs>(args?: SelectSubset<T, SkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skills.
     * @param {SkillsCreateArgs} args - Arguments to create a Skills.
     * @example
     * // Create one Skills
     * const Skills = await prisma.skills.create({
     *   data: {
     *     // ... data to create a Skills
     *   }
     * })
     * 
     */
    create<T extends SkillsCreateArgs>(args: SelectSubset<T, SkillsCreateArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skills.
     * @param {SkillsCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillsCreateManyArgs>(args?: SelectSubset<T, SkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillsCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillsWithIdOnly = await prisma.skills.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillsCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Skills.
     * @param {SkillsDeleteArgs} args - Arguments to delete one Skills.
     * @example
     * // Delete one Skills
     * const Skills = await prisma.skills.delete({
     *   where: {
     *     // ... filter to delete one Skills
     *   }
     * })
     * 
     */
    delete<T extends SkillsDeleteArgs>(args: SelectSubset<T, SkillsDeleteArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skills.
     * @param {SkillsUpdateArgs} args - Arguments to update one Skills.
     * @example
     * // Update one Skills
     * const skills = await prisma.skills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillsUpdateArgs>(args: SelectSubset<T, SkillsUpdateArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skills.
     * @param {SkillsDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillsDeleteManyArgs>(args?: SelectSubset<T, SkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skills = await prisma.skills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillsUpdateManyArgs>(args: SelectSubset<T, SkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skills.
     * @param {SkillsUpsertArgs} args - Arguments to update or create a Skills.
     * @example
     * // Update or create a Skills
     * const skills = await prisma.skills.upsert({
     *   create: {
     *     // ... data to create a Skills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skills we want to update
     *   }
     * })
     */
    upsert<T extends SkillsUpsertArgs>(args: SelectSubset<T, SkillsUpsertArgs<ExtArgs>>): Prisma__SkillsClient<$Result.GetResult<Prisma.$SkillsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skills.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillsCountArgs>(
      args?: Subset<T, SkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillsAggregateArgs>(args: Subset<T, SkillsAggregateArgs>): Prisma.PrismaPromise<GetSkillsAggregateType<T>>

    /**
     * Group by Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillsGroupByArgs['orderBy'] }
        : { orderBy?: SkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skills model
   */
  readonly fields: SkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Skills$UserArgs<ExtArgs> = {}>(args?: Subset<T, Skills$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skills model
   */ 
  interface SkillsFieldRefs {
    readonly id: FieldRef<"Skills", 'Int'>
    readonly userId: FieldRef<"Skills", 'Int'>
    readonly skill: FieldRef<"Skills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Skills findUnique
   */
  export type SkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where: SkillsWhereUniqueInput
  }

  /**
   * Skills findUniqueOrThrow
   */
  export type SkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where: SkillsWhereUniqueInput
  }

  /**
   * Skills findFirst
   */
  export type SkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillsOrderByWithRelationInput | SkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * Skills findFirstOrThrow
   */
  export type SkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillsOrderByWithRelationInput | SkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * Skills findMany
   */
  export type SkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillsOrderByWithRelationInput | SkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * Skills create
   */
  export type SkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a Skills.
     */
    data: XOR<SkillsCreateInput, SkillsUncheckedCreateInput>
  }

  /**
   * Skills createMany
   */
  export type SkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillsCreateManyInput | SkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skills createManyAndReturn
   */
  export type SkillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillsCreateManyInput | SkillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skills update
   */
  export type SkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a Skills.
     */
    data: XOR<SkillsUpdateInput, SkillsUncheckedUpdateInput>
    /**
     * Choose, which Skills to update.
     */
    where: SkillsWhereUniqueInput
  }

  /**
   * Skills updateMany
   */
  export type SkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillsUpdateManyMutationInput, SkillsUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillsWhereInput
  }

  /**
   * Skills upsert
   */
  export type SkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the Skills to update in case it exists.
     */
    where: SkillsWhereUniqueInput
    /**
     * In case the Skills found by the `where` argument doesn't exist, create a new Skills with this data.
     */
    create: XOR<SkillsCreateInput, SkillsUncheckedCreateInput>
    /**
     * In case the Skills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillsUpdateInput, SkillsUncheckedUpdateInput>
  }

  /**
   * Skills delete
   */
  export type SkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
    /**
     * Filter which Skills to delete.
     */
    where: SkillsWhereUniqueInput
  }

  /**
   * Skills deleteMany
   */
  export type SkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillsWhereInput
  }

  /**
   * Skills.User
   */
  export type Skills$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Skills without action
   */
  export type SkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skills
     */
    select?: SkillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsInclude<ExtArgs> | null
  }


  /**
   * Model Posts
   */

  export type AggregatePosts = {
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  export type PostsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    description: string | null
    posted_at: Date | null
  }

  export type PostsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    description: string | null
    posted_at: Date | null
  }

  export type PostsCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    posted_at: number
    _all: number
  }


  export type PostsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostsMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    posted_at?: true
  }

  export type PostsMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    posted_at?: true
  }

  export type PostsCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    posted_at?: true
    _all?: true
  }

  export type PostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to aggregate.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsMaxAggregateInputType
  }

  export type GetPostsAggregateType<T extends PostsAggregateArgs> = {
        [P in keyof T & keyof AggregatePosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosts[P]>
      : GetScalarType<T[P], AggregatePosts[P]>
  }




  export type PostsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsWhereInput
    orderBy?: PostsOrderByWithAggregationInput | PostsOrderByWithAggregationInput[]
    by: PostsScalarFieldEnum[] | PostsScalarFieldEnum
    having?: PostsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsCountAggregateInputType | true
    _avg?: PostsAvgAggregateInputType
    _sum?: PostsSumAggregateInputType
    _min?: PostsMinAggregateInputType
    _max?: PostsMaxAggregateInputType
  }

  export type PostsGroupByOutputType = {
    id: number
    userId: number | null
    title: string | null
    description: string | null
    posted_at: Date
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  type GetPostsGroupByPayload<T extends PostsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsGroupByOutputType[P]>
            : GetScalarType<T[P], PostsGroupByOutputType[P]>
        }
      >
    >


  export type PostsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    posted_at?: boolean
    User?: boolean | Posts$UserArgs<ExtArgs>
    postImageLinks?: boolean | Posts$postImageLinksArgs<ExtArgs>
    comments?: boolean | Posts$commentsArgs<ExtArgs>
    likes?: boolean | Posts$likesArgs<ExtArgs>
    reposts?: boolean | Posts$repostsArgs<ExtArgs>
    shares?: boolean | Posts$sharesArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type PostsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    posted_at?: boolean
    User?: boolean | Posts$UserArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type PostsSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    posted_at?: boolean
  }

  export type PostsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Posts$UserArgs<ExtArgs>
    postImageLinks?: boolean | Posts$postImageLinksArgs<ExtArgs>
    comments?: boolean | Posts$commentsArgs<ExtArgs>
    likes?: boolean | Posts$likesArgs<ExtArgs>
    reposts?: boolean | Posts$repostsArgs<ExtArgs>
    shares?: boolean | Posts$sharesArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Posts$UserArgs<ExtArgs>
  }

  export type $PostsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Posts"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      postImageLinks: Prisma.$PostImageLinksPayload<ExtArgs>[]
      comments: Prisma.$CommentsPayload<ExtArgs>[]
      likes: Prisma.$LikesPayload<ExtArgs>[]
      reposts: Prisma.$RepostsPayload<ExtArgs>[]
      shares: Prisma.$SharesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      title: string | null
      description: string | null
      posted_at: Date
    }, ExtArgs["result"]["posts"]>
    composites: {}
  }

  type PostsGetPayload<S extends boolean | null | undefined | PostsDefaultArgs> = $Result.GetResult<Prisma.$PostsPayload, S>

  type PostsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostsCountAggregateInputType | true
    }

  export interface PostsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Posts'], meta: { name: 'Posts' } }
    /**
     * Find zero or one Posts that matches the filter.
     * @param {PostsFindUniqueArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostsFindUniqueArgs>(args: SelectSubset<T, PostsFindUniqueArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Posts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostsFindUniqueOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostsFindUniqueOrThrowArgs>(args: SelectSubset<T, PostsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindFirstArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostsFindFirstArgs>(args?: SelectSubset<T, PostsFindFirstArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindFirstOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostsFindFirstOrThrowArgs>(args?: SelectSubset<T, PostsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.posts.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.posts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postsWithIdOnly = await prisma.posts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostsFindManyArgs>(args?: SelectSubset<T, PostsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Posts.
     * @param {PostsCreateArgs} args - Arguments to create a Posts.
     * @example
     * // Create one Posts
     * const Posts = await prisma.posts.create({
     *   data: {
     *     // ... data to create a Posts
     *   }
     * })
     * 
     */
    create<T extends PostsCreateArgs>(args: SelectSubset<T, PostsCreateArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostsCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const posts = await prisma.posts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostsCreateManyArgs>(args?: SelectSubset<T, PostsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostsCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const posts = await prisma.posts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postsWithIdOnly = await prisma.posts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostsCreateManyAndReturnArgs>(args?: SelectSubset<T, PostsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Posts.
     * @param {PostsDeleteArgs} args - Arguments to delete one Posts.
     * @example
     * // Delete one Posts
     * const Posts = await prisma.posts.delete({
     *   where: {
     *     // ... filter to delete one Posts
     *   }
     * })
     * 
     */
    delete<T extends PostsDeleteArgs>(args: SelectSubset<T, PostsDeleteArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Posts.
     * @param {PostsUpdateArgs} args - Arguments to update one Posts.
     * @example
     * // Update one Posts
     * const posts = await prisma.posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostsUpdateArgs>(args: SelectSubset<T, PostsUpdateArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostsDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostsDeleteManyArgs>(args?: SelectSubset<T, PostsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const posts = await prisma.posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostsUpdateManyArgs>(args: SelectSubset<T, PostsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Posts.
     * @param {PostsUpsertArgs} args - Arguments to update or create a Posts.
     * @example
     * // Update or create a Posts
     * const posts = await prisma.posts.upsert({
     *   create: {
     *     // ... data to create a Posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Posts we want to update
     *   }
     * })
     */
    upsert<T extends PostsUpsertArgs>(args: SelectSubset<T, PostsUpsertArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.posts.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostsCountArgs>(
      args?: Subset<T, PostsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsAggregateArgs>(args: Subset<T, PostsAggregateArgs>): Prisma.PrismaPromise<GetPostsAggregateType<T>>

    /**
     * Group by Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostsGroupByArgs['orderBy'] }
        : { orderBy?: PostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Posts model
   */
  readonly fields: PostsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Posts$UserArgs<ExtArgs> = {}>(args?: Subset<T, Posts$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    postImageLinks<T extends Posts$postImageLinksArgs<ExtArgs> = {}>(args?: Subset<T, Posts$postImageLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Posts$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Posts$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends Posts$likesArgs<ExtArgs> = {}>(args?: Subset<T, Posts$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "findMany"> | Null>
    reposts<T extends Posts$repostsArgs<ExtArgs> = {}>(args?: Subset<T, Posts$repostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "findMany"> | Null>
    shares<T extends Posts$sharesArgs<ExtArgs> = {}>(args?: Subset<T, Posts$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Posts model
   */ 
  interface PostsFieldRefs {
    readonly id: FieldRef<"Posts", 'Int'>
    readonly userId: FieldRef<"Posts", 'Int'>
    readonly title: FieldRef<"Posts", 'String'>
    readonly description: FieldRef<"Posts", 'String'>
    readonly posted_at: FieldRef<"Posts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Posts findUnique
   */
  export type PostsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts findUniqueOrThrow
   */
  export type PostsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts findFirst
   */
  export type PostsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Posts findFirstOrThrow
   */
  export type PostsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Posts findMany
   */
  export type PostsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Posts create
   */
  export type PostsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * The data needed to create a Posts.
     */
    data?: XOR<PostsCreateInput, PostsUncheckedCreateInput>
  }

  /**
   * Posts createMany
   */
  export type PostsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostsCreateManyInput | PostsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Posts createManyAndReturn
   */
  export type PostsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostsCreateManyInput | PostsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Posts update
   */
  export type PostsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * The data needed to update a Posts.
     */
    data: XOR<PostsUpdateInput, PostsUncheckedUpdateInput>
    /**
     * Choose, which Posts to update.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts updateMany
   */
  export type PostsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostsUpdateManyMutationInput, PostsUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostsWhereInput
  }

  /**
   * Posts upsert
   */
  export type PostsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * The filter to search for the Posts to update in case it exists.
     */
    where: PostsWhereUniqueInput
    /**
     * In case the Posts found by the `where` argument doesn't exist, create a new Posts with this data.
     */
    create: XOR<PostsCreateInput, PostsUncheckedCreateInput>
    /**
     * In case the Posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostsUpdateInput, PostsUncheckedUpdateInput>
  }

  /**
   * Posts delete
   */
  export type PostsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter which Posts to delete.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts deleteMany
   */
  export type PostsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostsWhereInput
  }

  /**
   * Posts.User
   */
  export type Posts$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Posts.postImageLinks
   */
  export type Posts$postImageLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    where?: PostImageLinksWhereInput
    orderBy?: PostImageLinksOrderByWithRelationInput | PostImageLinksOrderByWithRelationInput[]
    cursor?: PostImageLinksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostImageLinksScalarFieldEnum | PostImageLinksScalarFieldEnum[]
  }

  /**
   * Posts.comments
   */
  export type Posts$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    cursor?: CommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Posts.likes
   */
  export type Posts$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    where?: LikesWhereInput
    orderBy?: LikesOrderByWithRelationInput | LikesOrderByWithRelationInput[]
    cursor?: LikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * Posts.reposts
   */
  export type Posts$repostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    where?: RepostsWhereInput
    orderBy?: RepostsOrderByWithRelationInput | RepostsOrderByWithRelationInput[]
    cursor?: RepostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepostsScalarFieldEnum | RepostsScalarFieldEnum[]
  }

  /**
   * Posts.shares
   */
  export type Posts$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    where?: SharesWhereInput
    orderBy?: SharesOrderByWithRelationInput | SharesOrderByWithRelationInput[]
    cursor?: SharesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharesScalarFieldEnum | SharesScalarFieldEnum[]
  }

  /**
   * Posts without action
   */
  export type PostsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
  }


  /**
   * Model PostImageLinks
   */

  export type AggregatePostImageLinks = {
    _count: PostImageLinksCountAggregateOutputType | null
    _avg: PostImageLinksAvgAggregateOutputType | null
    _sum: PostImageLinksSumAggregateOutputType | null
    _min: PostImageLinksMinAggregateOutputType | null
    _max: PostImageLinksMaxAggregateOutputType | null
  }

  export type PostImageLinksAvgAggregateOutputType = {
    id: number | null
    postsId: number | null
  }

  export type PostImageLinksSumAggregateOutputType = {
    id: number | null
    postsId: number | null
  }

  export type PostImageLinksMinAggregateOutputType = {
    id: number | null
    postsId: number | null
    postImageLink: string | null
  }

  export type PostImageLinksMaxAggregateOutputType = {
    id: number | null
    postsId: number | null
    postImageLink: string | null
  }

  export type PostImageLinksCountAggregateOutputType = {
    id: number
    postsId: number
    postImageLink: number
    _all: number
  }


  export type PostImageLinksAvgAggregateInputType = {
    id?: true
    postsId?: true
  }

  export type PostImageLinksSumAggregateInputType = {
    id?: true
    postsId?: true
  }

  export type PostImageLinksMinAggregateInputType = {
    id?: true
    postsId?: true
    postImageLink?: true
  }

  export type PostImageLinksMaxAggregateInputType = {
    id?: true
    postsId?: true
    postImageLink?: true
  }

  export type PostImageLinksCountAggregateInputType = {
    id?: true
    postsId?: true
    postImageLink?: true
    _all?: true
  }

  export type PostImageLinksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostImageLinks to aggregate.
     */
    where?: PostImageLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImageLinks to fetch.
     */
    orderBy?: PostImageLinksOrderByWithRelationInput | PostImageLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostImageLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImageLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostImageLinks
    **/
    _count?: true | PostImageLinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostImageLinksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostImageLinksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostImageLinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostImageLinksMaxAggregateInputType
  }

  export type GetPostImageLinksAggregateType<T extends PostImageLinksAggregateArgs> = {
        [P in keyof T & keyof AggregatePostImageLinks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostImageLinks[P]>
      : GetScalarType<T[P], AggregatePostImageLinks[P]>
  }




  export type PostImageLinksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostImageLinksWhereInput
    orderBy?: PostImageLinksOrderByWithAggregationInput | PostImageLinksOrderByWithAggregationInput[]
    by: PostImageLinksScalarFieldEnum[] | PostImageLinksScalarFieldEnum
    having?: PostImageLinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostImageLinksCountAggregateInputType | true
    _avg?: PostImageLinksAvgAggregateInputType
    _sum?: PostImageLinksSumAggregateInputType
    _min?: PostImageLinksMinAggregateInputType
    _max?: PostImageLinksMaxAggregateInputType
  }

  export type PostImageLinksGroupByOutputType = {
    id: number
    postsId: number | null
    postImageLink: string | null
    _count: PostImageLinksCountAggregateOutputType | null
    _avg: PostImageLinksAvgAggregateOutputType | null
    _sum: PostImageLinksSumAggregateOutputType | null
    _min: PostImageLinksMinAggregateOutputType | null
    _max: PostImageLinksMaxAggregateOutputType | null
  }

  type GetPostImageLinksGroupByPayload<T extends PostImageLinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostImageLinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostImageLinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostImageLinksGroupByOutputType[P]>
            : GetScalarType<T[P], PostImageLinksGroupByOutputType[P]>
        }
      >
    >


  export type PostImageLinksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    postImageLink?: boolean
    Posts?: boolean | PostImageLinks$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["postImageLinks"]>

  export type PostImageLinksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    postImageLink?: boolean
    Posts?: boolean | PostImageLinks$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["postImageLinks"]>

  export type PostImageLinksSelectScalar = {
    id?: boolean
    postsId?: boolean
    postImageLink?: boolean
  }

  export type PostImageLinksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | PostImageLinks$PostsArgs<ExtArgs>
  }
  export type PostImageLinksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | PostImageLinks$PostsArgs<ExtArgs>
  }

  export type $PostImageLinksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostImageLinks"
    objects: {
      Posts: Prisma.$PostsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postsId: number | null
      postImageLink: string | null
    }, ExtArgs["result"]["postImageLinks"]>
    composites: {}
  }

  type PostImageLinksGetPayload<S extends boolean | null | undefined | PostImageLinksDefaultArgs> = $Result.GetResult<Prisma.$PostImageLinksPayload, S>

  type PostImageLinksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostImageLinksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostImageLinksCountAggregateInputType | true
    }

  export interface PostImageLinksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostImageLinks'], meta: { name: 'PostImageLinks' } }
    /**
     * Find zero or one PostImageLinks that matches the filter.
     * @param {PostImageLinksFindUniqueArgs} args - Arguments to find a PostImageLinks
     * @example
     * // Get one PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostImageLinksFindUniqueArgs>(args: SelectSubset<T, PostImageLinksFindUniqueArgs<ExtArgs>>): Prisma__PostImageLinksClient<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostImageLinks that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostImageLinksFindUniqueOrThrowArgs} args - Arguments to find a PostImageLinks
     * @example
     * // Get one PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostImageLinksFindUniqueOrThrowArgs>(args: SelectSubset<T, PostImageLinksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostImageLinksClient<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostImageLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageLinksFindFirstArgs} args - Arguments to find a PostImageLinks
     * @example
     * // Get one PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostImageLinksFindFirstArgs>(args?: SelectSubset<T, PostImageLinksFindFirstArgs<ExtArgs>>): Prisma__PostImageLinksClient<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostImageLinks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageLinksFindFirstOrThrowArgs} args - Arguments to find a PostImageLinks
     * @example
     * // Get one PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostImageLinksFindFirstOrThrowArgs>(args?: SelectSubset<T, PostImageLinksFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostImageLinksClient<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostImageLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageLinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.findMany()
     * 
     * // Get first 10 PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postImageLinksWithIdOnly = await prisma.postImageLinks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostImageLinksFindManyArgs>(args?: SelectSubset<T, PostImageLinksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostImageLinks.
     * @param {PostImageLinksCreateArgs} args - Arguments to create a PostImageLinks.
     * @example
     * // Create one PostImageLinks
     * const PostImageLinks = await prisma.postImageLinks.create({
     *   data: {
     *     // ... data to create a PostImageLinks
     *   }
     * })
     * 
     */
    create<T extends PostImageLinksCreateArgs>(args: SelectSubset<T, PostImageLinksCreateArgs<ExtArgs>>): Prisma__PostImageLinksClient<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostImageLinks.
     * @param {PostImageLinksCreateManyArgs} args - Arguments to create many PostImageLinks.
     * @example
     * // Create many PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostImageLinksCreateManyArgs>(args?: SelectSubset<T, PostImageLinksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostImageLinks and returns the data saved in the database.
     * @param {PostImageLinksCreateManyAndReturnArgs} args - Arguments to create many PostImageLinks.
     * @example
     * // Create many PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostImageLinks and only return the `id`
     * const postImageLinksWithIdOnly = await prisma.postImageLinks.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostImageLinksCreateManyAndReturnArgs>(args?: SelectSubset<T, PostImageLinksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostImageLinks.
     * @param {PostImageLinksDeleteArgs} args - Arguments to delete one PostImageLinks.
     * @example
     * // Delete one PostImageLinks
     * const PostImageLinks = await prisma.postImageLinks.delete({
     *   where: {
     *     // ... filter to delete one PostImageLinks
     *   }
     * })
     * 
     */
    delete<T extends PostImageLinksDeleteArgs>(args: SelectSubset<T, PostImageLinksDeleteArgs<ExtArgs>>): Prisma__PostImageLinksClient<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostImageLinks.
     * @param {PostImageLinksUpdateArgs} args - Arguments to update one PostImageLinks.
     * @example
     * // Update one PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostImageLinksUpdateArgs>(args: SelectSubset<T, PostImageLinksUpdateArgs<ExtArgs>>): Prisma__PostImageLinksClient<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostImageLinks.
     * @param {PostImageLinksDeleteManyArgs} args - Arguments to filter PostImageLinks to delete.
     * @example
     * // Delete a few PostImageLinks
     * const { count } = await prisma.postImageLinks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostImageLinksDeleteManyArgs>(args?: SelectSubset<T, PostImageLinksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostImageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageLinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostImageLinksUpdateManyArgs>(args: SelectSubset<T, PostImageLinksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostImageLinks.
     * @param {PostImageLinksUpsertArgs} args - Arguments to update or create a PostImageLinks.
     * @example
     * // Update or create a PostImageLinks
     * const postImageLinks = await prisma.postImageLinks.upsert({
     *   create: {
     *     // ... data to create a PostImageLinks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostImageLinks we want to update
     *   }
     * })
     */
    upsert<T extends PostImageLinksUpsertArgs>(args: SelectSubset<T, PostImageLinksUpsertArgs<ExtArgs>>): Prisma__PostImageLinksClient<$Result.GetResult<Prisma.$PostImageLinksPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostImageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageLinksCountArgs} args - Arguments to filter PostImageLinks to count.
     * @example
     * // Count the number of PostImageLinks
     * const count = await prisma.postImageLinks.count({
     *   where: {
     *     // ... the filter for the PostImageLinks we want to count
     *   }
     * })
    **/
    count<T extends PostImageLinksCountArgs>(
      args?: Subset<T, PostImageLinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostImageLinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostImageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageLinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostImageLinksAggregateArgs>(args: Subset<T, PostImageLinksAggregateArgs>): Prisma.PrismaPromise<GetPostImageLinksAggregateType<T>>

    /**
     * Group by PostImageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageLinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostImageLinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostImageLinksGroupByArgs['orderBy'] }
        : { orderBy?: PostImageLinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostImageLinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostImageLinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostImageLinks model
   */
  readonly fields: PostImageLinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostImageLinks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostImageLinksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Posts<T extends PostImageLinks$PostsArgs<ExtArgs> = {}>(args?: Subset<T, PostImageLinks$PostsArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostImageLinks model
   */ 
  interface PostImageLinksFieldRefs {
    readonly id: FieldRef<"PostImageLinks", 'Int'>
    readonly postsId: FieldRef<"PostImageLinks", 'Int'>
    readonly postImageLink: FieldRef<"PostImageLinks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostImageLinks findUnique
   */
  export type PostImageLinksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which PostImageLinks to fetch.
     */
    where: PostImageLinksWhereUniqueInput
  }

  /**
   * PostImageLinks findUniqueOrThrow
   */
  export type PostImageLinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which PostImageLinks to fetch.
     */
    where: PostImageLinksWhereUniqueInput
  }

  /**
   * PostImageLinks findFirst
   */
  export type PostImageLinksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which PostImageLinks to fetch.
     */
    where?: PostImageLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImageLinks to fetch.
     */
    orderBy?: PostImageLinksOrderByWithRelationInput | PostImageLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostImageLinks.
     */
    cursor?: PostImageLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImageLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostImageLinks.
     */
    distinct?: PostImageLinksScalarFieldEnum | PostImageLinksScalarFieldEnum[]
  }

  /**
   * PostImageLinks findFirstOrThrow
   */
  export type PostImageLinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which PostImageLinks to fetch.
     */
    where?: PostImageLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImageLinks to fetch.
     */
    orderBy?: PostImageLinksOrderByWithRelationInput | PostImageLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostImageLinks.
     */
    cursor?: PostImageLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImageLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostImageLinks.
     */
    distinct?: PostImageLinksScalarFieldEnum | PostImageLinksScalarFieldEnum[]
  }

  /**
   * PostImageLinks findMany
   */
  export type PostImageLinksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which PostImageLinks to fetch.
     */
    where?: PostImageLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImageLinks to fetch.
     */
    orderBy?: PostImageLinksOrderByWithRelationInput | PostImageLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostImageLinks.
     */
    cursor?: PostImageLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImageLinks.
     */
    skip?: number
    distinct?: PostImageLinksScalarFieldEnum | PostImageLinksScalarFieldEnum[]
  }

  /**
   * PostImageLinks create
   */
  export type PostImageLinksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    /**
     * The data needed to create a PostImageLinks.
     */
    data?: XOR<PostImageLinksCreateInput, PostImageLinksUncheckedCreateInput>
  }

  /**
   * PostImageLinks createMany
   */
  export type PostImageLinksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostImageLinks.
     */
    data: PostImageLinksCreateManyInput | PostImageLinksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostImageLinks createManyAndReturn
   */
  export type PostImageLinksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostImageLinks.
     */
    data: PostImageLinksCreateManyInput | PostImageLinksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostImageLinks update
   */
  export type PostImageLinksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    /**
     * The data needed to update a PostImageLinks.
     */
    data: XOR<PostImageLinksUpdateInput, PostImageLinksUncheckedUpdateInput>
    /**
     * Choose, which PostImageLinks to update.
     */
    where: PostImageLinksWhereUniqueInput
  }

  /**
   * PostImageLinks updateMany
   */
  export type PostImageLinksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostImageLinks.
     */
    data: XOR<PostImageLinksUpdateManyMutationInput, PostImageLinksUncheckedUpdateManyInput>
    /**
     * Filter which PostImageLinks to update
     */
    where?: PostImageLinksWhereInput
  }

  /**
   * PostImageLinks upsert
   */
  export type PostImageLinksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    /**
     * The filter to search for the PostImageLinks to update in case it exists.
     */
    where: PostImageLinksWhereUniqueInput
    /**
     * In case the PostImageLinks found by the `where` argument doesn't exist, create a new PostImageLinks with this data.
     */
    create: XOR<PostImageLinksCreateInput, PostImageLinksUncheckedCreateInput>
    /**
     * In case the PostImageLinks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostImageLinksUpdateInput, PostImageLinksUncheckedUpdateInput>
  }

  /**
   * PostImageLinks delete
   */
  export type PostImageLinksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
    /**
     * Filter which PostImageLinks to delete.
     */
    where: PostImageLinksWhereUniqueInput
  }

  /**
   * PostImageLinks deleteMany
   */
  export type PostImageLinksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostImageLinks to delete
     */
    where?: PostImageLinksWhereInput
  }

  /**
   * PostImageLinks.Posts
   */
  export type PostImageLinks$PostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
  }

  /**
   * PostImageLinks without action
   */
  export type PostImageLinksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImageLinks
     */
    select?: PostImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageLinksInclude<ExtArgs> | null
  }


  /**
   * Model Comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    id: number | null
    postsId: number | null
  }

  export type CommentsSumAggregateOutputType = {
    id: number | null
    postsId: number | null
  }

  export type CommentsMinAggregateOutputType = {
    id: number | null
    postsId: number | null
    comment: string | null
    commented_at: Date | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: number | null
    postsId: number | null
    comment: string | null
    commented_at: Date | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    postsId: number
    comment: number
    commented_at: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    id?: true
    postsId?: true
  }

  export type CommentsSumAggregateInputType = {
    id?: true
    postsId?: true
  }

  export type CommentsMinAggregateInputType = {
    id?: true
    postsId?: true
    comment?: true
    commented_at?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    postsId?: true
    comment?: true
    commented_at?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    postsId?: true
    comment?: true
    commented_at?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to aggregate.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type CommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithAggregationInput | CommentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: CommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    id: number
    postsId: number | null
    comment: string
    commented_at: Date
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends CommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type CommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    comment?: boolean
    commented_at?: boolean
    Posts?: boolean | Comments$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type CommentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    comment?: boolean
    commented_at?: boolean
    Posts?: boolean | Comments$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type CommentsSelectScalar = {
    id?: boolean
    postsId?: boolean
    comment?: boolean
    commented_at?: boolean
  }

  export type CommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | Comments$PostsArgs<ExtArgs>
  }
  export type CommentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | Comments$PostsArgs<ExtArgs>
  }

  export type $CommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comments"
    objects: {
      Posts: Prisma.$PostsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postsId: number | null
      comment: string
      commented_at: Date
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }

  type CommentsGetPayload<S extends boolean | null | undefined | CommentsDefaultArgs> = $Result.GetResult<Prisma.$CommentsPayload, S>

  type CommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface CommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comments'], meta: { name: 'Comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {CommentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentsFindUniqueArgs>(args: SelectSubset<T, CommentsFindUniqueArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentsFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentsFindFirstArgs>(args?: SelectSubset<T, CommentsFindFirstArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentsFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentsFindManyArgs>(args?: SelectSubset<T, CommentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comments.
     * @param {CommentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
     */
    create<T extends CommentsCreateArgs>(args: SelectSubset<T, CommentsCreateArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentsCreateManyArgs>(args?: SelectSubset<T, CommentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentsCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentsCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comments.
     * @param {CommentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
     */
    delete<T extends CommentsDeleteArgs>(args: SelectSubset<T, CommentsDeleteArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comments.
     * @param {CommentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentsUpdateArgs>(args: SelectSubset<T, CommentsUpdateArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentsDeleteManyArgs>(args?: SelectSubset<T, CommentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentsUpdateManyArgs>(args: SelectSubset<T, CommentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comments.
     * @param {CommentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends CommentsUpsertArgs>(args: SelectSubset<T, CommentsUpsertArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentsCountArgs>(
      args?: Subset<T, CommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentsGroupByArgs['orderBy'] }
        : { orderBy?: CommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comments model
   */
  readonly fields: CommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Posts<T extends Comments$PostsArgs<ExtArgs> = {}>(args?: Subset<T, Comments$PostsArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comments model
   */ 
  interface CommentsFieldRefs {
    readonly id: FieldRef<"Comments", 'Int'>
    readonly postsId: FieldRef<"Comments", 'Int'>
    readonly comment: FieldRef<"Comments", 'String'>
    readonly commented_at: FieldRef<"Comments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comments findUnique
   */
  export type CommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments findUniqueOrThrow
   */
  export type CommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments findFirst
   */
  export type CommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments findFirstOrThrow
   */
  export type CommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments findMany
   */
  export type CommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments create
   */
  export type CommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Comments.
     */
    data: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
  }

  /**
   * Comments createMany
   */
  export type CommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentsCreateManyInput | CommentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comments createManyAndReturn
   */
  export type CommentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentsCreateManyInput | CommentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comments update
   */
  export type CommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Comments.
     */
    data: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
    /**
     * Choose, which Comments to update.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments updateMany
   */
  export type CommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentsWhereInput
  }

  /**
   * Comments upsert
   */
  export type CommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Comments to update in case it exists.
     */
    where: CommentsWhereUniqueInput
    /**
     * In case the Comments found by the `where` argument doesn't exist, create a new Comments with this data.
     */
    create: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
    /**
     * In case the Comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
  }

  /**
   * Comments delete
   */
  export type CommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter which Comments to delete.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments deleteMany
   */
  export type CommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentsWhereInput
  }

  /**
   * Comments.Posts
   */
  export type Comments$PostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
  }

  /**
   * Comments without action
   */
  export type CommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
  }


  /**
   * Model Likes
   */

  export type AggregateLikes = {
    _count: LikesCountAggregateOutputType | null
    _avg: LikesAvgAggregateOutputType | null
    _sum: LikesSumAggregateOutputType | null
    _min: LikesMinAggregateOutputType | null
    _max: LikesMaxAggregateOutputType | null
  }

  export type LikesAvgAggregateOutputType = {
    id: number | null
    postsId: number | null
    liked_user_id: number | null
  }

  export type LikesSumAggregateOutputType = {
    id: number | null
    postsId: number | null
    liked_user_id: number | null
  }

  export type LikesMinAggregateOutputType = {
    id: number | null
    postsId: number | null
    liked_user_id: number | null
  }

  export type LikesMaxAggregateOutputType = {
    id: number | null
    postsId: number | null
    liked_user_id: number | null
  }

  export type LikesCountAggregateOutputType = {
    id: number
    postsId: number
    liked_user_id: number
    _all: number
  }


  export type LikesAvgAggregateInputType = {
    id?: true
    postsId?: true
    liked_user_id?: true
  }

  export type LikesSumAggregateInputType = {
    id?: true
    postsId?: true
    liked_user_id?: true
  }

  export type LikesMinAggregateInputType = {
    id?: true
    postsId?: true
    liked_user_id?: true
  }

  export type LikesMaxAggregateInputType = {
    id?: true
    postsId?: true
    liked_user_id?: true
  }

  export type LikesCountAggregateInputType = {
    id?: true
    postsId?: true
    liked_user_id?: true
    _all?: true
  }

  export type LikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to aggregate.
     */
    where?: LikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikesOrderByWithRelationInput | LikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LikesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LikesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikesMaxAggregateInputType
  }

  export type GetLikesAggregateType<T extends LikesAggregateArgs> = {
        [P in keyof T & keyof AggregateLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikes[P]>
      : GetScalarType<T[P], AggregateLikes[P]>
  }




  export type LikesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikesWhereInput
    orderBy?: LikesOrderByWithAggregationInput | LikesOrderByWithAggregationInput[]
    by: LikesScalarFieldEnum[] | LikesScalarFieldEnum
    having?: LikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikesCountAggregateInputType | true
    _avg?: LikesAvgAggregateInputType
    _sum?: LikesSumAggregateInputType
    _min?: LikesMinAggregateInputType
    _max?: LikesMaxAggregateInputType
  }

  export type LikesGroupByOutputType = {
    id: number
    postsId: number | null
    liked_user_id: number | null
    _count: LikesCountAggregateOutputType | null
    _avg: LikesAvgAggregateOutputType | null
    _sum: LikesSumAggregateOutputType | null
    _min: LikesMinAggregateOutputType | null
    _max: LikesMaxAggregateOutputType | null
  }

  type GetLikesGroupByPayload<T extends LikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikesGroupByOutputType[P]>
            : GetScalarType<T[P], LikesGroupByOutputType[P]>
        }
      >
    >


  export type LikesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    liked_user_id?: boolean
    Posts?: boolean | Likes$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["likes"]>

  export type LikesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    liked_user_id?: boolean
    Posts?: boolean | Likes$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["likes"]>

  export type LikesSelectScalar = {
    id?: boolean
    postsId?: boolean
    liked_user_id?: boolean
  }

  export type LikesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | Likes$PostsArgs<ExtArgs>
  }
  export type LikesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | Likes$PostsArgs<ExtArgs>
  }

  export type $LikesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Likes"
    objects: {
      Posts: Prisma.$PostsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postsId: number | null
      liked_user_id: number | null
    }, ExtArgs["result"]["likes"]>
    composites: {}
  }

  type LikesGetPayload<S extends boolean | null | undefined | LikesDefaultArgs> = $Result.GetResult<Prisma.$LikesPayload, S>

  type LikesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikesCountAggregateInputType | true
    }

  export interface LikesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Likes'], meta: { name: 'Likes' } }
    /**
     * Find zero or one Likes that matches the filter.
     * @param {LikesFindUniqueArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikesFindUniqueArgs>(args: SelectSubset<T, LikesFindUniqueArgs<ExtArgs>>): Prisma__LikesClient<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Likes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LikesFindUniqueOrThrowArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikesFindUniqueOrThrowArgs>(args: SelectSubset<T, LikesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikesClient<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikesFindFirstArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikesFindFirstArgs>(args?: SelectSubset<T, LikesFindFirstArgs<ExtArgs>>): Prisma__LikesClient<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Likes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikesFindFirstOrThrowArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikesFindFirstOrThrowArgs>(args?: SelectSubset<T, LikesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikesClient<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.likes.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.likes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likesWithIdOnly = await prisma.likes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikesFindManyArgs>(args?: SelectSubset<T, LikesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Likes.
     * @param {LikesCreateArgs} args - Arguments to create a Likes.
     * @example
     * // Create one Likes
     * const Likes = await prisma.likes.create({
     *   data: {
     *     // ... data to create a Likes
     *   }
     * })
     * 
     */
    create<T extends LikesCreateArgs>(args: SelectSubset<T, LikesCreateArgs<ExtArgs>>): Prisma__LikesClient<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Likes.
     * @param {LikesCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const likes = await prisma.likes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikesCreateManyArgs>(args?: SelectSubset<T, LikesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikesCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const likes = await prisma.likes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likesWithIdOnly = await prisma.likes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikesCreateManyAndReturnArgs>(args?: SelectSubset<T, LikesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Likes.
     * @param {LikesDeleteArgs} args - Arguments to delete one Likes.
     * @example
     * // Delete one Likes
     * const Likes = await prisma.likes.delete({
     *   where: {
     *     // ... filter to delete one Likes
     *   }
     * })
     * 
     */
    delete<T extends LikesDeleteArgs>(args: SelectSubset<T, LikesDeleteArgs<ExtArgs>>): Prisma__LikesClient<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Likes.
     * @param {LikesUpdateArgs} args - Arguments to update one Likes.
     * @example
     * // Update one Likes
     * const likes = await prisma.likes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikesUpdateArgs>(args: SelectSubset<T, LikesUpdateArgs<ExtArgs>>): Prisma__LikesClient<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikesDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.likes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikesDeleteManyArgs>(args?: SelectSubset<T, LikesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const likes = await prisma.likes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikesUpdateManyArgs>(args: SelectSubset<T, LikesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Likes.
     * @param {LikesUpsertArgs} args - Arguments to update or create a Likes.
     * @example
     * // Update or create a Likes
     * const likes = await prisma.likes.upsert({
     *   create: {
     *     // ... data to create a Likes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Likes we want to update
     *   }
     * })
     */
    upsert<T extends LikesUpsertArgs>(args: SelectSubset<T, LikesUpsertArgs<ExtArgs>>): Prisma__LikesClient<$Result.GetResult<Prisma.$LikesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikesCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.likes.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikesCountArgs>(
      args?: Subset<T, LikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikesAggregateArgs>(args: Subset<T, LikesAggregateArgs>): Prisma.PrismaPromise<GetLikesAggregateType<T>>

    /**
     * Group by Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikesGroupByArgs['orderBy'] }
        : { orderBy?: LikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Likes model
   */
  readonly fields: LikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Likes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Posts<T extends Likes$PostsArgs<ExtArgs> = {}>(args?: Subset<T, Likes$PostsArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Likes model
   */ 
  interface LikesFieldRefs {
    readonly id: FieldRef<"Likes", 'Int'>
    readonly postsId: FieldRef<"Likes", 'Int'>
    readonly liked_user_id: FieldRef<"Likes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Likes findUnique
   */
  export type LikesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where: LikesWhereUniqueInput
  }

  /**
   * Likes findUniqueOrThrow
   */
  export type LikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where: LikesWhereUniqueInput
  }

  /**
   * Likes findFirst
   */
  export type LikesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikesOrderByWithRelationInput | LikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * Likes findFirstOrThrow
   */
  export type LikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikesOrderByWithRelationInput | LikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * Likes findMany
   */
  export type LikesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikesOrderByWithRelationInput | LikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * Likes create
   */
  export type LikesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    /**
     * The data needed to create a Likes.
     */
    data?: XOR<LikesCreateInput, LikesUncheckedCreateInput>
  }

  /**
   * Likes createMany
   */
  export type LikesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikesCreateManyInput | LikesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Likes createManyAndReturn
   */
  export type LikesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikesCreateManyInput | LikesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Likes update
   */
  export type LikesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    /**
     * The data needed to update a Likes.
     */
    data: XOR<LikesUpdateInput, LikesUncheckedUpdateInput>
    /**
     * Choose, which Likes to update.
     */
    where: LikesWhereUniqueInput
  }

  /**
   * Likes updateMany
   */
  export type LikesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikesUpdateManyMutationInput, LikesUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikesWhereInput
  }

  /**
   * Likes upsert
   */
  export type LikesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    /**
     * The filter to search for the Likes to update in case it exists.
     */
    where: LikesWhereUniqueInput
    /**
     * In case the Likes found by the `where` argument doesn't exist, create a new Likes with this data.
     */
    create: XOR<LikesCreateInput, LikesUncheckedCreateInput>
    /**
     * In case the Likes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikesUpdateInput, LikesUncheckedUpdateInput>
  }

  /**
   * Likes delete
   */
  export type LikesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
    /**
     * Filter which Likes to delete.
     */
    where: LikesWhereUniqueInput
  }

  /**
   * Likes deleteMany
   */
  export type LikesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikesWhereInput
  }

  /**
   * Likes.Posts
   */
  export type Likes$PostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
  }

  /**
   * Likes without action
   */
  export type LikesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Likes
     */
    select?: LikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikesInclude<ExtArgs> | null
  }


  /**
   * Model Reposts
   */

  export type AggregateReposts = {
    _count: RepostsCountAggregateOutputType | null
    _avg: RepostsAvgAggregateOutputType | null
    _sum: RepostsSumAggregateOutputType | null
    _min: RepostsMinAggregateOutputType | null
    _max: RepostsMaxAggregateOutputType | null
  }

  export type RepostsAvgAggregateOutputType = {
    id: number | null
    postsId: number | null
    reposted_user_id: number | null
  }

  export type RepostsSumAggregateOutputType = {
    id: number | null
    postsId: number | null
    reposted_user_id: number | null
  }

  export type RepostsMinAggregateOutputType = {
    id: number | null
    postsId: number | null
    reposted_user_id: number | null
  }

  export type RepostsMaxAggregateOutputType = {
    id: number | null
    postsId: number | null
    reposted_user_id: number | null
  }

  export type RepostsCountAggregateOutputType = {
    id: number
    postsId: number
    reposted_user_id: number
    _all: number
  }


  export type RepostsAvgAggregateInputType = {
    id?: true
    postsId?: true
    reposted_user_id?: true
  }

  export type RepostsSumAggregateInputType = {
    id?: true
    postsId?: true
    reposted_user_id?: true
  }

  export type RepostsMinAggregateInputType = {
    id?: true
    postsId?: true
    reposted_user_id?: true
  }

  export type RepostsMaxAggregateInputType = {
    id?: true
    postsId?: true
    reposted_user_id?: true
  }

  export type RepostsCountAggregateInputType = {
    id?: true
    postsId?: true
    reposted_user_id?: true
    _all?: true
  }

  export type RepostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reposts to aggregate.
     */
    where?: RepostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reposts to fetch.
     */
    orderBy?: RepostsOrderByWithRelationInput | RepostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reposts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reposts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reposts
    **/
    _count?: true | RepostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepostsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepostsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepostsMaxAggregateInputType
  }

  export type GetRepostsAggregateType<T extends RepostsAggregateArgs> = {
        [P in keyof T & keyof AggregateReposts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReposts[P]>
      : GetScalarType<T[P], AggregateReposts[P]>
  }




  export type RepostsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepostsWhereInput
    orderBy?: RepostsOrderByWithAggregationInput | RepostsOrderByWithAggregationInput[]
    by: RepostsScalarFieldEnum[] | RepostsScalarFieldEnum
    having?: RepostsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepostsCountAggregateInputType | true
    _avg?: RepostsAvgAggregateInputType
    _sum?: RepostsSumAggregateInputType
    _min?: RepostsMinAggregateInputType
    _max?: RepostsMaxAggregateInputType
  }

  export type RepostsGroupByOutputType = {
    id: number
    postsId: number | null
    reposted_user_id: number | null
    _count: RepostsCountAggregateOutputType | null
    _avg: RepostsAvgAggregateOutputType | null
    _sum: RepostsSumAggregateOutputType | null
    _min: RepostsMinAggregateOutputType | null
    _max: RepostsMaxAggregateOutputType | null
  }

  type GetRepostsGroupByPayload<T extends RepostsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepostsGroupByOutputType[P]>
            : GetScalarType<T[P], RepostsGroupByOutputType[P]>
        }
      >
    >


  export type RepostsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    reposted_user_id?: boolean
    Posts?: boolean | Reposts$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["reposts"]>

  export type RepostsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    reposted_user_id?: boolean
    Posts?: boolean | Reposts$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["reposts"]>

  export type RepostsSelectScalar = {
    id?: boolean
    postsId?: boolean
    reposted_user_id?: boolean
  }

  export type RepostsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | Reposts$PostsArgs<ExtArgs>
  }
  export type RepostsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | Reposts$PostsArgs<ExtArgs>
  }

  export type $RepostsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reposts"
    objects: {
      Posts: Prisma.$PostsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postsId: number | null
      reposted_user_id: number | null
    }, ExtArgs["result"]["reposts"]>
    composites: {}
  }

  type RepostsGetPayload<S extends boolean | null | undefined | RepostsDefaultArgs> = $Result.GetResult<Prisma.$RepostsPayload, S>

  type RepostsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RepostsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RepostsCountAggregateInputType | true
    }

  export interface RepostsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reposts'], meta: { name: 'Reposts' } }
    /**
     * Find zero or one Reposts that matches the filter.
     * @param {RepostsFindUniqueArgs} args - Arguments to find a Reposts
     * @example
     * // Get one Reposts
     * const reposts = await prisma.reposts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepostsFindUniqueArgs>(args: SelectSubset<T, RepostsFindUniqueArgs<ExtArgs>>): Prisma__RepostsClient<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reposts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RepostsFindUniqueOrThrowArgs} args - Arguments to find a Reposts
     * @example
     * // Get one Reposts
     * const reposts = await prisma.reposts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepostsFindUniqueOrThrowArgs>(args: SelectSubset<T, RepostsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepostsClient<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reposts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostsFindFirstArgs} args - Arguments to find a Reposts
     * @example
     * // Get one Reposts
     * const reposts = await prisma.reposts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepostsFindFirstArgs>(args?: SelectSubset<T, RepostsFindFirstArgs<ExtArgs>>): Prisma__RepostsClient<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reposts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostsFindFirstOrThrowArgs} args - Arguments to find a Reposts
     * @example
     * // Get one Reposts
     * const reposts = await prisma.reposts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepostsFindFirstOrThrowArgs>(args?: SelectSubset<T, RepostsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepostsClient<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reposts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reposts
     * const reposts = await prisma.reposts.findMany()
     * 
     * // Get first 10 Reposts
     * const reposts = await prisma.reposts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repostsWithIdOnly = await prisma.reposts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepostsFindManyArgs>(args?: SelectSubset<T, RepostsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reposts.
     * @param {RepostsCreateArgs} args - Arguments to create a Reposts.
     * @example
     * // Create one Reposts
     * const Reposts = await prisma.reposts.create({
     *   data: {
     *     // ... data to create a Reposts
     *   }
     * })
     * 
     */
    create<T extends RepostsCreateArgs>(args: SelectSubset<T, RepostsCreateArgs<ExtArgs>>): Prisma__RepostsClient<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reposts.
     * @param {RepostsCreateManyArgs} args - Arguments to create many Reposts.
     * @example
     * // Create many Reposts
     * const reposts = await prisma.reposts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepostsCreateManyArgs>(args?: SelectSubset<T, RepostsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reposts and returns the data saved in the database.
     * @param {RepostsCreateManyAndReturnArgs} args - Arguments to create many Reposts.
     * @example
     * // Create many Reposts
     * const reposts = await prisma.reposts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reposts and only return the `id`
     * const repostsWithIdOnly = await prisma.reposts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RepostsCreateManyAndReturnArgs>(args?: SelectSubset<T, RepostsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reposts.
     * @param {RepostsDeleteArgs} args - Arguments to delete one Reposts.
     * @example
     * // Delete one Reposts
     * const Reposts = await prisma.reposts.delete({
     *   where: {
     *     // ... filter to delete one Reposts
     *   }
     * })
     * 
     */
    delete<T extends RepostsDeleteArgs>(args: SelectSubset<T, RepostsDeleteArgs<ExtArgs>>): Prisma__RepostsClient<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reposts.
     * @param {RepostsUpdateArgs} args - Arguments to update one Reposts.
     * @example
     * // Update one Reposts
     * const reposts = await prisma.reposts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepostsUpdateArgs>(args: SelectSubset<T, RepostsUpdateArgs<ExtArgs>>): Prisma__RepostsClient<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reposts.
     * @param {RepostsDeleteManyArgs} args - Arguments to filter Reposts to delete.
     * @example
     * // Delete a few Reposts
     * const { count } = await prisma.reposts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepostsDeleteManyArgs>(args?: SelectSubset<T, RepostsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reposts
     * const reposts = await prisma.reposts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepostsUpdateManyArgs>(args: SelectSubset<T, RepostsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reposts.
     * @param {RepostsUpsertArgs} args - Arguments to update or create a Reposts.
     * @example
     * // Update or create a Reposts
     * const reposts = await prisma.reposts.upsert({
     *   create: {
     *     // ... data to create a Reposts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reposts we want to update
     *   }
     * })
     */
    upsert<T extends RepostsUpsertArgs>(args: SelectSubset<T, RepostsUpsertArgs<ExtArgs>>): Prisma__RepostsClient<$Result.GetResult<Prisma.$RepostsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostsCountArgs} args - Arguments to filter Reposts to count.
     * @example
     * // Count the number of Reposts
     * const count = await prisma.reposts.count({
     *   where: {
     *     // ... the filter for the Reposts we want to count
     *   }
     * })
    **/
    count<T extends RepostsCountArgs>(
      args?: Subset<T, RepostsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepostsAggregateArgs>(args: Subset<T, RepostsAggregateArgs>): Prisma.PrismaPromise<GetRepostsAggregateType<T>>

    /**
     * Group by Reposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepostsGroupByArgs['orderBy'] }
        : { orderBy?: RepostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepostsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reposts model
   */
  readonly fields: RepostsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reposts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepostsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Posts<T extends Reposts$PostsArgs<ExtArgs> = {}>(args?: Subset<T, Reposts$PostsArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reposts model
   */ 
  interface RepostsFieldRefs {
    readonly id: FieldRef<"Reposts", 'Int'>
    readonly postsId: FieldRef<"Reposts", 'Int'>
    readonly reposted_user_id: FieldRef<"Reposts", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Reposts findUnique
   */
  export type RepostsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    /**
     * Filter, which Reposts to fetch.
     */
    where: RepostsWhereUniqueInput
  }

  /**
   * Reposts findUniqueOrThrow
   */
  export type RepostsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    /**
     * Filter, which Reposts to fetch.
     */
    where: RepostsWhereUniqueInput
  }

  /**
   * Reposts findFirst
   */
  export type RepostsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    /**
     * Filter, which Reposts to fetch.
     */
    where?: RepostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reposts to fetch.
     */
    orderBy?: RepostsOrderByWithRelationInput | RepostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reposts.
     */
    cursor?: RepostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reposts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reposts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reposts.
     */
    distinct?: RepostsScalarFieldEnum | RepostsScalarFieldEnum[]
  }

  /**
   * Reposts findFirstOrThrow
   */
  export type RepostsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    /**
     * Filter, which Reposts to fetch.
     */
    where?: RepostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reposts to fetch.
     */
    orderBy?: RepostsOrderByWithRelationInput | RepostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reposts.
     */
    cursor?: RepostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reposts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reposts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reposts.
     */
    distinct?: RepostsScalarFieldEnum | RepostsScalarFieldEnum[]
  }

  /**
   * Reposts findMany
   */
  export type RepostsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    /**
     * Filter, which Reposts to fetch.
     */
    where?: RepostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reposts to fetch.
     */
    orderBy?: RepostsOrderByWithRelationInput | RepostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reposts.
     */
    cursor?: RepostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reposts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reposts.
     */
    skip?: number
    distinct?: RepostsScalarFieldEnum | RepostsScalarFieldEnum[]
  }

  /**
   * Reposts create
   */
  export type RepostsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    /**
     * The data needed to create a Reposts.
     */
    data?: XOR<RepostsCreateInput, RepostsUncheckedCreateInput>
  }

  /**
   * Reposts createMany
   */
  export type RepostsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reposts.
     */
    data: RepostsCreateManyInput | RepostsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reposts createManyAndReturn
   */
  export type RepostsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reposts.
     */
    data: RepostsCreateManyInput | RepostsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reposts update
   */
  export type RepostsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    /**
     * The data needed to update a Reposts.
     */
    data: XOR<RepostsUpdateInput, RepostsUncheckedUpdateInput>
    /**
     * Choose, which Reposts to update.
     */
    where: RepostsWhereUniqueInput
  }

  /**
   * Reposts updateMany
   */
  export type RepostsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reposts.
     */
    data: XOR<RepostsUpdateManyMutationInput, RepostsUncheckedUpdateManyInput>
    /**
     * Filter which Reposts to update
     */
    where?: RepostsWhereInput
  }

  /**
   * Reposts upsert
   */
  export type RepostsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    /**
     * The filter to search for the Reposts to update in case it exists.
     */
    where: RepostsWhereUniqueInput
    /**
     * In case the Reposts found by the `where` argument doesn't exist, create a new Reposts with this data.
     */
    create: XOR<RepostsCreateInput, RepostsUncheckedCreateInput>
    /**
     * In case the Reposts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepostsUpdateInput, RepostsUncheckedUpdateInput>
  }

  /**
   * Reposts delete
   */
  export type RepostsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
    /**
     * Filter which Reposts to delete.
     */
    where: RepostsWhereUniqueInput
  }

  /**
   * Reposts deleteMany
   */
  export type RepostsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reposts to delete
     */
    where?: RepostsWhereInput
  }

  /**
   * Reposts.Posts
   */
  export type Reposts$PostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
  }

  /**
   * Reposts without action
   */
  export type RepostsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reposts
     */
    select?: RepostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostsInclude<ExtArgs> | null
  }


  /**
   * Model Shares
   */

  export type AggregateShares = {
    _count: SharesCountAggregateOutputType | null
    _avg: SharesAvgAggregateOutputType | null
    _sum: SharesSumAggregateOutputType | null
    _min: SharesMinAggregateOutputType | null
    _max: SharesMaxAggregateOutputType | null
  }

  export type SharesAvgAggregateOutputType = {
    id: number | null
    postsId: number | null
    shared_user_id: number | null
  }

  export type SharesSumAggregateOutputType = {
    id: number | null
    postsId: number | null
    shared_user_id: number | null
  }

  export type SharesMinAggregateOutputType = {
    id: number | null
    postsId: number | null
    shared_user_id: number | null
  }

  export type SharesMaxAggregateOutputType = {
    id: number | null
    postsId: number | null
    shared_user_id: number | null
  }

  export type SharesCountAggregateOutputType = {
    id: number
    postsId: number
    shared_user_id: number
    _all: number
  }


  export type SharesAvgAggregateInputType = {
    id?: true
    postsId?: true
    shared_user_id?: true
  }

  export type SharesSumAggregateInputType = {
    id?: true
    postsId?: true
    shared_user_id?: true
  }

  export type SharesMinAggregateInputType = {
    id?: true
    postsId?: true
    shared_user_id?: true
  }

  export type SharesMaxAggregateInputType = {
    id?: true
    postsId?: true
    shared_user_id?: true
  }

  export type SharesCountAggregateInputType = {
    id?: true
    postsId?: true
    shared_user_id?: true
    _all?: true
  }

  export type SharesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shares to aggregate.
     */
    where?: SharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shares to fetch.
     */
    orderBy?: SharesOrderByWithRelationInput | SharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shares
    **/
    _count?: true | SharesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharesMaxAggregateInputType
  }

  export type GetSharesAggregateType<T extends SharesAggregateArgs> = {
        [P in keyof T & keyof AggregateShares]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShares[P]>
      : GetScalarType<T[P], AggregateShares[P]>
  }




  export type SharesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharesWhereInput
    orderBy?: SharesOrderByWithAggregationInput | SharesOrderByWithAggregationInput[]
    by: SharesScalarFieldEnum[] | SharesScalarFieldEnum
    having?: SharesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharesCountAggregateInputType | true
    _avg?: SharesAvgAggregateInputType
    _sum?: SharesSumAggregateInputType
    _min?: SharesMinAggregateInputType
    _max?: SharesMaxAggregateInputType
  }

  export type SharesGroupByOutputType = {
    id: number
    postsId: number | null
    shared_user_id: number | null
    _count: SharesCountAggregateOutputType | null
    _avg: SharesAvgAggregateOutputType | null
    _sum: SharesSumAggregateOutputType | null
    _min: SharesMinAggregateOutputType | null
    _max: SharesMaxAggregateOutputType | null
  }

  type GetSharesGroupByPayload<T extends SharesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharesGroupByOutputType[P]>
            : GetScalarType<T[P], SharesGroupByOutputType[P]>
        }
      >
    >


  export type SharesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    shared_user_id?: boolean
    Posts?: boolean | Shares$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["shares"]>

  export type SharesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    shared_user_id?: boolean
    Posts?: boolean | Shares$PostsArgs<ExtArgs>
  }, ExtArgs["result"]["shares"]>

  export type SharesSelectScalar = {
    id?: boolean
    postsId?: boolean
    shared_user_id?: boolean
  }

  export type SharesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | Shares$PostsArgs<ExtArgs>
  }
  export type SharesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Posts?: boolean | Shares$PostsArgs<ExtArgs>
  }

  export type $SharesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shares"
    objects: {
      Posts: Prisma.$PostsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postsId: number | null
      shared_user_id: number | null
    }, ExtArgs["result"]["shares"]>
    composites: {}
  }

  type SharesGetPayload<S extends boolean | null | undefined | SharesDefaultArgs> = $Result.GetResult<Prisma.$SharesPayload, S>

  type SharesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SharesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SharesCountAggregateInputType | true
    }

  export interface SharesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shares'], meta: { name: 'Shares' } }
    /**
     * Find zero or one Shares that matches the filter.
     * @param {SharesFindUniqueArgs} args - Arguments to find a Shares
     * @example
     * // Get one Shares
     * const shares = await prisma.shares.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharesFindUniqueArgs>(args: SelectSubset<T, SharesFindUniqueArgs<ExtArgs>>): Prisma__SharesClient<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shares that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SharesFindUniqueOrThrowArgs} args - Arguments to find a Shares
     * @example
     * // Get one Shares
     * const shares = await prisma.shares.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharesFindUniqueOrThrowArgs>(args: SelectSubset<T, SharesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharesClient<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharesFindFirstArgs} args - Arguments to find a Shares
     * @example
     * // Get one Shares
     * const shares = await prisma.shares.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharesFindFirstArgs>(args?: SelectSubset<T, SharesFindFirstArgs<ExtArgs>>): Prisma__SharesClient<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shares that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharesFindFirstOrThrowArgs} args - Arguments to find a Shares
     * @example
     * // Get one Shares
     * const shares = await prisma.shares.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharesFindFirstOrThrowArgs>(args?: SelectSubset<T, SharesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharesClient<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shares
     * const shares = await prisma.shares.findMany()
     * 
     * // Get first 10 Shares
     * const shares = await prisma.shares.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharesWithIdOnly = await prisma.shares.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharesFindManyArgs>(args?: SelectSubset<T, SharesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shares.
     * @param {SharesCreateArgs} args - Arguments to create a Shares.
     * @example
     * // Create one Shares
     * const Shares = await prisma.shares.create({
     *   data: {
     *     // ... data to create a Shares
     *   }
     * })
     * 
     */
    create<T extends SharesCreateArgs>(args: SelectSubset<T, SharesCreateArgs<ExtArgs>>): Prisma__SharesClient<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shares.
     * @param {SharesCreateManyArgs} args - Arguments to create many Shares.
     * @example
     * // Create many Shares
     * const shares = await prisma.shares.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharesCreateManyArgs>(args?: SelectSubset<T, SharesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shares and returns the data saved in the database.
     * @param {SharesCreateManyAndReturnArgs} args - Arguments to create many Shares.
     * @example
     * // Create many Shares
     * const shares = await prisma.shares.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shares and only return the `id`
     * const sharesWithIdOnly = await prisma.shares.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharesCreateManyAndReturnArgs>(args?: SelectSubset<T, SharesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Shares.
     * @param {SharesDeleteArgs} args - Arguments to delete one Shares.
     * @example
     * // Delete one Shares
     * const Shares = await prisma.shares.delete({
     *   where: {
     *     // ... filter to delete one Shares
     *   }
     * })
     * 
     */
    delete<T extends SharesDeleteArgs>(args: SelectSubset<T, SharesDeleteArgs<ExtArgs>>): Prisma__SharesClient<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shares.
     * @param {SharesUpdateArgs} args - Arguments to update one Shares.
     * @example
     * // Update one Shares
     * const shares = await prisma.shares.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharesUpdateArgs>(args: SelectSubset<T, SharesUpdateArgs<ExtArgs>>): Prisma__SharesClient<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shares.
     * @param {SharesDeleteManyArgs} args - Arguments to filter Shares to delete.
     * @example
     * // Delete a few Shares
     * const { count } = await prisma.shares.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharesDeleteManyArgs>(args?: SelectSubset<T, SharesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shares
     * const shares = await prisma.shares.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharesUpdateManyArgs>(args: SelectSubset<T, SharesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shares.
     * @param {SharesUpsertArgs} args - Arguments to update or create a Shares.
     * @example
     * // Update or create a Shares
     * const shares = await prisma.shares.upsert({
     *   create: {
     *     // ... data to create a Shares
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shares we want to update
     *   }
     * })
     */
    upsert<T extends SharesUpsertArgs>(args: SelectSubset<T, SharesUpsertArgs<ExtArgs>>): Prisma__SharesClient<$Result.GetResult<Prisma.$SharesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharesCountArgs} args - Arguments to filter Shares to count.
     * @example
     * // Count the number of Shares
     * const count = await prisma.shares.count({
     *   where: {
     *     // ... the filter for the Shares we want to count
     *   }
     * })
    **/
    count<T extends SharesCountArgs>(
      args?: Subset<T, SharesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharesAggregateArgs>(args: Subset<T, SharesAggregateArgs>): Prisma.PrismaPromise<GetSharesAggregateType<T>>

    /**
     * Group by Shares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharesGroupByArgs['orderBy'] }
        : { orderBy?: SharesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shares model
   */
  readonly fields: SharesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shares.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Posts<T extends Shares$PostsArgs<ExtArgs> = {}>(args?: Subset<T, Shares$PostsArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shares model
   */ 
  interface SharesFieldRefs {
    readonly id: FieldRef<"Shares", 'Int'>
    readonly postsId: FieldRef<"Shares", 'Int'>
    readonly shared_user_id: FieldRef<"Shares", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Shares findUnique
   */
  export type SharesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    /**
     * Filter, which Shares to fetch.
     */
    where: SharesWhereUniqueInput
  }

  /**
   * Shares findUniqueOrThrow
   */
  export type SharesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    /**
     * Filter, which Shares to fetch.
     */
    where: SharesWhereUniqueInput
  }

  /**
   * Shares findFirst
   */
  export type SharesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    /**
     * Filter, which Shares to fetch.
     */
    where?: SharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shares to fetch.
     */
    orderBy?: SharesOrderByWithRelationInput | SharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shares.
     */
    cursor?: SharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shares.
     */
    distinct?: SharesScalarFieldEnum | SharesScalarFieldEnum[]
  }

  /**
   * Shares findFirstOrThrow
   */
  export type SharesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    /**
     * Filter, which Shares to fetch.
     */
    where?: SharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shares to fetch.
     */
    orderBy?: SharesOrderByWithRelationInput | SharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shares.
     */
    cursor?: SharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shares.
     */
    distinct?: SharesScalarFieldEnum | SharesScalarFieldEnum[]
  }

  /**
   * Shares findMany
   */
  export type SharesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    /**
     * Filter, which Shares to fetch.
     */
    where?: SharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shares to fetch.
     */
    orderBy?: SharesOrderByWithRelationInput | SharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shares.
     */
    cursor?: SharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shares.
     */
    skip?: number
    distinct?: SharesScalarFieldEnum | SharesScalarFieldEnum[]
  }

  /**
   * Shares create
   */
  export type SharesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    /**
     * The data needed to create a Shares.
     */
    data?: XOR<SharesCreateInput, SharesUncheckedCreateInput>
  }

  /**
   * Shares createMany
   */
  export type SharesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shares.
     */
    data: SharesCreateManyInput | SharesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shares createManyAndReturn
   */
  export type SharesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shares.
     */
    data: SharesCreateManyInput | SharesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shares update
   */
  export type SharesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    /**
     * The data needed to update a Shares.
     */
    data: XOR<SharesUpdateInput, SharesUncheckedUpdateInput>
    /**
     * Choose, which Shares to update.
     */
    where: SharesWhereUniqueInput
  }

  /**
   * Shares updateMany
   */
  export type SharesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shares.
     */
    data: XOR<SharesUpdateManyMutationInput, SharesUncheckedUpdateManyInput>
    /**
     * Filter which Shares to update
     */
    where?: SharesWhereInput
  }

  /**
   * Shares upsert
   */
  export type SharesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    /**
     * The filter to search for the Shares to update in case it exists.
     */
    where: SharesWhereUniqueInput
    /**
     * In case the Shares found by the `where` argument doesn't exist, create a new Shares with this data.
     */
    create: XOR<SharesCreateInput, SharesUncheckedCreateInput>
    /**
     * In case the Shares was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharesUpdateInput, SharesUncheckedUpdateInput>
  }

  /**
   * Shares delete
   */
  export type SharesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
    /**
     * Filter which Shares to delete.
     */
    where: SharesWhereUniqueInput
  }

  /**
   * Shares deleteMany
   */
  export type SharesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shares to delete
     */
    where?: SharesWhereInput
  }

  /**
   * Shares.Posts
   */
  export type Shares$PostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
  }

  /**
   * Shares without action
   */
  export type SharesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shares
     */
    select?: SharesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharesInclude<ExtArgs> | null
  }


  /**
   * Model Questions
   */

  export type AggregateQuestions = {
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type QuestionsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type QuestionsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    question: string | null
    question_description: string | null
    asked_at: Date | null
  }

  export type QuestionsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    question: string | null
    question_description: string | null
    asked_at: Date | null
  }

  export type QuestionsCountAggregateOutputType = {
    id: number
    userId: number
    question: number
    question_description: number
    asked_at: number
    _all: number
  }


  export type QuestionsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type QuestionsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type QuestionsMinAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    question_description?: true
    asked_at?: true
  }

  export type QuestionsMaxAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    question_description?: true
    asked_at?: true
  }

  export type QuestionsCountAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    question_description?: true
    asked_at?: true
    _all?: true
  }

  export type QuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to aggregate.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }




  export type QuestionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsWhereInput
    orderBy?: QuestionsOrderByWithAggregationInput | QuestionsOrderByWithAggregationInput[]
    by: QuestionsScalarFieldEnum[] | QuestionsScalarFieldEnum
    having?: QuestionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsCountAggregateInputType | true
    _avg?: QuestionsAvgAggregateInputType
    _sum?: QuestionsSumAggregateInputType
    _min?: QuestionsMinAggregateInputType
    _max?: QuestionsMaxAggregateInputType
  }

  export type QuestionsGroupByOutputType = {
    id: number
    userId: number | null
    question: string
    question_description: string
    asked_at: Date
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  type GetQuestionsGroupByPayload<T extends QuestionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    question_description?: boolean
    asked_at?: boolean
    User?: boolean | Questions$UserArgs<ExtArgs>
    question_image_links?: boolean | Questions$question_image_linksArgs<ExtArgs>
    insightful?: boolean | Questions$insightfulArgs<ExtArgs>
    answers?: boolean | Questions$answersArgs<ExtArgs>
    questionComments?: boolean | Questions$questionCommentsArgs<ExtArgs>
    questionReferences?: boolean | Questions$questionReferencesArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>

  export type QuestionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    question_description?: boolean
    asked_at?: boolean
    User?: boolean | Questions$UserArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>

  export type QuestionsSelectScalar = {
    id?: boolean
    userId?: boolean
    question?: boolean
    question_description?: boolean
    asked_at?: boolean
  }

  export type QuestionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Questions$UserArgs<ExtArgs>
    question_image_links?: boolean | Questions$question_image_linksArgs<ExtArgs>
    insightful?: boolean | Questions$insightfulArgs<ExtArgs>
    answers?: boolean | Questions$answersArgs<ExtArgs>
    questionComments?: boolean | Questions$questionCommentsArgs<ExtArgs>
    questionReferences?: boolean | Questions$questionReferencesArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Questions$UserArgs<ExtArgs>
  }

  export type $QuestionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Questions"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      question_image_links: Prisma.$QuestionImageLinksPayload<ExtArgs>[]
      insightful: Prisma.$InsightfulPayload<ExtArgs>[]
      answers: Prisma.$AnswersPayload<ExtArgs>[]
      questionComments: Prisma.$QuestionCommentsPayload<ExtArgs>[]
      questionReferences: Prisma.$QuestionReferencesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      question: string
      question_description: string
      asked_at: Date
    }, ExtArgs["result"]["questions"]>
    composites: {}
  }

  type QuestionsGetPayload<S extends boolean | null | undefined | QuestionsDefaultArgs> = $Result.GetResult<Prisma.$QuestionsPayload, S>

  type QuestionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionsCountAggregateInputType | true
    }

  export interface QuestionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Questions'], meta: { name: 'Questions' } }
    /**
     * Find zero or one Questions that matches the filter.
     * @param {QuestionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionsFindUniqueArgs>(args: SelectSubset<T, QuestionsFindUniqueArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionsFindUniqueOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionsFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionsFindFirstArgs>(args?: SelectSubset<T, QuestionsFindFirstArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsFindFirstOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionsFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsWithIdOnly = await prisma.questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionsFindManyArgs>(args?: SelectSubset<T, QuestionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questions.
     * @param {QuestionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
     */
    create<T extends QuestionsCreateArgs>(args: SelectSubset<T, QuestionsCreateArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {QuestionsCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionsCreateManyArgs>(args?: SelectSubset<T, QuestionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionsCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionsWithIdOnly = await prisma.questions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionsCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Questions.
     * @param {QuestionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
     */
    delete<T extends QuestionsDeleteArgs>(args: SelectSubset<T, QuestionsDeleteArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questions.
     * @param {QuestionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionsUpdateArgs>(args: SelectSubset<T, QuestionsUpdateArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {QuestionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionsDeleteManyArgs>(args?: SelectSubset<T, QuestionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionsUpdateManyArgs>(args: SelectSubset<T, QuestionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questions.
     * @param {QuestionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
     */
    upsert<T extends QuestionsUpsertArgs>(args: SelectSubset<T, QuestionsUpsertArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionsCountArgs>(
      args?: Subset<T, QuestionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Prisma.PrismaPromise<GetQuestionsAggregateType<T>>

    /**
     * Group by Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Questions model
   */
  readonly fields: QuestionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Questions$UserArgs<ExtArgs> = {}>(args?: Subset<T, Questions$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    question_image_links<T extends Questions$question_image_linksArgs<ExtArgs> = {}>(args?: Subset<T, Questions$question_image_linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "findMany"> | Null>
    insightful<T extends Questions$insightfulArgs<ExtArgs> = {}>(args?: Subset<T, Questions$insightfulArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "findMany"> | Null>
    answers<T extends Questions$answersArgs<ExtArgs> = {}>(args?: Subset<T, Questions$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findMany"> | Null>
    questionComments<T extends Questions$questionCommentsArgs<ExtArgs> = {}>(args?: Subset<T, Questions$questionCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "findMany"> | Null>
    questionReferences<T extends Questions$questionReferencesArgs<ExtArgs> = {}>(args?: Subset<T, Questions$questionReferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Questions model
   */ 
  interface QuestionsFieldRefs {
    readonly id: FieldRef<"Questions", 'Int'>
    readonly userId: FieldRef<"Questions", 'Int'>
    readonly question: FieldRef<"Questions", 'String'>
    readonly question_description: FieldRef<"Questions", 'String'>
    readonly asked_at: FieldRef<"Questions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Questions findUnique
   */
  export type QuestionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions findUniqueOrThrow
   */
  export type QuestionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions findFirst
   */
  export type QuestionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * Questions findFirstOrThrow
   */
  export type QuestionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * Questions findMany
   */
  export type QuestionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * Questions create
   */
  export type QuestionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Questions.
     */
    data: XOR<QuestionsCreateInput, QuestionsUncheckedCreateInput>
  }

  /**
   * Questions createMany
   */
  export type QuestionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionsCreateManyInput | QuestionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Questions createManyAndReturn
   */
  export type QuestionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionsCreateManyInput | QuestionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Questions update
   */
  export type QuestionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Questions.
     */
    data: XOR<QuestionsUpdateInput, QuestionsUncheckedUpdateInput>
    /**
     * Choose, which Questions to update.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions updateMany
   */
  export type QuestionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionsUpdateManyMutationInput, QuestionsUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionsWhereInput
  }

  /**
   * Questions upsert
   */
  export type QuestionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Questions to update in case it exists.
     */
    where: QuestionsWhereUniqueInput
    /**
     * In case the Questions found by the `where` argument doesn't exist, create a new Questions with this data.
     */
    create: XOR<QuestionsCreateInput, QuestionsUncheckedCreateInput>
    /**
     * In case the Questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionsUpdateInput, QuestionsUncheckedUpdateInput>
  }

  /**
   * Questions delete
   */
  export type QuestionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter which Questions to delete.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions deleteMany
   */
  export type QuestionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionsWhereInput
  }

  /**
   * Questions.User
   */
  export type Questions$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Questions.question_image_links
   */
  export type Questions$question_image_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    where?: QuestionImageLinksWhereInput
    orderBy?: QuestionImageLinksOrderByWithRelationInput | QuestionImageLinksOrderByWithRelationInput[]
    cursor?: QuestionImageLinksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionImageLinksScalarFieldEnum | QuestionImageLinksScalarFieldEnum[]
  }

  /**
   * Questions.insightful
   */
  export type Questions$insightfulArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    where?: InsightfulWhereInput
    orderBy?: InsightfulOrderByWithRelationInput | InsightfulOrderByWithRelationInput[]
    cursor?: InsightfulWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightfulScalarFieldEnum | InsightfulScalarFieldEnum[]
  }

  /**
   * Questions.answers
   */
  export type Questions$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    where?: AnswersWhereInput
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    cursor?: AnswersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * Questions.questionComments
   */
  export type Questions$questionCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    where?: QuestionCommentsWhereInput
    orderBy?: QuestionCommentsOrderByWithRelationInput | QuestionCommentsOrderByWithRelationInput[]
    cursor?: QuestionCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionCommentsScalarFieldEnum | QuestionCommentsScalarFieldEnum[]
  }

  /**
   * Questions.questionReferences
   */
  export type Questions$questionReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    where?: QuestionReferencesWhereInput
    orderBy?: QuestionReferencesOrderByWithRelationInput | QuestionReferencesOrderByWithRelationInput[]
    cursor?: QuestionReferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionReferencesScalarFieldEnum | QuestionReferencesScalarFieldEnum[]
  }

  /**
   * Questions without action
   */
  export type QuestionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
  }


  /**
   * Model QuestionReferences
   */

  export type AggregateQuestionReferences = {
    _count: QuestionReferencesCountAggregateOutputType | null
    _avg: QuestionReferencesAvgAggregateOutputType | null
    _sum: QuestionReferencesSumAggregateOutputType | null
    _min: QuestionReferencesMinAggregateOutputType | null
    _max: QuestionReferencesMaxAggregateOutputType | null
  }

  export type QuestionReferencesAvgAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type QuestionReferencesSumAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type QuestionReferencesMinAggregateOutputType = {
    id: number | null
    questionsId: number | null
    reference: string | null
  }

  export type QuestionReferencesMaxAggregateOutputType = {
    id: number | null
    questionsId: number | null
    reference: string | null
  }

  export type QuestionReferencesCountAggregateOutputType = {
    id: number
    questionsId: number
    reference: number
    _all: number
  }


  export type QuestionReferencesAvgAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type QuestionReferencesSumAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type QuestionReferencesMinAggregateInputType = {
    id?: true
    questionsId?: true
    reference?: true
  }

  export type QuestionReferencesMaxAggregateInputType = {
    id?: true
    questionsId?: true
    reference?: true
  }

  export type QuestionReferencesCountAggregateInputType = {
    id?: true
    questionsId?: true
    reference?: true
    _all?: true
  }

  export type QuestionReferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionReferences to aggregate.
     */
    where?: QuestionReferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionReferences to fetch.
     */
    orderBy?: QuestionReferencesOrderByWithRelationInput | QuestionReferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionReferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionReferences
    **/
    _count?: true | QuestionReferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionReferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionReferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionReferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionReferencesMaxAggregateInputType
  }

  export type GetQuestionReferencesAggregateType<T extends QuestionReferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionReferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionReferences[P]>
      : GetScalarType<T[P], AggregateQuestionReferences[P]>
  }




  export type QuestionReferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionReferencesWhereInput
    orderBy?: QuestionReferencesOrderByWithAggregationInput | QuestionReferencesOrderByWithAggregationInput[]
    by: QuestionReferencesScalarFieldEnum[] | QuestionReferencesScalarFieldEnum
    having?: QuestionReferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionReferencesCountAggregateInputType | true
    _avg?: QuestionReferencesAvgAggregateInputType
    _sum?: QuestionReferencesSumAggregateInputType
    _min?: QuestionReferencesMinAggregateInputType
    _max?: QuestionReferencesMaxAggregateInputType
  }

  export type QuestionReferencesGroupByOutputType = {
    id: number
    questionsId: number | null
    reference: string | null
    _count: QuestionReferencesCountAggregateOutputType | null
    _avg: QuestionReferencesAvgAggregateOutputType | null
    _sum: QuestionReferencesSumAggregateOutputType | null
    _min: QuestionReferencesMinAggregateOutputType | null
    _max: QuestionReferencesMaxAggregateOutputType | null
  }

  type GetQuestionReferencesGroupByPayload<T extends QuestionReferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionReferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionReferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionReferencesGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionReferencesGroupByOutputType[P]>
        }
      >
    >


  export type QuestionReferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    reference?: boolean
    Questions?: boolean | QuestionReferences$QuestionsArgs<ExtArgs>
  }, ExtArgs["result"]["questionReferences"]>

  export type QuestionReferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    reference?: boolean
    Questions?: boolean | QuestionReferences$QuestionsArgs<ExtArgs>
  }, ExtArgs["result"]["questionReferences"]>

  export type QuestionReferencesSelectScalar = {
    id?: boolean
    questionsId?: boolean
    reference?: boolean
  }

  export type QuestionReferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | QuestionReferences$QuestionsArgs<ExtArgs>
  }
  export type QuestionReferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | QuestionReferences$QuestionsArgs<ExtArgs>
  }

  export type $QuestionReferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionReferences"
    objects: {
      Questions: Prisma.$QuestionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionsId: number | null
      reference: string | null
    }, ExtArgs["result"]["questionReferences"]>
    composites: {}
  }

  type QuestionReferencesGetPayload<S extends boolean | null | undefined | QuestionReferencesDefaultArgs> = $Result.GetResult<Prisma.$QuestionReferencesPayload, S>

  type QuestionReferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionReferencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionReferencesCountAggregateInputType | true
    }

  export interface QuestionReferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionReferences'], meta: { name: 'QuestionReferences' } }
    /**
     * Find zero or one QuestionReferences that matches the filter.
     * @param {QuestionReferencesFindUniqueArgs} args - Arguments to find a QuestionReferences
     * @example
     * // Get one QuestionReferences
     * const questionReferences = await prisma.questionReferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionReferencesFindUniqueArgs>(args: SelectSubset<T, QuestionReferencesFindUniqueArgs<ExtArgs>>): Prisma__QuestionReferencesClient<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionReferences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionReferencesFindUniqueOrThrowArgs} args - Arguments to find a QuestionReferences
     * @example
     * // Get one QuestionReferences
     * const questionReferences = await prisma.questionReferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionReferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionReferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionReferencesClient<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionReferencesFindFirstArgs} args - Arguments to find a QuestionReferences
     * @example
     * // Get one QuestionReferences
     * const questionReferences = await prisma.questionReferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionReferencesFindFirstArgs>(args?: SelectSubset<T, QuestionReferencesFindFirstArgs<ExtArgs>>): Prisma__QuestionReferencesClient<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionReferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionReferencesFindFirstOrThrowArgs} args - Arguments to find a QuestionReferences
     * @example
     * // Get one QuestionReferences
     * const questionReferences = await prisma.questionReferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionReferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionReferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionReferencesClient<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionReferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionReferences
     * const questionReferences = await prisma.questionReferences.findMany()
     * 
     * // Get first 10 QuestionReferences
     * const questionReferences = await prisma.questionReferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionReferencesWithIdOnly = await prisma.questionReferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionReferencesFindManyArgs>(args?: SelectSubset<T, QuestionReferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionReferences.
     * @param {QuestionReferencesCreateArgs} args - Arguments to create a QuestionReferences.
     * @example
     * // Create one QuestionReferences
     * const QuestionReferences = await prisma.questionReferences.create({
     *   data: {
     *     // ... data to create a QuestionReferences
     *   }
     * })
     * 
     */
    create<T extends QuestionReferencesCreateArgs>(args: SelectSubset<T, QuestionReferencesCreateArgs<ExtArgs>>): Prisma__QuestionReferencesClient<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionReferences.
     * @param {QuestionReferencesCreateManyArgs} args - Arguments to create many QuestionReferences.
     * @example
     * // Create many QuestionReferences
     * const questionReferences = await prisma.questionReferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionReferencesCreateManyArgs>(args?: SelectSubset<T, QuestionReferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionReferences and returns the data saved in the database.
     * @param {QuestionReferencesCreateManyAndReturnArgs} args - Arguments to create many QuestionReferences.
     * @example
     * // Create many QuestionReferences
     * const questionReferences = await prisma.questionReferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionReferences and only return the `id`
     * const questionReferencesWithIdOnly = await prisma.questionReferences.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionReferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionReferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuestionReferences.
     * @param {QuestionReferencesDeleteArgs} args - Arguments to delete one QuestionReferences.
     * @example
     * // Delete one QuestionReferences
     * const QuestionReferences = await prisma.questionReferences.delete({
     *   where: {
     *     // ... filter to delete one QuestionReferences
     *   }
     * })
     * 
     */
    delete<T extends QuestionReferencesDeleteArgs>(args: SelectSubset<T, QuestionReferencesDeleteArgs<ExtArgs>>): Prisma__QuestionReferencesClient<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionReferences.
     * @param {QuestionReferencesUpdateArgs} args - Arguments to update one QuestionReferences.
     * @example
     * // Update one QuestionReferences
     * const questionReferences = await prisma.questionReferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionReferencesUpdateArgs>(args: SelectSubset<T, QuestionReferencesUpdateArgs<ExtArgs>>): Prisma__QuestionReferencesClient<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionReferences.
     * @param {QuestionReferencesDeleteManyArgs} args - Arguments to filter QuestionReferences to delete.
     * @example
     * // Delete a few QuestionReferences
     * const { count } = await prisma.questionReferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionReferencesDeleteManyArgs>(args?: SelectSubset<T, QuestionReferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionReferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionReferences
     * const questionReferences = await prisma.questionReferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionReferencesUpdateManyArgs>(args: SelectSubset<T, QuestionReferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionReferences.
     * @param {QuestionReferencesUpsertArgs} args - Arguments to update or create a QuestionReferences.
     * @example
     * // Update or create a QuestionReferences
     * const questionReferences = await prisma.questionReferences.upsert({
     *   create: {
     *     // ... data to create a QuestionReferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionReferences we want to update
     *   }
     * })
     */
    upsert<T extends QuestionReferencesUpsertArgs>(args: SelectSubset<T, QuestionReferencesUpsertArgs<ExtArgs>>): Prisma__QuestionReferencesClient<$Result.GetResult<Prisma.$QuestionReferencesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionReferencesCountArgs} args - Arguments to filter QuestionReferences to count.
     * @example
     * // Count the number of QuestionReferences
     * const count = await prisma.questionReferences.count({
     *   where: {
     *     // ... the filter for the QuestionReferences we want to count
     *   }
     * })
    **/
    count<T extends QuestionReferencesCountArgs>(
      args?: Subset<T, QuestionReferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionReferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionReferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionReferencesAggregateArgs>(args: Subset<T, QuestionReferencesAggregateArgs>): Prisma.PrismaPromise<GetQuestionReferencesAggregateType<T>>

    /**
     * Group by QuestionReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionReferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionReferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionReferencesGroupByArgs['orderBy'] }
        : { orderBy?: QuestionReferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionReferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionReferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionReferences model
   */
  readonly fields: QuestionReferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionReferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionReferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Questions<T extends QuestionReferences$QuestionsArgs<ExtArgs> = {}>(args?: Subset<T, QuestionReferences$QuestionsArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionReferences model
   */ 
  interface QuestionReferencesFieldRefs {
    readonly id: FieldRef<"QuestionReferences", 'Int'>
    readonly questionsId: FieldRef<"QuestionReferences", 'Int'>
    readonly reference: FieldRef<"QuestionReferences", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuestionReferences findUnique
   */
  export type QuestionReferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    /**
     * Filter, which QuestionReferences to fetch.
     */
    where: QuestionReferencesWhereUniqueInput
  }

  /**
   * QuestionReferences findUniqueOrThrow
   */
  export type QuestionReferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    /**
     * Filter, which QuestionReferences to fetch.
     */
    where: QuestionReferencesWhereUniqueInput
  }

  /**
   * QuestionReferences findFirst
   */
  export type QuestionReferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    /**
     * Filter, which QuestionReferences to fetch.
     */
    where?: QuestionReferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionReferences to fetch.
     */
    orderBy?: QuestionReferencesOrderByWithRelationInput | QuestionReferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionReferences.
     */
    cursor?: QuestionReferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionReferences.
     */
    distinct?: QuestionReferencesScalarFieldEnum | QuestionReferencesScalarFieldEnum[]
  }

  /**
   * QuestionReferences findFirstOrThrow
   */
  export type QuestionReferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    /**
     * Filter, which QuestionReferences to fetch.
     */
    where?: QuestionReferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionReferences to fetch.
     */
    orderBy?: QuestionReferencesOrderByWithRelationInput | QuestionReferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionReferences.
     */
    cursor?: QuestionReferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionReferences.
     */
    distinct?: QuestionReferencesScalarFieldEnum | QuestionReferencesScalarFieldEnum[]
  }

  /**
   * QuestionReferences findMany
   */
  export type QuestionReferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    /**
     * Filter, which QuestionReferences to fetch.
     */
    where?: QuestionReferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionReferences to fetch.
     */
    orderBy?: QuestionReferencesOrderByWithRelationInput | QuestionReferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionReferences.
     */
    cursor?: QuestionReferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionReferences.
     */
    skip?: number
    distinct?: QuestionReferencesScalarFieldEnum | QuestionReferencesScalarFieldEnum[]
  }

  /**
   * QuestionReferences create
   */
  export type QuestionReferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionReferences.
     */
    data?: XOR<QuestionReferencesCreateInput, QuestionReferencesUncheckedCreateInput>
  }

  /**
   * QuestionReferences createMany
   */
  export type QuestionReferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionReferences.
     */
    data: QuestionReferencesCreateManyInput | QuestionReferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionReferences createManyAndReturn
   */
  export type QuestionReferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuestionReferences.
     */
    data: QuestionReferencesCreateManyInput | QuestionReferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionReferences update
   */
  export type QuestionReferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionReferences.
     */
    data: XOR<QuestionReferencesUpdateInput, QuestionReferencesUncheckedUpdateInput>
    /**
     * Choose, which QuestionReferences to update.
     */
    where: QuestionReferencesWhereUniqueInput
  }

  /**
   * QuestionReferences updateMany
   */
  export type QuestionReferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionReferences.
     */
    data: XOR<QuestionReferencesUpdateManyMutationInput, QuestionReferencesUncheckedUpdateManyInput>
    /**
     * Filter which QuestionReferences to update
     */
    where?: QuestionReferencesWhereInput
  }

  /**
   * QuestionReferences upsert
   */
  export type QuestionReferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionReferences to update in case it exists.
     */
    where: QuestionReferencesWhereUniqueInput
    /**
     * In case the QuestionReferences found by the `where` argument doesn't exist, create a new QuestionReferences with this data.
     */
    create: XOR<QuestionReferencesCreateInput, QuestionReferencesUncheckedCreateInput>
    /**
     * In case the QuestionReferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionReferencesUpdateInput, QuestionReferencesUncheckedUpdateInput>
  }

  /**
   * QuestionReferences delete
   */
  export type QuestionReferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
    /**
     * Filter which QuestionReferences to delete.
     */
    where: QuestionReferencesWhereUniqueInput
  }

  /**
   * QuestionReferences deleteMany
   */
  export type QuestionReferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionReferences to delete
     */
    where?: QuestionReferencesWhereInput
  }

  /**
   * QuestionReferences.Questions
   */
  export type QuestionReferences$QuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    where?: QuestionsWhereInput
  }

  /**
   * QuestionReferences without action
   */
  export type QuestionReferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionReferences
     */
    select?: QuestionReferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionReferencesInclude<ExtArgs> | null
  }


  /**
   * Model QuestionComments
   */

  export type AggregateQuestionComments = {
    _count: QuestionCommentsCountAggregateOutputType | null
    _avg: QuestionCommentsAvgAggregateOutputType | null
    _sum: QuestionCommentsSumAggregateOutputType | null
    _min: QuestionCommentsMinAggregateOutputType | null
    _max: QuestionCommentsMaxAggregateOutputType | null
  }

  export type QuestionCommentsAvgAggregateOutputType = {
    id: number | null
    questionsId: number | null
    comment_user_id: number | null
  }

  export type QuestionCommentsSumAggregateOutputType = {
    id: number | null
    questionsId: number | null
    comment_user_id: number | null
  }

  export type QuestionCommentsMinAggregateOutputType = {
    id: number | null
    questionsId: number | null
    comment: string | null
    comment_user_id: number | null
  }

  export type QuestionCommentsMaxAggregateOutputType = {
    id: number | null
    questionsId: number | null
    comment: string | null
    comment_user_id: number | null
  }

  export type QuestionCommentsCountAggregateOutputType = {
    id: number
    questionsId: number
    comment: number
    comment_user_id: number
    _all: number
  }


  export type QuestionCommentsAvgAggregateInputType = {
    id?: true
    questionsId?: true
    comment_user_id?: true
  }

  export type QuestionCommentsSumAggregateInputType = {
    id?: true
    questionsId?: true
    comment_user_id?: true
  }

  export type QuestionCommentsMinAggregateInputType = {
    id?: true
    questionsId?: true
    comment?: true
    comment_user_id?: true
  }

  export type QuestionCommentsMaxAggregateInputType = {
    id?: true
    questionsId?: true
    comment?: true
    comment_user_id?: true
  }

  export type QuestionCommentsCountAggregateInputType = {
    id?: true
    questionsId?: true
    comment?: true
    comment_user_id?: true
    _all?: true
  }

  export type QuestionCommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionComments to aggregate.
     */
    where?: QuestionCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionComments to fetch.
     */
    orderBy?: QuestionCommentsOrderByWithRelationInput | QuestionCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionComments
    **/
    _count?: true | QuestionCommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionCommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionCommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionCommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionCommentsMaxAggregateInputType
  }

  export type GetQuestionCommentsAggregateType<T extends QuestionCommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionComments[P]>
      : GetScalarType<T[P], AggregateQuestionComments[P]>
  }




  export type QuestionCommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionCommentsWhereInput
    orderBy?: QuestionCommentsOrderByWithAggregationInput | QuestionCommentsOrderByWithAggregationInput[]
    by: QuestionCommentsScalarFieldEnum[] | QuestionCommentsScalarFieldEnum
    having?: QuestionCommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCommentsCountAggregateInputType | true
    _avg?: QuestionCommentsAvgAggregateInputType
    _sum?: QuestionCommentsSumAggregateInputType
    _min?: QuestionCommentsMinAggregateInputType
    _max?: QuestionCommentsMaxAggregateInputType
  }

  export type QuestionCommentsGroupByOutputType = {
    id: number
    questionsId: number | null
    comment: string
    comment_user_id: number
    _count: QuestionCommentsCountAggregateOutputType | null
    _avg: QuestionCommentsAvgAggregateOutputType | null
    _sum: QuestionCommentsSumAggregateOutputType | null
    _min: QuestionCommentsMinAggregateOutputType | null
    _max: QuestionCommentsMaxAggregateOutputType | null
  }

  type GetQuestionCommentsGroupByPayload<T extends QuestionCommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionCommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionCommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionCommentsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionCommentsGroupByOutputType[P]>
        }
      >
    >


  export type QuestionCommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    comment?: boolean
    comment_user_id?: boolean
    Questions?: boolean | QuestionComments$QuestionsArgs<ExtArgs>
  }, ExtArgs["result"]["questionComments"]>

  export type QuestionCommentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    comment?: boolean
    comment_user_id?: boolean
    Questions?: boolean | QuestionComments$QuestionsArgs<ExtArgs>
  }, ExtArgs["result"]["questionComments"]>

  export type QuestionCommentsSelectScalar = {
    id?: boolean
    questionsId?: boolean
    comment?: boolean
    comment_user_id?: boolean
  }

  export type QuestionCommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | QuestionComments$QuestionsArgs<ExtArgs>
  }
  export type QuestionCommentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | QuestionComments$QuestionsArgs<ExtArgs>
  }

  export type $QuestionCommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionComments"
    objects: {
      Questions: Prisma.$QuestionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionsId: number | null
      comment: string
      comment_user_id: number
    }, ExtArgs["result"]["questionComments"]>
    composites: {}
  }

  type QuestionCommentsGetPayload<S extends boolean | null | undefined | QuestionCommentsDefaultArgs> = $Result.GetResult<Prisma.$QuestionCommentsPayload, S>

  type QuestionCommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionCommentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionCommentsCountAggregateInputType | true
    }

  export interface QuestionCommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionComments'], meta: { name: 'QuestionComments' } }
    /**
     * Find zero or one QuestionComments that matches the filter.
     * @param {QuestionCommentsFindUniqueArgs} args - Arguments to find a QuestionComments
     * @example
     * // Get one QuestionComments
     * const questionComments = await prisma.questionComments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionCommentsFindUniqueArgs>(args: SelectSubset<T, QuestionCommentsFindUniqueArgs<ExtArgs>>): Prisma__QuestionCommentsClient<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionComments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionCommentsFindUniqueOrThrowArgs} args - Arguments to find a QuestionComments
     * @example
     * // Get one QuestionComments
     * const questionComments = await prisma.questionComments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionCommentsFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionCommentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionCommentsClient<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCommentsFindFirstArgs} args - Arguments to find a QuestionComments
     * @example
     * // Get one QuestionComments
     * const questionComments = await prisma.questionComments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionCommentsFindFirstArgs>(args?: SelectSubset<T, QuestionCommentsFindFirstArgs<ExtArgs>>): Prisma__QuestionCommentsClient<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionComments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCommentsFindFirstOrThrowArgs} args - Arguments to find a QuestionComments
     * @example
     * // Get one QuestionComments
     * const questionComments = await prisma.questionComments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionCommentsFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionCommentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionCommentsClient<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCommentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionComments
     * const questionComments = await prisma.questionComments.findMany()
     * 
     * // Get first 10 QuestionComments
     * const questionComments = await prisma.questionComments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionCommentsWithIdOnly = await prisma.questionComments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionCommentsFindManyArgs>(args?: SelectSubset<T, QuestionCommentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionComments.
     * @param {QuestionCommentsCreateArgs} args - Arguments to create a QuestionComments.
     * @example
     * // Create one QuestionComments
     * const QuestionComments = await prisma.questionComments.create({
     *   data: {
     *     // ... data to create a QuestionComments
     *   }
     * })
     * 
     */
    create<T extends QuestionCommentsCreateArgs>(args: SelectSubset<T, QuestionCommentsCreateArgs<ExtArgs>>): Prisma__QuestionCommentsClient<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionComments.
     * @param {QuestionCommentsCreateManyArgs} args - Arguments to create many QuestionComments.
     * @example
     * // Create many QuestionComments
     * const questionComments = await prisma.questionComments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCommentsCreateManyArgs>(args?: SelectSubset<T, QuestionCommentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionComments and returns the data saved in the database.
     * @param {QuestionCommentsCreateManyAndReturnArgs} args - Arguments to create many QuestionComments.
     * @example
     * // Create many QuestionComments
     * const questionComments = await prisma.questionComments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionComments and only return the `id`
     * const questionCommentsWithIdOnly = await prisma.questionComments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCommentsCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCommentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuestionComments.
     * @param {QuestionCommentsDeleteArgs} args - Arguments to delete one QuestionComments.
     * @example
     * // Delete one QuestionComments
     * const QuestionComments = await prisma.questionComments.delete({
     *   where: {
     *     // ... filter to delete one QuestionComments
     *   }
     * })
     * 
     */
    delete<T extends QuestionCommentsDeleteArgs>(args: SelectSubset<T, QuestionCommentsDeleteArgs<ExtArgs>>): Prisma__QuestionCommentsClient<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionComments.
     * @param {QuestionCommentsUpdateArgs} args - Arguments to update one QuestionComments.
     * @example
     * // Update one QuestionComments
     * const questionComments = await prisma.questionComments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionCommentsUpdateArgs>(args: SelectSubset<T, QuestionCommentsUpdateArgs<ExtArgs>>): Prisma__QuestionCommentsClient<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionComments.
     * @param {QuestionCommentsDeleteManyArgs} args - Arguments to filter QuestionComments to delete.
     * @example
     * // Delete a few QuestionComments
     * const { count } = await prisma.questionComments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionCommentsDeleteManyArgs>(args?: SelectSubset<T, QuestionCommentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionComments
     * const questionComments = await prisma.questionComments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionCommentsUpdateManyArgs>(args: SelectSubset<T, QuestionCommentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionComments.
     * @param {QuestionCommentsUpsertArgs} args - Arguments to update or create a QuestionComments.
     * @example
     * // Update or create a QuestionComments
     * const questionComments = await prisma.questionComments.upsert({
     *   create: {
     *     // ... data to create a QuestionComments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionComments we want to update
     *   }
     * })
     */
    upsert<T extends QuestionCommentsUpsertArgs>(args: SelectSubset<T, QuestionCommentsUpsertArgs<ExtArgs>>): Prisma__QuestionCommentsClient<$Result.GetResult<Prisma.$QuestionCommentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCommentsCountArgs} args - Arguments to filter QuestionComments to count.
     * @example
     * // Count the number of QuestionComments
     * const count = await prisma.questionComments.count({
     *   where: {
     *     // ... the filter for the QuestionComments we want to count
     *   }
     * })
    **/
    count<T extends QuestionCommentsCountArgs>(
      args?: Subset<T, QuestionCommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionCommentsAggregateArgs>(args: Subset<T, QuestionCommentsAggregateArgs>): Prisma.PrismaPromise<GetQuestionCommentsAggregateType<T>>

    /**
     * Group by QuestionComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionCommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionCommentsGroupByArgs['orderBy'] }
        : { orderBy?: QuestionCommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionCommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionComments model
   */
  readonly fields: QuestionCommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionComments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionCommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Questions<T extends QuestionComments$QuestionsArgs<ExtArgs> = {}>(args?: Subset<T, QuestionComments$QuestionsArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionComments model
   */ 
  interface QuestionCommentsFieldRefs {
    readonly id: FieldRef<"QuestionComments", 'Int'>
    readonly questionsId: FieldRef<"QuestionComments", 'Int'>
    readonly comment: FieldRef<"QuestionComments", 'String'>
    readonly comment_user_id: FieldRef<"QuestionComments", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuestionComments findUnique
   */
  export type QuestionCommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    /**
     * Filter, which QuestionComments to fetch.
     */
    where: QuestionCommentsWhereUniqueInput
  }

  /**
   * QuestionComments findUniqueOrThrow
   */
  export type QuestionCommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    /**
     * Filter, which QuestionComments to fetch.
     */
    where: QuestionCommentsWhereUniqueInput
  }

  /**
   * QuestionComments findFirst
   */
  export type QuestionCommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    /**
     * Filter, which QuestionComments to fetch.
     */
    where?: QuestionCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionComments to fetch.
     */
    orderBy?: QuestionCommentsOrderByWithRelationInput | QuestionCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionComments.
     */
    cursor?: QuestionCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionComments.
     */
    distinct?: QuestionCommentsScalarFieldEnum | QuestionCommentsScalarFieldEnum[]
  }

  /**
   * QuestionComments findFirstOrThrow
   */
  export type QuestionCommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    /**
     * Filter, which QuestionComments to fetch.
     */
    where?: QuestionCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionComments to fetch.
     */
    orderBy?: QuestionCommentsOrderByWithRelationInput | QuestionCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionComments.
     */
    cursor?: QuestionCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionComments.
     */
    distinct?: QuestionCommentsScalarFieldEnum | QuestionCommentsScalarFieldEnum[]
  }

  /**
   * QuestionComments findMany
   */
  export type QuestionCommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    /**
     * Filter, which QuestionComments to fetch.
     */
    where?: QuestionCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionComments to fetch.
     */
    orderBy?: QuestionCommentsOrderByWithRelationInput | QuestionCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionComments.
     */
    cursor?: QuestionCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionComments.
     */
    skip?: number
    distinct?: QuestionCommentsScalarFieldEnum | QuestionCommentsScalarFieldEnum[]
  }

  /**
   * QuestionComments create
   */
  export type QuestionCommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionComments.
     */
    data: XOR<QuestionCommentsCreateInput, QuestionCommentsUncheckedCreateInput>
  }

  /**
   * QuestionComments createMany
   */
  export type QuestionCommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionComments.
     */
    data: QuestionCommentsCreateManyInput | QuestionCommentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionComments createManyAndReturn
   */
  export type QuestionCommentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuestionComments.
     */
    data: QuestionCommentsCreateManyInput | QuestionCommentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionComments update
   */
  export type QuestionCommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionComments.
     */
    data: XOR<QuestionCommentsUpdateInput, QuestionCommentsUncheckedUpdateInput>
    /**
     * Choose, which QuestionComments to update.
     */
    where: QuestionCommentsWhereUniqueInput
  }

  /**
   * QuestionComments updateMany
   */
  export type QuestionCommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionComments.
     */
    data: XOR<QuestionCommentsUpdateManyMutationInput, QuestionCommentsUncheckedUpdateManyInput>
    /**
     * Filter which QuestionComments to update
     */
    where?: QuestionCommentsWhereInput
  }

  /**
   * QuestionComments upsert
   */
  export type QuestionCommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionComments to update in case it exists.
     */
    where: QuestionCommentsWhereUniqueInput
    /**
     * In case the QuestionComments found by the `where` argument doesn't exist, create a new QuestionComments with this data.
     */
    create: XOR<QuestionCommentsCreateInput, QuestionCommentsUncheckedCreateInput>
    /**
     * In case the QuestionComments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionCommentsUpdateInput, QuestionCommentsUncheckedUpdateInput>
  }

  /**
   * QuestionComments delete
   */
  export type QuestionCommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
    /**
     * Filter which QuestionComments to delete.
     */
    where: QuestionCommentsWhereUniqueInput
  }

  /**
   * QuestionComments deleteMany
   */
  export type QuestionCommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionComments to delete
     */
    where?: QuestionCommentsWhereInput
  }

  /**
   * QuestionComments.Questions
   */
  export type QuestionComments$QuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    where?: QuestionsWhereInput
  }

  /**
   * QuestionComments without action
   */
  export type QuestionCommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionComments
     */
    select?: QuestionCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionCommentsInclude<ExtArgs> | null
  }


  /**
   * Model Answers
   */

  export type AggregateAnswers = {
    _count: AnswersCountAggregateOutputType | null
    _avg: AnswersAvgAggregateOutputType | null
    _sum: AnswersSumAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  export type AnswersAvgAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type AnswersSumAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type AnswersMinAggregateOutputType = {
    id: number | null
    questionsId: number | null
    answered_user_id: string | null
    answer_description: string | null
  }

  export type AnswersMaxAggregateOutputType = {
    id: number | null
    questionsId: number | null
    answered_user_id: string | null
    answer_description: string | null
  }

  export type AnswersCountAggregateOutputType = {
    id: number
    questionsId: number
    answered_user_id: number
    answer_description: number
    _all: number
  }


  export type AnswersAvgAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type AnswersSumAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type AnswersMinAggregateInputType = {
    id?: true
    questionsId?: true
    answered_user_id?: true
    answer_description?: true
  }

  export type AnswersMaxAggregateInputType = {
    id?: true
    questionsId?: true
    answered_user_id?: true
    answer_description?: true
  }

  export type AnswersCountAggregateInputType = {
    id?: true
    questionsId?: true
    answered_user_id?: true
    answer_description?: true
    _all?: true
  }

  export type AnswersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to aggregate.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswersMaxAggregateInputType
  }

  export type GetAnswersAggregateType<T extends AnswersAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswers[P]>
      : GetScalarType<T[P], AggregateAnswers[P]>
  }




  export type AnswersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswersWhereInput
    orderBy?: AnswersOrderByWithAggregationInput | AnswersOrderByWithAggregationInput[]
    by: AnswersScalarFieldEnum[] | AnswersScalarFieldEnum
    having?: AnswersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswersCountAggregateInputType | true
    _avg?: AnswersAvgAggregateInputType
    _sum?: AnswersSumAggregateInputType
    _min?: AnswersMinAggregateInputType
    _max?: AnswersMaxAggregateInputType
  }

  export type AnswersGroupByOutputType = {
    id: number
    questionsId: number | null
    answered_user_id: string
    answer_description: string
    _count: AnswersCountAggregateOutputType | null
    _avg: AnswersAvgAggregateOutputType | null
    _sum: AnswersSumAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  type GetAnswersGroupByPayload<T extends AnswersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswersGroupByOutputType[P]>
            : GetScalarType<T[P], AnswersGroupByOutputType[P]>
        }
      >
    >


  export type AnswersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    answered_user_id?: boolean
    answer_description?: boolean
    Questions?: boolean | Answers$QuestionsArgs<ExtArgs>
    answer_image_links?: boolean | Answers$answer_image_linksArgs<ExtArgs>
    _count?: boolean | AnswersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>

  export type AnswersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    answered_user_id?: boolean
    answer_description?: boolean
    Questions?: boolean | Answers$QuestionsArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>

  export type AnswersSelectScalar = {
    id?: boolean
    questionsId?: boolean
    answered_user_id?: boolean
    answer_description?: boolean
  }

  export type AnswersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | Answers$QuestionsArgs<ExtArgs>
    answer_image_links?: boolean | Answers$answer_image_linksArgs<ExtArgs>
    _count?: boolean | AnswersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnswersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | Answers$QuestionsArgs<ExtArgs>
  }

  export type $AnswersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answers"
    objects: {
      Questions: Prisma.$QuestionsPayload<ExtArgs> | null
      answer_image_links: Prisma.$Answer_Image_LinksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionsId: number | null
      answered_user_id: string
      answer_description: string
    }, ExtArgs["result"]["answers"]>
    composites: {}
  }

  type AnswersGetPayload<S extends boolean | null | undefined | AnswersDefaultArgs> = $Result.GetResult<Prisma.$AnswersPayload, S>

  type AnswersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnswersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnswersCountAggregateInputType | true
    }

  export interface AnswersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answers'], meta: { name: 'Answers' } }
    /**
     * Find zero or one Answers that matches the filter.
     * @param {AnswersFindUniqueArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswersFindUniqueArgs>(args: SelectSubset<T, AnswersFindUniqueArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Answers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnswersFindUniqueOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswersFindUniqueOrThrowArgs>(args: SelectSubset<T, AnswersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersFindFirstArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswersFindFirstArgs>(args?: SelectSubset<T, AnswersFindFirstArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersFindFirstOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswersFindFirstOrThrowArgs>(args?: SelectSubset<T, AnswersFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answers.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answersWithIdOnly = await prisma.answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnswersFindManyArgs>(args?: SelectSubset<T, AnswersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Answers.
     * @param {AnswersCreateArgs} args - Arguments to create a Answers.
     * @example
     * // Create one Answers
     * const Answers = await prisma.answers.create({
     *   data: {
     *     // ... data to create a Answers
     *   }
     * })
     * 
     */
    create<T extends AnswersCreateArgs>(args: SelectSubset<T, AnswersCreateArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Answers.
     * @param {AnswersCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answers = await prisma.answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnswersCreateManyArgs>(args?: SelectSubset<T, AnswersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Answers and returns the data saved in the database.
     * @param {AnswersCreateManyAndReturnArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answers = await prisma.answers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Answers and only return the `id`
     * const answersWithIdOnly = await prisma.answers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnswersCreateManyAndReturnArgs>(args?: SelectSubset<T, AnswersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Answers.
     * @param {AnswersDeleteArgs} args - Arguments to delete one Answers.
     * @example
     * // Delete one Answers
     * const Answers = await prisma.answers.delete({
     *   where: {
     *     // ... filter to delete one Answers
     *   }
     * })
     * 
     */
    delete<T extends AnswersDeleteArgs>(args: SelectSubset<T, AnswersDeleteArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Answers.
     * @param {AnswersUpdateArgs} args - Arguments to update one Answers.
     * @example
     * // Update one Answers
     * const answers = await prisma.answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnswersUpdateArgs>(args: SelectSubset<T, AnswersUpdateArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Answers.
     * @param {AnswersDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnswersDeleteManyArgs>(args?: SelectSubset<T, AnswersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answers = await prisma.answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnswersUpdateManyArgs>(args: SelectSubset<T, AnswersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Answers.
     * @param {AnswersUpsertArgs} args - Arguments to update or create a Answers.
     * @example
     * // Update or create a Answers
     * const answers = await prisma.answers.upsert({
     *   create: {
     *     // ... data to create a Answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answers we want to update
     *   }
     * })
     */
    upsert<T extends AnswersUpsertArgs>(args: SelectSubset<T, AnswersUpsertArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answers.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswersCountArgs>(
      args?: Subset<T, AnswersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswersAggregateArgs>(args: Subset<T, AnswersAggregateArgs>): Prisma.PrismaPromise<GetAnswersAggregateType<T>>

    /**
     * Group by Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswersGroupByArgs['orderBy'] }
        : { orderBy?: AnswersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answers model
   */
  readonly fields: AnswersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Questions<T extends Answers$QuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Answers$QuestionsArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    answer_image_links<T extends Answers$answer_image_linksArgs<ExtArgs> = {}>(args?: Subset<T, Answers$answer_image_linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Answers model
   */ 
  interface AnswersFieldRefs {
    readonly id: FieldRef<"Answers", 'Int'>
    readonly questionsId: FieldRef<"Answers", 'Int'>
    readonly answered_user_id: FieldRef<"Answers", 'String'>
    readonly answer_description: FieldRef<"Answers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Answers findUnique
   */
  export type AnswersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where: AnswersWhereUniqueInput
  }

  /**
   * Answers findUniqueOrThrow
   */
  export type AnswersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where: AnswersWhereUniqueInput
  }

  /**
   * Answers findFirst
   */
  export type AnswersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * Answers findFirstOrThrow
   */
  export type AnswersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * Answers findMany
   */
  export type AnswersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * Answers create
   */
  export type AnswersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * The data needed to create a Answers.
     */
    data: XOR<AnswersCreateInput, AnswersUncheckedCreateInput>
  }

  /**
   * Answers createMany
   */
  export type AnswersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answers.
     */
    data: AnswersCreateManyInput | AnswersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Answers createManyAndReturn
   */
  export type AnswersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Answers.
     */
    data: AnswersCreateManyInput | AnswersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answers update
   */
  export type AnswersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * The data needed to update a Answers.
     */
    data: XOR<AnswersUpdateInput, AnswersUncheckedUpdateInput>
    /**
     * Choose, which Answers to update.
     */
    where: AnswersWhereUniqueInput
  }

  /**
   * Answers updateMany
   */
  export type AnswersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswersUpdateManyMutationInput, AnswersUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswersWhereInput
  }

  /**
   * Answers upsert
   */
  export type AnswersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * The filter to search for the Answers to update in case it exists.
     */
    where: AnswersWhereUniqueInput
    /**
     * In case the Answers found by the `where` argument doesn't exist, create a new Answers with this data.
     */
    create: XOR<AnswersCreateInput, AnswersUncheckedCreateInput>
    /**
     * In case the Answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswersUpdateInput, AnswersUncheckedUpdateInput>
  }

  /**
   * Answers delete
   */
  export type AnswersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter which Answers to delete.
     */
    where: AnswersWhereUniqueInput
  }

  /**
   * Answers deleteMany
   */
  export type AnswersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswersWhereInput
  }

  /**
   * Answers.Questions
   */
  export type Answers$QuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    where?: QuestionsWhereInput
  }

  /**
   * Answers.answer_image_links
   */
  export type Answers$answer_image_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    where?: Answer_Image_LinksWhereInput
    orderBy?: Answer_Image_LinksOrderByWithRelationInput | Answer_Image_LinksOrderByWithRelationInput[]
    cursor?: Answer_Image_LinksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Answer_Image_LinksScalarFieldEnum | Answer_Image_LinksScalarFieldEnum[]
  }

  /**
   * Answers without action
   */
  export type AnswersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
  }


  /**
   * Model Answer_Image_Links
   */

  export type AggregateAnswer_Image_Links = {
    _count: Answer_Image_LinksCountAggregateOutputType | null
    _avg: Answer_Image_LinksAvgAggregateOutputType | null
    _sum: Answer_Image_LinksSumAggregateOutputType | null
    _min: Answer_Image_LinksMinAggregateOutputType | null
    _max: Answer_Image_LinksMaxAggregateOutputType | null
  }

  export type Answer_Image_LinksAvgAggregateOutputType = {
    id: number | null
    answersId: number | null
  }

  export type Answer_Image_LinksSumAggregateOutputType = {
    id: number | null
    answersId: number | null
  }

  export type Answer_Image_LinksMinAggregateOutputType = {
    id: number | null
    answersId: number | null
    answer_image_link: string | null
  }

  export type Answer_Image_LinksMaxAggregateOutputType = {
    id: number | null
    answersId: number | null
    answer_image_link: string | null
  }

  export type Answer_Image_LinksCountAggregateOutputType = {
    id: number
    answersId: number
    answer_image_link: number
    _all: number
  }


  export type Answer_Image_LinksAvgAggregateInputType = {
    id?: true
    answersId?: true
  }

  export type Answer_Image_LinksSumAggregateInputType = {
    id?: true
    answersId?: true
  }

  export type Answer_Image_LinksMinAggregateInputType = {
    id?: true
    answersId?: true
    answer_image_link?: true
  }

  export type Answer_Image_LinksMaxAggregateInputType = {
    id?: true
    answersId?: true
    answer_image_link?: true
  }

  export type Answer_Image_LinksCountAggregateInputType = {
    id?: true
    answersId?: true
    answer_image_link?: true
    _all?: true
  }

  export type Answer_Image_LinksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answer_Image_Links to aggregate.
     */
    where?: Answer_Image_LinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answer_Image_Links to fetch.
     */
    orderBy?: Answer_Image_LinksOrderByWithRelationInput | Answer_Image_LinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Answer_Image_LinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answer_Image_Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answer_Image_Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answer_Image_Links
    **/
    _count?: true | Answer_Image_LinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Answer_Image_LinksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Answer_Image_LinksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Answer_Image_LinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Answer_Image_LinksMaxAggregateInputType
  }

  export type GetAnswer_Image_LinksAggregateType<T extends Answer_Image_LinksAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer_Image_Links]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer_Image_Links[P]>
      : GetScalarType<T[P], AggregateAnswer_Image_Links[P]>
  }




  export type Answer_Image_LinksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Answer_Image_LinksWhereInput
    orderBy?: Answer_Image_LinksOrderByWithAggregationInput | Answer_Image_LinksOrderByWithAggregationInput[]
    by: Answer_Image_LinksScalarFieldEnum[] | Answer_Image_LinksScalarFieldEnum
    having?: Answer_Image_LinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Answer_Image_LinksCountAggregateInputType | true
    _avg?: Answer_Image_LinksAvgAggregateInputType
    _sum?: Answer_Image_LinksSumAggregateInputType
    _min?: Answer_Image_LinksMinAggregateInputType
    _max?: Answer_Image_LinksMaxAggregateInputType
  }

  export type Answer_Image_LinksGroupByOutputType = {
    id: number
    answersId: number | null
    answer_image_link: string | null
    _count: Answer_Image_LinksCountAggregateOutputType | null
    _avg: Answer_Image_LinksAvgAggregateOutputType | null
    _sum: Answer_Image_LinksSumAggregateOutputType | null
    _min: Answer_Image_LinksMinAggregateOutputType | null
    _max: Answer_Image_LinksMaxAggregateOutputType | null
  }

  type GetAnswer_Image_LinksGroupByPayload<T extends Answer_Image_LinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Answer_Image_LinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Answer_Image_LinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Answer_Image_LinksGroupByOutputType[P]>
            : GetScalarType<T[P], Answer_Image_LinksGroupByOutputType[P]>
        }
      >
    >


  export type Answer_Image_LinksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    answersId?: boolean
    answer_image_link?: boolean
    Answers?: boolean | Answer_Image_Links$AnswersArgs<ExtArgs>
  }, ExtArgs["result"]["answer_Image_Links"]>

  export type Answer_Image_LinksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    answersId?: boolean
    answer_image_link?: boolean
    Answers?: boolean | Answer_Image_Links$AnswersArgs<ExtArgs>
  }, ExtArgs["result"]["answer_Image_Links"]>

  export type Answer_Image_LinksSelectScalar = {
    id?: boolean
    answersId?: boolean
    answer_image_link?: boolean
  }

  export type Answer_Image_LinksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Answers?: boolean | Answer_Image_Links$AnswersArgs<ExtArgs>
  }
  export type Answer_Image_LinksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Answers?: boolean | Answer_Image_Links$AnswersArgs<ExtArgs>
  }

  export type $Answer_Image_LinksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answer_Image_Links"
    objects: {
      Answers: Prisma.$AnswersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      answersId: number | null
      answer_image_link: string | null
    }, ExtArgs["result"]["answer_Image_Links"]>
    composites: {}
  }

  type Answer_Image_LinksGetPayload<S extends boolean | null | undefined | Answer_Image_LinksDefaultArgs> = $Result.GetResult<Prisma.$Answer_Image_LinksPayload, S>

  type Answer_Image_LinksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Answer_Image_LinksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Answer_Image_LinksCountAggregateInputType | true
    }

  export interface Answer_Image_LinksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answer_Image_Links'], meta: { name: 'Answer_Image_Links' } }
    /**
     * Find zero or one Answer_Image_Links that matches the filter.
     * @param {Answer_Image_LinksFindUniqueArgs} args - Arguments to find a Answer_Image_Links
     * @example
     * // Get one Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Answer_Image_LinksFindUniqueArgs>(args: SelectSubset<T, Answer_Image_LinksFindUniqueArgs<ExtArgs>>): Prisma__Answer_Image_LinksClient<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Answer_Image_Links that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Answer_Image_LinksFindUniqueOrThrowArgs} args - Arguments to find a Answer_Image_Links
     * @example
     * // Get one Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Answer_Image_LinksFindUniqueOrThrowArgs>(args: SelectSubset<T, Answer_Image_LinksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Answer_Image_LinksClient<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Answer_Image_Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Answer_Image_LinksFindFirstArgs} args - Arguments to find a Answer_Image_Links
     * @example
     * // Get one Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Answer_Image_LinksFindFirstArgs>(args?: SelectSubset<T, Answer_Image_LinksFindFirstArgs<ExtArgs>>): Prisma__Answer_Image_LinksClient<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Answer_Image_Links that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Answer_Image_LinksFindFirstOrThrowArgs} args - Arguments to find a Answer_Image_Links
     * @example
     * // Get one Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Answer_Image_LinksFindFirstOrThrowArgs>(args?: SelectSubset<T, Answer_Image_LinksFindFirstOrThrowArgs<ExtArgs>>): Prisma__Answer_Image_LinksClient<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Answer_Image_Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Answer_Image_LinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.findMany()
     * 
     * // Get first 10 Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answer_Image_LinksWithIdOnly = await prisma.answer_Image_Links.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Answer_Image_LinksFindManyArgs>(args?: SelectSubset<T, Answer_Image_LinksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Answer_Image_Links.
     * @param {Answer_Image_LinksCreateArgs} args - Arguments to create a Answer_Image_Links.
     * @example
     * // Create one Answer_Image_Links
     * const Answer_Image_Links = await prisma.answer_Image_Links.create({
     *   data: {
     *     // ... data to create a Answer_Image_Links
     *   }
     * })
     * 
     */
    create<T extends Answer_Image_LinksCreateArgs>(args: SelectSubset<T, Answer_Image_LinksCreateArgs<ExtArgs>>): Prisma__Answer_Image_LinksClient<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Answer_Image_Links.
     * @param {Answer_Image_LinksCreateManyArgs} args - Arguments to create many Answer_Image_Links.
     * @example
     * // Create many Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Answer_Image_LinksCreateManyArgs>(args?: SelectSubset<T, Answer_Image_LinksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Answer_Image_Links and returns the data saved in the database.
     * @param {Answer_Image_LinksCreateManyAndReturnArgs} args - Arguments to create many Answer_Image_Links.
     * @example
     * // Create many Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Answer_Image_Links and only return the `id`
     * const answer_Image_LinksWithIdOnly = await prisma.answer_Image_Links.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Answer_Image_LinksCreateManyAndReturnArgs>(args?: SelectSubset<T, Answer_Image_LinksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Answer_Image_Links.
     * @param {Answer_Image_LinksDeleteArgs} args - Arguments to delete one Answer_Image_Links.
     * @example
     * // Delete one Answer_Image_Links
     * const Answer_Image_Links = await prisma.answer_Image_Links.delete({
     *   where: {
     *     // ... filter to delete one Answer_Image_Links
     *   }
     * })
     * 
     */
    delete<T extends Answer_Image_LinksDeleteArgs>(args: SelectSubset<T, Answer_Image_LinksDeleteArgs<ExtArgs>>): Prisma__Answer_Image_LinksClient<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Answer_Image_Links.
     * @param {Answer_Image_LinksUpdateArgs} args - Arguments to update one Answer_Image_Links.
     * @example
     * // Update one Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Answer_Image_LinksUpdateArgs>(args: SelectSubset<T, Answer_Image_LinksUpdateArgs<ExtArgs>>): Prisma__Answer_Image_LinksClient<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Answer_Image_Links.
     * @param {Answer_Image_LinksDeleteManyArgs} args - Arguments to filter Answer_Image_Links to delete.
     * @example
     * // Delete a few Answer_Image_Links
     * const { count } = await prisma.answer_Image_Links.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Answer_Image_LinksDeleteManyArgs>(args?: SelectSubset<T, Answer_Image_LinksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answer_Image_Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Answer_Image_LinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Answer_Image_LinksUpdateManyArgs>(args: SelectSubset<T, Answer_Image_LinksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Answer_Image_Links.
     * @param {Answer_Image_LinksUpsertArgs} args - Arguments to update or create a Answer_Image_Links.
     * @example
     * // Update or create a Answer_Image_Links
     * const answer_Image_Links = await prisma.answer_Image_Links.upsert({
     *   create: {
     *     // ... data to create a Answer_Image_Links
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer_Image_Links we want to update
     *   }
     * })
     */
    upsert<T extends Answer_Image_LinksUpsertArgs>(args: SelectSubset<T, Answer_Image_LinksUpsertArgs<ExtArgs>>): Prisma__Answer_Image_LinksClient<$Result.GetResult<Prisma.$Answer_Image_LinksPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Answer_Image_Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Answer_Image_LinksCountArgs} args - Arguments to filter Answer_Image_Links to count.
     * @example
     * // Count the number of Answer_Image_Links
     * const count = await prisma.answer_Image_Links.count({
     *   where: {
     *     // ... the filter for the Answer_Image_Links we want to count
     *   }
     * })
    **/
    count<T extends Answer_Image_LinksCountArgs>(
      args?: Subset<T, Answer_Image_LinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Answer_Image_LinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer_Image_Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Answer_Image_LinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Answer_Image_LinksAggregateArgs>(args: Subset<T, Answer_Image_LinksAggregateArgs>): Prisma.PrismaPromise<GetAnswer_Image_LinksAggregateType<T>>

    /**
     * Group by Answer_Image_Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Answer_Image_LinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Answer_Image_LinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Answer_Image_LinksGroupByArgs['orderBy'] }
        : { orderBy?: Answer_Image_LinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Answer_Image_LinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswer_Image_LinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answer_Image_Links model
   */
  readonly fields: Answer_Image_LinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer_Image_Links.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Answer_Image_LinksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Answers<T extends Answer_Image_Links$AnswersArgs<ExtArgs> = {}>(args?: Subset<T, Answer_Image_Links$AnswersArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Answer_Image_Links model
   */ 
  interface Answer_Image_LinksFieldRefs {
    readonly id: FieldRef<"Answer_Image_Links", 'Int'>
    readonly answersId: FieldRef<"Answer_Image_Links", 'Int'>
    readonly answer_image_link: FieldRef<"Answer_Image_Links", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Answer_Image_Links findUnique
   */
  export type Answer_Image_LinksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    /**
     * Filter, which Answer_Image_Links to fetch.
     */
    where: Answer_Image_LinksWhereUniqueInput
  }

  /**
   * Answer_Image_Links findUniqueOrThrow
   */
  export type Answer_Image_LinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    /**
     * Filter, which Answer_Image_Links to fetch.
     */
    where: Answer_Image_LinksWhereUniqueInput
  }

  /**
   * Answer_Image_Links findFirst
   */
  export type Answer_Image_LinksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    /**
     * Filter, which Answer_Image_Links to fetch.
     */
    where?: Answer_Image_LinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answer_Image_Links to fetch.
     */
    orderBy?: Answer_Image_LinksOrderByWithRelationInput | Answer_Image_LinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answer_Image_Links.
     */
    cursor?: Answer_Image_LinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answer_Image_Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answer_Image_Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answer_Image_Links.
     */
    distinct?: Answer_Image_LinksScalarFieldEnum | Answer_Image_LinksScalarFieldEnum[]
  }

  /**
   * Answer_Image_Links findFirstOrThrow
   */
  export type Answer_Image_LinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    /**
     * Filter, which Answer_Image_Links to fetch.
     */
    where?: Answer_Image_LinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answer_Image_Links to fetch.
     */
    orderBy?: Answer_Image_LinksOrderByWithRelationInput | Answer_Image_LinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answer_Image_Links.
     */
    cursor?: Answer_Image_LinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answer_Image_Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answer_Image_Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answer_Image_Links.
     */
    distinct?: Answer_Image_LinksScalarFieldEnum | Answer_Image_LinksScalarFieldEnum[]
  }

  /**
   * Answer_Image_Links findMany
   */
  export type Answer_Image_LinksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    /**
     * Filter, which Answer_Image_Links to fetch.
     */
    where?: Answer_Image_LinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answer_Image_Links to fetch.
     */
    orderBy?: Answer_Image_LinksOrderByWithRelationInput | Answer_Image_LinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answer_Image_Links.
     */
    cursor?: Answer_Image_LinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answer_Image_Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answer_Image_Links.
     */
    skip?: number
    distinct?: Answer_Image_LinksScalarFieldEnum | Answer_Image_LinksScalarFieldEnum[]
  }

  /**
   * Answer_Image_Links create
   */
  export type Answer_Image_LinksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    /**
     * The data needed to create a Answer_Image_Links.
     */
    data?: XOR<Answer_Image_LinksCreateInput, Answer_Image_LinksUncheckedCreateInput>
  }

  /**
   * Answer_Image_Links createMany
   */
  export type Answer_Image_LinksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answer_Image_Links.
     */
    data: Answer_Image_LinksCreateManyInput | Answer_Image_LinksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Answer_Image_Links createManyAndReturn
   */
  export type Answer_Image_LinksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Answer_Image_Links.
     */
    data: Answer_Image_LinksCreateManyInput | Answer_Image_LinksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answer_Image_Links update
   */
  export type Answer_Image_LinksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    /**
     * The data needed to update a Answer_Image_Links.
     */
    data: XOR<Answer_Image_LinksUpdateInput, Answer_Image_LinksUncheckedUpdateInput>
    /**
     * Choose, which Answer_Image_Links to update.
     */
    where: Answer_Image_LinksWhereUniqueInput
  }

  /**
   * Answer_Image_Links updateMany
   */
  export type Answer_Image_LinksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answer_Image_Links.
     */
    data: XOR<Answer_Image_LinksUpdateManyMutationInput, Answer_Image_LinksUncheckedUpdateManyInput>
    /**
     * Filter which Answer_Image_Links to update
     */
    where?: Answer_Image_LinksWhereInput
  }

  /**
   * Answer_Image_Links upsert
   */
  export type Answer_Image_LinksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    /**
     * The filter to search for the Answer_Image_Links to update in case it exists.
     */
    where: Answer_Image_LinksWhereUniqueInput
    /**
     * In case the Answer_Image_Links found by the `where` argument doesn't exist, create a new Answer_Image_Links with this data.
     */
    create: XOR<Answer_Image_LinksCreateInput, Answer_Image_LinksUncheckedCreateInput>
    /**
     * In case the Answer_Image_Links was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Answer_Image_LinksUpdateInput, Answer_Image_LinksUncheckedUpdateInput>
  }

  /**
   * Answer_Image_Links delete
   */
  export type Answer_Image_LinksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
    /**
     * Filter which Answer_Image_Links to delete.
     */
    where: Answer_Image_LinksWhereUniqueInput
  }

  /**
   * Answer_Image_Links deleteMany
   */
  export type Answer_Image_LinksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answer_Image_Links to delete
     */
    where?: Answer_Image_LinksWhereInput
  }

  /**
   * Answer_Image_Links.Answers
   */
  export type Answer_Image_Links$AnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    where?: AnswersWhereInput
  }

  /**
   * Answer_Image_Links without action
   */
  export type Answer_Image_LinksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer_Image_Links
     */
    select?: Answer_Image_LinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Answer_Image_LinksInclude<ExtArgs> | null
  }


  /**
   * Model QuestionImageLinks
   */

  export type AggregateQuestionImageLinks = {
    _count: QuestionImageLinksCountAggregateOutputType | null
    _avg: QuestionImageLinksAvgAggregateOutputType | null
    _sum: QuestionImageLinksSumAggregateOutputType | null
    _min: QuestionImageLinksMinAggregateOutputType | null
    _max: QuestionImageLinksMaxAggregateOutputType | null
  }

  export type QuestionImageLinksAvgAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type QuestionImageLinksSumAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type QuestionImageLinksMinAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type QuestionImageLinksMaxAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type QuestionImageLinksCountAggregateOutputType = {
    id: number
    questionsId: number
    _all: number
  }


  export type QuestionImageLinksAvgAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type QuestionImageLinksSumAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type QuestionImageLinksMinAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type QuestionImageLinksMaxAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type QuestionImageLinksCountAggregateInputType = {
    id?: true
    questionsId?: true
    _all?: true
  }

  export type QuestionImageLinksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionImageLinks to aggregate.
     */
    where?: QuestionImageLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionImageLinks to fetch.
     */
    orderBy?: QuestionImageLinksOrderByWithRelationInput | QuestionImageLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionImageLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionImageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionImageLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionImageLinks
    **/
    _count?: true | QuestionImageLinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionImageLinksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionImageLinksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionImageLinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionImageLinksMaxAggregateInputType
  }

  export type GetQuestionImageLinksAggregateType<T extends QuestionImageLinksAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionImageLinks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionImageLinks[P]>
      : GetScalarType<T[P], AggregateQuestionImageLinks[P]>
  }




  export type QuestionImageLinksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionImageLinksWhereInput
    orderBy?: QuestionImageLinksOrderByWithAggregationInput | QuestionImageLinksOrderByWithAggregationInput[]
    by: QuestionImageLinksScalarFieldEnum[] | QuestionImageLinksScalarFieldEnum
    having?: QuestionImageLinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionImageLinksCountAggregateInputType | true
    _avg?: QuestionImageLinksAvgAggregateInputType
    _sum?: QuestionImageLinksSumAggregateInputType
    _min?: QuestionImageLinksMinAggregateInputType
    _max?: QuestionImageLinksMaxAggregateInputType
  }

  export type QuestionImageLinksGroupByOutputType = {
    id: number
    questionsId: number | null
    _count: QuestionImageLinksCountAggregateOutputType | null
    _avg: QuestionImageLinksAvgAggregateOutputType | null
    _sum: QuestionImageLinksSumAggregateOutputType | null
    _min: QuestionImageLinksMinAggregateOutputType | null
    _max: QuestionImageLinksMaxAggregateOutputType | null
  }

  type GetQuestionImageLinksGroupByPayload<T extends QuestionImageLinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionImageLinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionImageLinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionImageLinksGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionImageLinksGroupByOutputType[P]>
        }
      >
    >


  export type QuestionImageLinksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    Questions?: boolean | QuestionImageLinks$QuestionsArgs<ExtArgs>
  }, ExtArgs["result"]["questionImageLinks"]>

  export type QuestionImageLinksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    Questions?: boolean | QuestionImageLinks$QuestionsArgs<ExtArgs>
  }, ExtArgs["result"]["questionImageLinks"]>

  export type QuestionImageLinksSelectScalar = {
    id?: boolean
    questionsId?: boolean
  }

  export type QuestionImageLinksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | QuestionImageLinks$QuestionsArgs<ExtArgs>
  }
  export type QuestionImageLinksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | QuestionImageLinks$QuestionsArgs<ExtArgs>
  }

  export type $QuestionImageLinksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionImageLinks"
    objects: {
      Questions: Prisma.$QuestionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionsId: number | null
    }, ExtArgs["result"]["questionImageLinks"]>
    composites: {}
  }

  type QuestionImageLinksGetPayload<S extends boolean | null | undefined | QuestionImageLinksDefaultArgs> = $Result.GetResult<Prisma.$QuestionImageLinksPayload, S>

  type QuestionImageLinksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionImageLinksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionImageLinksCountAggregateInputType | true
    }

  export interface QuestionImageLinksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionImageLinks'], meta: { name: 'QuestionImageLinks' } }
    /**
     * Find zero or one QuestionImageLinks that matches the filter.
     * @param {QuestionImageLinksFindUniqueArgs} args - Arguments to find a QuestionImageLinks
     * @example
     * // Get one QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionImageLinksFindUniqueArgs>(args: SelectSubset<T, QuestionImageLinksFindUniqueArgs<ExtArgs>>): Prisma__QuestionImageLinksClient<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionImageLinks that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionImageLinksFindUniqueOrThrowArgs} args - Arguments to find a QuestionImageLinks
     * @example
     * // Get one QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionImageLinksFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionImageLinksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionImageLinksClient<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionImageLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageLinksFindFirstArgs} args - Arguments to find a QuestionImageLinks
     * @example
     * // Get one QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionImageLinksFindFirstArgs>(args?: SelectSubset<T, QuestionImageLinksFindFirstArgs<ExtArgs>>): Prisma__QuestionImageLinksClient<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionImageLinks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageLinksFindFirstOrThrowArgs} args - Arguments to find a QuestionImageLinks
     * @example
     * // Get one QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionImageLinksFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionImageLinksFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionImageLinksClient<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionImageLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageLinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.findMany()
     * 
     * // Get first 10 QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionImageLinksWithIdOnly = await prisma.questionImageLinks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionImageLinksFindManyArgs>(args?: SelectSubset<T, QuestionImageLinksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionImageLinks.
     * @param {QuestionImageLinksCreateArgs} args - Arguments to create a QuestionImageLinks.
     * @example
     * // Create one QuestionImageLinks
     * const QuestionImageLinks = await prisma.questionImageLinks.create({
     *   data: {
     *     // ... data to create a QuestionImageLinks
     *   }
     * })
     * 
     */
    create<T extends QuestionImageLinksCreateArgs>(args: SelectSubset<T, QuestionImageLinksCreateArgs<ExtArgs>>): Prisma__QuestionImageLinksClient<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionImageLinks.
     * @param {QuestionImageLinksCreateManyArgs} args - Arguments to create many QuestionImageLinks.
     * @example
     * // Create many QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionImageLinksCreateManyArgs>(args?: SelectSubset<T, QuestionImageLinksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionImageLinks and returns the data saved in the database.
     * @param {QuestionImageLinksCreateManyAndReturnArgs} args - Arguments to create many QuestionImageLinks.
     * @example
     * // Create many QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionImageLinks and only return the `id`
     * const questionImageLinksWithIdOnly = await prisma.questionImageLinks.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionImageLinksCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionImageLinksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuestionImageLinks.
     * @param {QuestionImageLinksDeleteArgs} args - Arguments to delete one QuestionImageLinks.
     * @example
     * // Delete one QuestionImageLinks
     * const QuestionImageLinks = await prisma.questionImageLinks.delete({
     *   where: {
     *     // ... filter to delete one QuestionImageLinks
     *   }
     * })
     * 
     */
    delete<T extends QuestionImageLinksDeleteArgs>(args: SelectSubset<T, QuestionImageLinksDeleteArgs<ExtArgs>>): Prisma__QuestionImageLinksClient<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionImageLinks.
     * @param {QuestionImageLinksUpdateArgs} args - Arguments to update one QuestionImageLinks.
     * @example
     * // Update one QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionImageLinksUpdateArgs>(args: SelectSubset<T, QuestionImageLinksUpdateArgs<ExtArgs>>): Prisma__QuestionImageLinksClient<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionImageLinks.
     * @param {QuestionImageLinksDeleteManyArgs} args - Arguments to filter QuestionImageLinks to delete.
     * @example
     * // Delete a few QuestionImageLinks
     * const { count } = await prisma.questionImageLinks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionImageLinksDeleteManyArgs>(args?: SelectSubset<T, QuestionImageLinksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionImageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageLinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionImageLinksUpdateManyArgs>(args: SelectSubset<T, QuestionImageLinksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionImageLinks.
     * @param {QuestionImageLinksUpsertArgs} args - Arguments to update or create a QuestionImageLinks.
     * @example
     * // Update or create a QuestionImageLinks
     * const questionImageLinks = await prisma.questionImageLinks.upsert({
     *   create: {
     *     // ... data to create a QuestionImageLinks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionImageLinks we want to update
     *   }
     * })
     */
    upsert<T extends QuestionImageLinksUpsertArgs>(args: SelectSubset<T, QuestionImageLinksUpsertArgs<ExtArgs>>): Prisma__QuestionImageLinksClient<$Result.GetResult<Prisma.$QuestionImageLinksPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionImageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageLinksCountArgs} args - Arguments to filter QuestionImageLinks to count.
     * @example
     * // Count the number of QuestionImageLinks
     * const count = await prisma.questionImageLinks.count({
     *   where: {
     *     // ... the filter for the QuestionImageLinks we want to count
     *   }
     * })
    **/
    count<T extends QuestionImageLinksCountArgs>(
      args?: Subset<T, QuestionImageLinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionImageLinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionImageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageLinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionImageLinksAggregateArgs>(args: Subset<T, QuestionImageLinksAggregateArgs>): Prisma.PrismaPromise<GetQuestionImageLinksAggregateType<T>>

    /**
     * Group by QuestionImageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageLinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionImageLinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionImageLinksGroupByArgs['orderBy'] }
        : { orderBy?: QuestionImageLinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionImageLinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionImageLinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionImageLinks model
   */
  readonly fields: QuestionImageLinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionImageLinks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionImageLinksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Questions<T extends QuestionImageLinks$QuestionsArgs<ExtArgs> = {}>(args?: Subset<T, QuestionImageLinks$QuestionsArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionImageLinks model
   */ 
  interface QuestionImageLinksFieldRefs {
    readonly id: FieldRef<"QuestionImageLinks", 'Int'>
    readonly questionsId: FieldRef<"QuestionImageLinks", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuestionImageLinks findUnique
   */
  export type QuestionImageLinksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImageLinks to fetch.
     */
    where: QuestionImageLinksWhereUniqueInput
  }

  /**
   * QuestionImageLinks findUniqueOrThrow
   */
  export type QuestionImageLinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImageLinks to fetch.
     */
    where: QuestionImageLinksWhereUniqueInput
  }

  /**
   * QuestionImageLinks findFirst
   */
  export type QuestionImageLinksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImageLinks to fetch.
     */
    where?: QuestionImageLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionImageLinks to fetch.
     */
    orderBy?: QuestionImageLinksOrderByWithRelationInput | QuestionImageLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionImageLinks.
     */
    cursor?: QuestionImageLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionImageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionImageLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionImageLinks.
     */
    distinct?: QuestionImageLinksScalarFieldEnum | QuestionImageLinksScalarFieldEnum[]
  }

  /**
   * QuestionImageLinks findFirstOrThrow
   */
  export type QuestionImageLinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImageLinks to fetch.
     */
    where?: QuestionImageLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionImageLinks to fetch.
     */
    orderBy?: QuestionImageLinksOrderByWithRelationInput | QuestionImageLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionImageLinks.
     */
    cursor?: QuestionImageLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionImageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionImageLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionImageLinks.
     */
    distinct?: QuestionImageLinksScalarFieldEnum | QuestionImageLinksScalarFieldEnum[]
  }

  /**
   * QuestionImageLinks findMany
   */
  export type QuestionImageLinksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImageLinks to fetch.
     */
    where?: QuestionImageLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionImageLinks to fetch.
     */
    orderBy?: QuestionImageLinksOrderByWithRelationInput | QuestionImageLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionImageLinks.
     */
    cursor?: QuestionImageLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionImageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionImageLinks.
     */
    skip?: number
    distinct?: QuestionImageLinksScalarFieldEnum | QuestionImageLinksScalarFieldEnum[]
  }

  /**
   * QuestionImageLinks create
   */
  export type QuestionImageLinksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionImageLinks.
     */
    data?: XOR<QuestionImageLinksCreateInput, QuestionImageLinksUncheckedCreateInput>
  }

  /**
   * QuestionImageLinks createMany
   */
  export type QuestionImageLinksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionImageLinks.
     */
    data: QuestionImageLinksCreateManyInput | QuestionImageLinksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionImageLinks createManyAndReturn
   */
  export type QuestionImageLinksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuestionImageLinks.
     */
    data: QuestionImageLinksCreateManyInput | QuestionImageLinksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionImageLinks update
   */
  export type QuestionImageLinksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionImageLinks.
     */
    data: XOR<QuestionImageLinksUpdateInput, QuestionImageLinksUncheckedUpdateInput>
    /**
     * Choose, which QuestionImageLinks to update.
     */
    where: QuestionImageLinksWhereUniqueInput
  }

  /**
   * QuestionImageLinks updateMany
   */
  export type QuestionImageLinksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionImageLinks.
     */
    data: XOR<QuestionImageLinksUpdateManyMutationInput, QuestionImageLinksUncheckedUpdateManyInput>
    /**
     * Filter which QuestionImageLinks to update
     */
    where?: QuestionImageLinksWhereInput
  }

  /**
   * QuestionImageLinks upsert
   */
  export type QuestionImageLinksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionImageLinks to update in case it exists.
     */
    where: QuestionImageLinksWhereUniqueInput
    /**
     * In case the QuestionImageLinks found by the `where` argument doesn't exist, create a new QuestionImageLinks with this data.
     */
    create: XOR<QuestionImageLinksCreateInput, QuestionImageLinksUncheckedCreateInput>
    /**
     * In case the QuestionImageLinks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionImageLinksUpdateInput, QuestionImageLinksUncheckedUpdateInput>
  }

  /**
   * QuestionImageLinks delete
   */
  export type QuestionImageLinksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
    /**
     * Filter which QuestionImageLinks to delete.
     */
    where: QuestionImageLinksWhereUniqueInput
  }

  /**
   * QuestionImageLinks deleteMany
   */
  export type QuestionImageLinksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionImageLinks to delete
     */
    where?: QuestionImageLinksWhereInput
  }

  /**
   * QuestionImageLinks.Questions
   */
  export type QuestionImageLinks$QuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    where?: QuestionsWhereInput
  }

  /**
   * QuestionImageLinks without action
   */
  export type QuestionImageLinksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImageLinks
     */
    select?: QuestionImageLinksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageLinksInclude<ExtArgs> | null
  }


  /**
   * Model Insightful
   */

  export type AggregateInsightful = {
    _count: InsightfulCountAggregateOutputType | null
    _avg: InsightfulAvgAggregateOutputType | null
    _sum: InsightfulSumAggregateOutputType | null
    _min: InsightfulMinAggregateOutputType | null
    _max: InsightfulMaxAggregateOutputType | null
  }

  export type InsightfulAvgAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type InsightfulSumAggregateOutputType = {
    id: number | null
    questionsId: number | null
  }

  export type InsightfulMinAggregateOutputType = {
    id: number | null
    questionsId: number | null
    insightful_user_id: string | null
  }

  export type InsightfulMaxAggregateOutputType = {
    id: number | null
    questionsId: number | null
    insightful_user_id: string | null
  }

  export type InsightfulCountAggregateOutputType = {
    id: number
    questionsId: number
    insightful_user_id: number
    _all: number
  }


  export type InsightfulAvgAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type InsightfulSumAggregateInputType = {
    id?: true
    questionsId?: true
  }

  export type InsightfulMinAggregateInputType = {
    id?: true
    questionsId?: true
    insightful_user_id?: true
  }

  export type InsightfulMaxAggregateInputType = {
    id?: true
    questionsId?: true
    insightful_user_id?: true
  }

  export type InsightfulCountAggregateInputType = {
    id?: true
    questionsId?: true
    insightful_user_id?: true
    _all?: true
  }

  export type InsightfulAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insightful to aggregate.
     */
    where?: InsightfulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insightfuls to fetch.
     */
    orderBy?: InsightfulOrderByWithRelationInput | InsightfulOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightfulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insightfuls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insightfuls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Insightfuls
    **/
    _count?: true | InsightfulCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsightfulAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsightfulSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightfulMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightfulMaxAggregateInputType
  }

  export type GetInsightfulAggregateType<T extends InsightfulAggregateArgs> = {
        [P in keyof T & keyof AggregateInsightful]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsightful[P]>
      : GetScalarType<T[P], AggregateInsightful[P]>
  }




  export type InsightfulGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightfulWhereInput
    orderBy?: InsightfulOrderByWithAggregationInput | InsightfulOrderByWithAggregationInput[]
    by: InsightfulScalarFieldEnum[] | InsightfulScalarFieldEnum
    having?: InsightfulScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightfulCountAggregateInputType | true
    _avg?: InsightfulAvgAggregateInputType
    _sum?: InsightfulSumAggregateInputType
    _min?: InsightfulMinAggregateInputType
    _max?: InsightfulMaxAggregateInputType
  }

  export type InsightfulGroupByOutputType = {
    id: number
    questionsId: number | null
    insightful_user_id: string | null
    _count: InsightfulCountAggregateOutputType | null
    _avg: InsightfulAvgAggregateOutputType | null
    _sum: InsightfulSumAggregateOutputType | null
    _min: InsightfulMinAggregateOutputType | null
    _max: InsightfulMaxAggregateOutputType | null
  }

  type GetInsightfulGroupByPayload<T extends InsightfulGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightfulGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightfulGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightfulGroupByOutputType[P]>
            : GetScalarType<T[P], InsightfulGroupByOutputType[P]>
        }
      >
    >


  export type InsightfulSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    insightful_user_id?: boolean
    Questions?: boolean | Insightful$QuestionsArgs<ExtArgs>
  }, ExtArgs["result"]["insightful"]>

  export type InsightfulSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionsId?: boolean
    insightful_user_id?: boolean
    Questions?: boolean | Insightful$QuestionsArgs<ExtArgs>
  }, ExtArgs["result"]["insightful"]>

  export type InsightfulSelectScalar = {
    id?: boolean
    questionsId?: boolean
    insightful_user_id?: boolean
  }

  export type InsightfulInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | Insightful$QuestionsArgs<ExtArgs>
  }
  export type InsightfulIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | Insightful$QuestionsArgs<ExtArgs>
  }

  export type $InsightfulPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Insightful"
    objects: {
      Questions: Prisma.$QuestionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionsId: number | null
      insightful_user_id: string | null
    }, ExtArgs["result"]["insightful"]>
    composites: {}
  }

  type InsightfulGetPayload<S extends boolean | null | undefined | InsightfulDefaultArgs> = $Result.GetResult<Prisma.$InsightfulPayload, S>

  type InsightfulCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsightfulFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsightfulCountAggregateInputType | true
    }

  export interface InsightfulDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Insightful'], meta: { name: 'Insightful' } }
    /**
     * Find zero or one Insightful that matches the filter.
     * @param {InsightfulFindUniqueArgs} args - Arguments to find a Insightful
     * @example
     * // Get one Insightful
     * const insightful = await prisma.insightful.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightfulFindUniqueArgs>(args: SelectSubset<T, InsightfulFindUniqueArgs<ExtArgs>>): Prisma__InsightfulClient<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Insightful that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsightfulFindUniqueOrThrowArgs} args - Arguments to find a Insightful
     * @example
     * // Get one Insightful
     * const insightful = await prisma.insightful.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightfulFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightfulFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightfulClient<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Insightful that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightfulFindFirstArgs} args - Arguments to find a Insightful
     * @example
     * // Get one Insightful
     * const insightful = await prisma.insightful.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightfulFindFirstArgs>(args?: SelectSubset<T, InsightfulFindFirstArgs<ExtArgs>>): Prisma__InsightfulClient<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Insightful that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightfulFindFirstOrThrowArgs} args - Arguments to find a Insightful
     * @example
     * // Get one Insightful
     * const insightful = await prisma.insightful.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightfulFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightfulFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightfulClient<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Insightfuls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightfulFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insightfuls
     * const insightfuls = await prisma.insightful.findMany()
     * 
     * // Get first 10 Insightfuls
     * const insightfuls = await prisma.insightful.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightfulWithIdOnly = await prisma.insightful.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightfulFindManyArgs>(args?: SelectSubset<T, InsightfulFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Insightful.
     * @param {InsightfulCreateArgs} args - Arguments to create a Insightful.
     * @example
     * // Create one Insightful
     * const Insightful = await prisma.insightful.create({
     *   data: {
     *     // ... data to create a Insightful
     *   }
     * })
     * 
     */
    create<T extends InsightfulCreateArgs>(args: SelectSubset<T, InsightfulCreateArgs<ExtArgs>>): Prisma__InsightfulClient<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Insightfuls.
     * @param {InsightfulCreateManyArgs} args - Arguments to create many Insightfuls.
     * @example
     * // Create many Insightfuls
     * const insightful = await prisma.insightful.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightfulCreateManyArgs>(args?: SelectSubset<T, InsightfulCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Insightfuls and returns the data saved in the database.
     * @param {InsightfulCreateManyAndReturnArgs} args - Arguments to create many Insightfuls.
     * @example
     * // Create many Insightfuls
     * const insightful = await prisma.insightful.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Insightfuls and only return the `id`
     * const insightfulWithIdOnly = await prisma.insightful.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightfulCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightfulCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Insightful.
     * @param {InsightfulDeleteArgs} args - Arguments to delete one Insightful.
     * @example
     * // Delete one Insightful
     * const Insightful = await prisma.insightful.delete({
     *   where: {
     *     // ... filter to delete one Insightful
     *   }
     * })
     * 
     */
    delete<T extends InsightfulDeleteArgs>(args: SelectSubset<T, InsightfulDeleteArgs<ExtArgs>>): Prisma__InsightfulClient<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Insightful.
     * @param {InsightfulUpdateArgs} args - Arguments to update one Insightful.
     * @example
     * // Update one Insightful
     * const insightful = await prisma.insightful.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightfulUpdateArgs>(args: SelectSubset<T, InsightfulUpdateArgs<ExtArgs>>): Prisma__InsightfulClient<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Insightfuls.
     * @param {InsightfulDeleteManyArgs} args - Arguments to filter Insightfuls to delete.
     * @example
     * // Delete a few Insightfuls
     * const { count } = await prisma.insightful.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightfulDeleteManyArgs>(args?: SelectSubset<T, InsightfulDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insightfuls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightfulUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insightfuls
     * const insightful = await prisma.insightful.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightfulUpdateManyArgs>(args: SelectSubset<T, InsightfulUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Insightful.
     * @param {InsightfulUpsertArgs} args - Arguments to update or create a Insightful.
     * @example
     * // Update or create a Insightful
     * const insightful = await prisma.insightful.upsert({
     *   create: {
     *     // ... data to create a Insightful
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insightful we want to update
     *   }
     * })
     */
    upsert<T extends InsightfulUpsertArgs>(args: SelectSubset<T, InsightfulUpsertArgs<ExtArgs>>): Prisma__InsightfulClient<$Result.GetResult<Prisma.$InsightfulPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Insightfuls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightfulCountArgs} args - Arguments to filter Insightfuls to count.
     * @example
     * // Count the number of Insightfuls
     * const count = await prisma.insightful.count({
     *   where: {
     *     // ... the filter for the Insightfuls we want to count
     *   }
     * })
    **/
    count<T extends InsightfulCountArgs>(
      args?: Subset<T, InsightfulCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightfulCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insightful.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightfulAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightfulAggregateArgs>(args: Subset<T, InsightfulAggregateArgs>): Prisma.PrismaPromise<GetInsightfulAggregateType<T>>

    /**
     * Group by Insightful.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightfulGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightfulGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightfulGroupByArgs['orderBy'] }
        : { orderBy?: InsightfulGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightfulGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightfulGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Insightful model
   */
  readonly fields: InsightfulFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Insightful.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightfulClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Questions<T extends Insightful$QuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Insightful$QuestionsArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Insightful model
   */ 
  interface InsightfulFieldRefs {
    readonly id: FieldRef<"Insightful", 'Int'>
    readonly questionsId: FieldRef<"Insightful", 'Int'>
    readonly insightful_user_id: FieldRef<"Insightful", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Insightful findUnique
   */
  export type InsightfulFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    /**
     * Filter, which Insightful to fetch.
     */
    where: InsightfulWhereUniqueInput
  }

  /**
   * Insightful findUniqueOrThrow
   */
  export type InsightfulFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    /**
     * Filter, which Insightful to fetch.
     */
    where: InsightfulWhereUniqueInput
  }

  /**
   * Insightful findFirst
   */
  export type InsightfulFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    /**
     * Filter, which Insightful to fetch.
     */
    where?: InsightfulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insightfuls to fetch.
     */
    orderBy?: InsightfulOrderByWithRelationInput | InsightfulOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insightfuls.
     */
    cursor?: InsightfulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insightfuls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insightfuls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insightfuls.
     */
    distinct?: InsightfulScalarFieldEnum | InsightfulScalarFieldEnum[]
  }

  /**
   * Insightful findFirstOrThrow
   */
  export type InsightfulFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    /**
     * Filter, which Insightful to fetch.
     */
    where?: InsightfulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insightfuls to fetch.
     */
    orderBy?: InsightfulOrderByWithRelationInput | InsightfulOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insightfuls.
     */
    cursor?: InsightfulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insightfuls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insightfuls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insightfuls.
     */
    distinct?: InsightfulScalarFieldEnum | InsightfulScalarFieldEnum[]
  }

  /**
   * Insightful findMany
   */
  export type InsightfulFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    /**
     * Filter, which Insightfuls to fetch.
     */
    where?: InsightfulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insightfuls to fetch.
     */
    orderBy?: InsightfulOrderByWithRelationInput | InsightfulOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Insightfuls.
     */
    cursor?: InsightfulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insightfuls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insightfuls.
     */
    skip?: number
    distinct?: InsightfulScalarFieldEnum | InsightfulScalarFieldEnum[]
  }

  /**
   * Insightful create
   */
  export type InsightfulCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    /**
     * The data needed to create a Insightful.
     */
    data?: XOR<InsightfulCreateInput, InsightfulUncheckedCreateInput>
  }

  /**
   * Insightful createMany
   */
  export type InsightfulCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Insightfuls.
     */
    data: InsightfulCreateManyInput | InsightfulCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Insightful createManyAndReturn
   */
  export type InsightfulCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Insightfuls.
     */
    data: InsightfulCreateManyInput | InsightfulCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Insightful update
   */
  export type InsightfulUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    /**
     * The data needed to update a Insightful.
     */
    data: XOR<InsightfulUpdateInput, InsightfulUncheckedUpdateInput>
    /**
     * Choose, which Insightful to update.
     */
    where: InsightfulWhereUniqueInput
  }

  /**
   * Insightful updateMany
   */
  export type InsightfulUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Insightfuls.
     */
    data: XOR<InsightfulUpdateManyMutationInput, InsightfulUncheckedUpdateManyInput>
    /**
     * Filter which Insightfuls to update
     */
    where?: InsightfulWhereInput
  }

  /**
   * Insightful upsert
   */
  export type InsightfulUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    /**
     * The filter to search for the Insightful to update in case it exists.
     */
    where: InsightfulWhereUniqueInput
    /**
     * In case the Insightful found by the `where` argument doesn't exist, create a new Insightful with this data.
     */
    create: XOR<InsightfulCreateInput, InsightfulUncheckedCreateInput>
    /**
     * In case the Insightful was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightfulUpdateInput, InsightfulUncheckedUpdateInput>
  }

  /**
   * Insightful delete
   */
  export type InsightfulDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
    /**
     * Filter which Insightful to delete.
     */
    where: InsightfulWhereUniqueInput
  }

  /**
   * Insightful deleteMany
   */
  export type InsightfulDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insightfuls to delete
     */
    where?: InsightfulWhereInput
  }

  /**
   * Insightful.Questions
   */
  export type Insightful$QuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    where?: QuestionsWhereInput
  }

  /**
   * Insightful without action
   */
  export type InsightfulDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insightful
     */
    select?: InsightfulSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightfulInclude<ExtArgs> | null
  }


  /**
   * Model Friends
   */

  export type AggregateFriends = {
    _count: FriendsCountAggregateOutputType | null
    _avg: FriendsAvgAggregateOutputType | null
    _sum: FriendsSumAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  export type FriendsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FriendsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FriendsMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FriendsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FriendsCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type FriendsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FriendsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FriendsMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FriendsMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FriendsCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type FriendsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friends to aggregate.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friends
    **/
    _count?: true | FriendsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FriendsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FriendsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendsMaxAggregateInputType
  }

  export type GetFriendsAggregateType<T extends FriendsAggregateArgs> = {
        [P in keyof T & keyof AggregateFriends]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriends[P]>
      : GetScalarType<T[P], AggregateFriends[P]>
  }




  export type FriendsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithAggregationInput | FriendsOrderByWithAggregationInput[]
    by: FriendsScalarFieldEnum[] | FriendsScalarFieldEnum
    having?: FriendsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendsCountAggregateInputType | true
    _avg?: FriendsAvgAggregateInputType
    _sum?: FriendsSumAggregateInputType
    _min?: FriendsMinAggregateInputType
    _max?: FriendsMaxAggregateInputType
  }

  export type FriendsGroupByOutputType = {
    id: number
    userId: number | null
    _count: FriendsCountAggregateOutputType | null
    _avg: FriendsAvgAggregateOutputType | null
    _sum: FriendsSumAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  type GetFriendsGroupByPayload<T extends FriendsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendsGroupByOutputType[P]>
            : GetScalarType<T[P], FriendsGroupByOutputType[P]>
        }
      >
    >


  export type FriendsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    User?: boolean | Friends$UserArgs<ExtArgs>
  }, ExtArgs["result"]["friends"]>

  export type FriendsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    User?: boolean | Friends$UserArgs<ExtArgs>
  }, ExtArgs["result"]["friends"]>

  export type FriendsSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type FriendsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Friends$UserArgs<ExtArgs>
  }
  export type FriendsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Friends$UserArgs<ExtArgs>
  }

  export type $FriendsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friends"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
    }, ExtArgs["result"]["friends"]>
    composites: {}
  }

  type FriendsGetPayload<S extends boolean | null | undefined | FriendsDefaultArgs> = $Result.GetResult<Prisma.$FriendsPayload, S>

  type FriendsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FriendsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendsCountAggregateInputType | true
    }

  export interface FriendsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friends'], meta: { name: 'Friends' } }
    /**
     * Find zero or one Friends that matches the filter.
     * @param {FriendsFindUniqueArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendsFindUniqueArgs>(args: SelectSubset<T, FriendsFindUniqueArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Friends that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FriendsFindUniqueOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendsFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindFirstArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendsFindFirstArgs>(args?: SelectSubset<T, FriendsFindFirstArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Friends that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindFirstOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendsFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friends
     * const friends = await prisma.friends.findMany()
     * 
     * // Get first 10 Friends
     * const friends = await prisma.friends.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendsWithIdOnly = await prisma.friends.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendsFindManyArgs>(args?: SelectSubset<T, FriendsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Friends.
     * @param {FriendsCreateArgs} args - Arguments to create a Friends.
     * @example
     * // Create one Friends
     * const Friends = await prisma.friends.create({
     *   data: {
     *     // ... data to create a Friends
     *   }
     * })
     * 
     */
    create<T extends FriendsCreateArgs>(args: SelectSubset<T, FriendsCreateArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Friends.
     * @param {FriendsCreateManyArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friends = await prisma.friends.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendsCreateManyArgs>(args?: SelectSubset<T, FriendsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friends and returns the data saved in the database.
     * @param {FriendsCreateManyAndReturnArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friends = await prisma.friends.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friends and only return the `id`
     * const friendsWithIdOnly = await prisma.friends.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendsCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Friends.
     * @param {FriendsDeleteArgs} args - Arguments to delete one Friends.
     * @example
     * // Delete one Friends
     * const Friends = await prisma.friends.delete({
     *   where: {
     *     // ... filter to delete one Friends
     *   }
     * })
     * 
     */
    delete<T extends FriendsDeleteArgs>(args: SelectSubset<T, FriendsDeleteArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Friends.
     * @param {FriendsUpdateArgs} args - Arguments to update one Friends.
     * @example
     * // Update one Friends
     * const friends = await prisma.friends.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendsUpdateArgs>(args: SelectSubset<T, FriendsUpdateArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Friends.
     * @param {FriendsDeleteManyArgs} args - Arguments to filter Friends to delete.
     * @example
     * // Delete a few Friends
     * const { count } = await prisma.friends.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendsDeleteManyArgs>(args?: SelectSubset<T, FriendsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friends
     * const friends = await prisma.friends.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendsUpdateManyArgs>(args: SelectSubset<T, FriendsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friends.
     * @param {FriendsUpsertArgs} args - Arguments to update or create a Friends.
     * @example
     * // Update or create a Friends
     * const friends = await prisma.friends.upsert({
     *   create: {
     *     // ... data to create a Friends
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friends we want to update
     *   }
     * })
     */
    upsert<T extends FriendsUpsertArgs>(args: SelectSubset<T, FriendsUpsertArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsCountArgs} args - Arguments to filter Friends to count.
     * @example
     * // Count the number of Friends
     * const count = await prisma.friends.count({
     *   where: {
     *     // ... the filter for the Friends we want to count
     *   }
     * })
    **/
    count<T extends FriendsCountArgs>(
      args?: Subset<T, FriendsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendsAggregateArgs>(args: Subset<T, FriendsAggregateArgs>): Prisma.PrismaPromise<GetFriendsAggregateType<T>>

    /**
     * Group by Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendsGroupByArgs['orderBy'] }
        : { orderBy?: FriendsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friends model
   */
  readonly fields: FriendsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friends.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Friends$UserArgs<ExtArgs> = {}>(args?: Subset<T, Friends$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friends model
   */ 
  interface FriendsFieldRefs {
    readonly id: FieldRef<"Friends", 'Int'>
    readonly userId: FieldRef<"Friends", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Friends findUnique
   */
  export type FriendsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends findUniqueOrThrow
   */
  export type FriendsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends findFirst
   */
  export type FriendsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends findFirstOrThrow
   */
  export type FriendsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends findMany
   */
  export type FriendsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends create
   */
  export type FriendsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The data needed to create a Friends.
     */
    data?: XOR<FriendsCreateInput, FriendsUncheckedCreateInput>
  }

  /**
   * Friends createMany
   */
  export type FriendsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friends.
     */
    data: FriendsCreateManyInput | FriendsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friends createManyAndReturn
   */
  export type FriendsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Friends.
     */
    data: FriendsCreateManyInput | FriendsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friends update
   */
  export type FriendsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The data needed to update a Friends.
     */
    data: XOR<FriendsUpdateInput, FriendsUncheckedUpdateInput>
    /**
     * Choose, which Friends to update.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends updateMany
   */
  export type FriendsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friends.
     */
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyInput>
    /**
     * Filter which Friends to update
     */
    where?: FriendsWhereInput
  }

  /**
   * Friends upsert
   */
  export type FriendsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The filter to search for the Friends to update in case it exists.
     */
    where: FriendsWhereUniqueInput
    /**
     * In case the Friends found by the `where` argument doesn't exist, create a new Friends with this data.
     */
    create: XOR<FriendsCreateInput, FriendsUncheckedCreateInput>
    /**
     * In case the Friends was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendsUpdateInput, FriendsUncheckedUpdateInput>
  }

  /**
   * Friends delete
   */
  export type FriendsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter which Friends to delete.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends deleteMany
   */
  export type FriendsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friends to delete
     */
    where?: FriendsWhereInput
  }

  /**
   * Friends.User
   */
  export type Friends$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Friends without action
   */
  export type FriendsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
  }


  /**
   * Model Certifications
   */

  export type AggregateCertifications = {
    _count: CertificationsCountAggregateOutputType | null
    _avg: CertificationsAvgAggregateOutputType | null
    _sum: CertificationsSumAggregateOutputType | null
    _min: CertificationsMinAggregateOutputType | null
    _max: CertificationsMaxAggregateOutputType | null
  }

  export type CertificationsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CertificationsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CertificationsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    certificateName: string | null
    issuingOrganisation: string | null
    issueDate: string | null
    descreption: string | null
    certificateURL: string | null
    certificateMediaLink: string | null
  }

  export type CertificationsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    certificateName: string | null
    issuingOrganisation: string | null
    issueDate: string | null
    descreption: string | null
    certificateURL: string | null
    certificateMediaLink: string | null
  }

  export type CertificationsCountAggregateOutputType = {
    id: number
    userId: number
    certificateName: number
    issuingOrganisation: number
    issueDate: number
    descreption: number
    certificateURL: number
    certificateMediaLink: number
    _all: number
  }


  export type CertificationsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CertificationsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CertificationsMinAggregateInputType = {
    id?: true
    userId?: true
    certificateName?: true
    issuingOrganisation?: true
    issueDate?: true
    descreption?: true
    certificateURL?: true
    certificateMediaLink?: true
  }

  export type CertificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    certificateName?: true
    issuingOrganisation?: true
    issueDate?: true
    descreption?: true
    certificateURL?: true
    certificateMediaLink?: true
  }

  export type CertificationsCountAggregateInputType = {
    id?: true
    userId?: true
    certificateName?: true
    issuingOrganisation?: true
    issueDate?: true
    descreption?: true
    certificateURL?: true
    certificateMediaLink?: true
    _all?: true
  }

  export type CertificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certifications to aggregate.
     */
    where?: CertificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationsOrderByWithRelationInput | CertificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certifications
    **/
    _count?: true | CertificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationsMaxAggregateInputType
  }

  export type GetCertificationsAggregateType<T extends CertificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCertifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertifications[P]>
      : GetScalarType<T[P], AggregateCertifications[P]>
  }




  export type CertificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationsWhereInput
    orderBy?: CertificationsOrderByWithAggregationInput | CertificationsOrderByWithAggregationInput[]
    by: CertificationsScalarFieldEnum[] | CertificationsScalarFieldEnum
    having?: CertificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationsCountAggregateInputType | true
    _avg?: CertificationsAvgAggregateInputType
    _sum?: CertificationsSumAggregateInputType
    _min?: CertificationsMinAggregateInputType
    _max?: CertificationsMaxAggregateInputType
  }

  export type CertificationsGroupByOutputType = {
    id: number
    userId: number | null
    certificateName: string | null
    issuingOrganisation: string | null
    issueDate: string | null
    descreption: string | null
    certificateURL: string | null
    certificateMediaLink: string | null
    _count: CertificationsCountAggregateOutputType | null
    _avg: CertificationsAvgAggregateOutputType | null
    _sum: CertificationsSumAggregateOutputType | null
    _min: CertificationsMinAggregateOutputType | null
    _max: CertificationsMaxAggregateOutputType | null
  }

  type GetCertificationsGroupByPayload<T extends CertificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationsGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationsGroupByOutputType[P]>
        }
      >
    >


  export type CertificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    certificateName?: boolean
    issuingOrganisation?: boolean
    issueDate?: boolean
    descreption?: boolean
    certificateURL?: boolean
    certificateMediaLink?: boolean
    User?: boolean | Certifications$UserArgs<ExtArgs>
  }, ExtArgs["result"]["certifications"]>

  export type CertificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    certificateName?: boolean
    issuingOrganisation?: boolean
    issueDate?: boolean
    descreption?: boolean
    certificateURL?: boolean
    certificateMediaLink?: boolean
    User?: boolean | Certifications$UserArgs<ExtArgs>
  }, ExtArgs["result"]["certifications"]>

  export type CertificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    certificateName?: boolean
    issuingOrganisation?: boolean
    issueDate?: boolean
    descreption?: boolean
    certificateURL?: boolean
    certificateMediaLink?: boolean
  }

  export type CertificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Certifications$UserArgs<ExtArgs>
  }
  export type CertificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Certifications$UserArgs<ExtArgs>
  }

  export type $CertificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certifications"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      certificateName: string | null
      issuingOrganisation: string | null
      issueDate: string | null
      descreption: string | null
      certificateURL: string | null
      certificateMediaLink: string | null
    }, ExtArgs["result"]["certifications"]>
    composites: {}
  }

  type CertificationsGetPayload<S extends boolean | null | undefined | CertificationsDefaultArgs> = $Result.GetResult<Prisma.$CertificationsPayload, S>

  type CertificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificationsCountAggregateInputType | true
    }

  export interface CertificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certifications'], meta: { name: 'Certifications' } }
    /**
     * Find zero or one Certifications that matches the filter.
     * @param {CertificationsFindUniqueArgs} args - Arguments to find a Certifications
     * @example
     * // Get one Certifications
     * const certifications = await prisma.certifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificationsFindUniqueArgs>(args: SelectSubset<T, CertificationsFindUniqueArgs<ExtArgs>>): Prisma__CertificationsClient<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificationsFindUniqueOrThrowArgs} args - Arguments to find a Certifications
     * @example
     * // Get one Certifications
     * const certifications = await prisma.certifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificationsClient<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationsFindFirstArgs} args - Arguments to find a Certifications
     * @example
     * // Get one Certifications
     * const certifications = await prisma.certifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificationsFindFirstArgs>(args?: SelectSubset<T, CertificationsFindFirstArgs<ExtArgs>>): Prisma__CertificationsClient<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationsFindFirstOrThrowArgs} args - Arguments to find a Certifications
     * @example
     * // Get one Certifications
     * const certifications = await prisma.certifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificationsClient<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certifications
     * const certifications = await prisma.certifications.findMany()
     * 
     * // Get first 10 Certifications
     * const certifications = await prisma.certifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationsWithIdOnly = await prisma.certifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificationsFindManyArgs>(args?: SelectSubset<T, CertificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certifications.
     * @param {CertificationsCreateArgs} args - Arguments to create a Certifications.
     * @example
     * // Create one Certifications
     * const Certifications = await prisma.certifications.create({
     *   data: {
     *     // ... data to create a Certifications
     *   }
     * })
     * 
     */
    create<T extends CertificationsCreateArgs>(args: SelectSubset<T, CertificationsCreateArgs<ExtArgs>>): Prisma__CertificationsClient<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certifications.
     * @param {CertificationsCreateManyArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certifications = await prisma.certifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificationsCreateManyArgs>(args?: SelectSubset<T, CertificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certifications and returns the data saved in the database.
     * @param {CertificationsCreateManyAndReturnArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certifications = await prisma.certifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certifications and only return the `id`
     * const certificationsWithIdOnly = await prisma.certifications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certifications.
     * @param {CertificationsDeleteArgs} args - Arguments to delete one Certifications.
     * @example
     * // Delete one Certifications
     * const Certifications = await prisma.certifications.delete({
     *   where: {
     *     // ... filter to delete one Certifications
     *   }
     * })
     * 
     */
    delete<T extends CertificationsDeleteArgs>(args: SelectSubset<T, CertificationsDeleteArgs<ExtArgs>>): Prisma__CertificationsClient<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certifications.
     * @param {CertificationsUpdateArgs} args - Arguments to update one Certifications.
     * @example
     * // Update one Certifications
     * const certifications = await prisma.certifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificationsUpdateArgs>(args: SelectSubset<T, CertificationsUpdateArgs<ExtArgs>>): Prisma__CertificationsClient<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certifications.
     * @param {CertificationsDeleteManyArgs} args - Arguments to filter Certifications to delete.
     * @example
     * // Delete a few Certifications
     * const { count } = await prisma.certifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificationsDeleteManyArgs>(args?: SelectSubset<T, CertificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certifications
     * const certifications = await prisma.certifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificationsUpdateManyArgs>(args: SelectSubset<T, CertificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certifications.
     * @param {CertificationsUpsertArgs} args - Arguments to update or create a Certifications.
     * @example
     * // Update or create a Certifications
     * const certifications = await prisma.certifications.upsert({
     *   create: {
     *     // ... data to create a Certifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certifications we want to update
     *   }
     * })
     */
    upsert<T extends CertificationsUpsertArgs>(args: SelectSubset<T, CertificationsUpsertArgs<ExtArgs>>): Prisma__CertificationsClient<$Result.GetResult<Prisma.$CertificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationsCountArgs} args - Arguments to filter Certifications to count.
     * @example
     * // Count the number of Certifications
     * const count = await prisma.certifications.count({
     *   where: {
     *     // ... the filter for the Certifications we want to count
     *   }
     * })
    **/
    count<T extends CertificationsCountArgs>(
      args?: Subset<T, CertificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationsAggregateArgs>(args: Subset<T, CertificationsAggregateArgs>): Prisma.PrismaPromise<GetCertificationsAggregateType<T>>

    /**
     * Group by Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationsGroupByArgs['orderBy'] }
        : { orderBy?: CertificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certifications model
   */
  readonly fields: CertificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Certifications$UserArgs<ExtArgs> = {}>(args?: Subset<T, Certifications$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certifications model
   */ 
  interface CertificationsFieldRefs {
    readonly id: FieldRef<"Certifications", 'Int'>
    readonly userId: FieldRef<"Certifications", 'Int'>
    readonly certificateName: FieldRef<"Certifications", 'String'>
    readonly issuingOrganisation: FieldRef<"Certifications", 'String'>
    readonly issueDate: FieldRef<"Certifications", 'String'>
    readonly descreption: FieldRef<"Certifications", 'String'>
    readonly certificateURL: FieldRef<"Certifications", 'String'>
    readonly certificateMediaLink: FieldRef<"Certifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Certifications findUnique
   */
  export type CertificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where: CertificationsWhereUniqueInput
  }

  /**
   * Certifications findUniqueOrThrow
   */
  export type CertificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where: CertificationsWhereUniqueInput
  }

  /**
   * Certifications findFirst
   */
  export type CertificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationsOrderByWithRelationInput | CertificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationsScalarFieldEnum | CertificationsScalarFieldEnum[]
  }

  /**
   * Certifications findFirstOrThrow
   */
  export type CertificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationsOrderByWithRelationInput | CertificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationsScalarFieldEnum | CertificationsScalarFieldEnum[]
  }

  /**
   * Certifications findMany
   */
  export type CertificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationsOrderByWithRelationInput | CertificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certifications.
     */
    cursor?: CertificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    distinct?: CertificationsScalarFieldEnum | CertificationsScalarFieldEnum[]
  }

  /**
   * Certifications create
   */
  export type CertificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Certifications.
     */
    data?: XOR<CertificationsCreateInput, CertificationsUncheckedCreateInput>
  }

  /**
   * Certifications createMany
   */
  export type CertificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certifications.
     */
    data: CertificationsCreateManyInput | CertificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certifications createManyAndReturn
   */
  export type CertificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certifications.
     */
    data: CertificationsCreateManyInput | CertificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certifications update
   */
  export type CertificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Certifications.
     */
    data: XOR<CertificationsUpdateInput, CertificationsUncheckedUpdateInput>
    /**
     * Choose, which Certifications to update.
     */
    where: CertificationsWhereUniqueInput
  }

  /**
   * Certifications updateMany
   */
  export type CertificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationsUpdateManyMutationInput, CertificationsUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationsWhereInput
  }

  /**
   * Certifications upsert
   */
  export type CertificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Certifications to update in case it exists.
     */
    where: CertificationsWhereUniqueInput
    /**
     * In case the Certifications found by the `where` argument doesn't exist, create a new Certifications with this data.
     */
    create: XOR<CertificationsCreateInput, CertificationsUncheckedCreateInput>
    /**
     * In case the Certifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationsUpdateInput, CertificationsUncheckedUpdateInput>
  }

  /**
   * Certifications delete
   */
  export type CertificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
    /**
     * Filter which Certifications to delete.
     */
    where: CertificationsWhereUniqueInput
  }

  /**
   * Certifications deleteMany
   */
  export type CertificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certifications to delete
     */
    where?: CertificationsWhereInput
  }

  /**
   * Certifications.User
   */
  export type Certifications$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Certifications without action
   */
  export type CertificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certifications
     */
    select?: CertificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationsInclude<ExtArgs> | null
  }


  /**
   * Model Memberships
   */

  export type AggregateMemberships = {
    _count: MembershipsCountAggregateOutputType | null
    _avg: MembershipsAvgAggregateOutputType | null
    _sum: MembershipsSumAggregateOutputType | null
    _min: MembershipsMinAggregateOutputType | null
    _max: MembershipsMaxAggregateOutputType | null
  }

  export type MembershipsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MembershipsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MembershipsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    societyname: string | null
    position: string | null
    relatedDepartment: string | null
    membershipId: string | null
  }

  export type MembershipsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    societyname: string | null
    position: string | null
    relatedDepartment: string | null
    membershipId: string | null
  }

  export type MembershipsCountAggregateOutputType = {
    id: number
    userId: number
    societyname: number
    position: number
    relatedDepartment: number
    membershipId: number
    _all: number
  }


  export type MembershipsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MembershipsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MembershipsMinAggregateInputType = {
    id?: true
    userId?: true
    societyname?: true
    position?: true
    relatedDepartment?: true
    membershipId?: true
  }

  export type MembershipsMaxAggregateInputType = {
    id?: true
    userId?: true
    societyname?: true
    position?: true
    relatedDepartment?: true
    membershipId?: true
  }

  export type MembershipsCountAggregateInputType = {
    id?: true
    userId?: true
    societyname?: true
    position?: true
    relatedDepartment?: true
    membershipId?: true
    _all?: true
  }

  export type MembershipsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memberships to aggregate.
     */
    where?: MembershipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipsOrderByWithRelationInput | MembershipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memberships
    **/
    _count?: true | MembershipsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipsMaxAggregateInputType
  }

  export type GetMembershipsAggregateType<T extends MembershipsAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberships]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberships[P]>
      : GetScalarType<T[P], AggregateMemberships[P]>
  }




  export type MembershipsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipsWhereInput
    orderBy?: MembershipsOrderByWithAggregationInput | MembershipsOrderByWithAggregationInput[]
    by: MembershipsScalarFieldEnum[] | MembershipsScalarFieldEnum
    having?: MembershipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipsCountAggregateInputType | true
    _avg?: MembershipsAvgAggregateInputType
    _sum?: MembershipsSumAggregateInputType
    _min?: MembershipsMinAggregateInputType
    _max?: MembershipsMaxAggregateInputType
  }

  export type MembershipsGroupByOutputType = {
    id: number
    userId: number | null
    societyname: string | null
    position: string | null
    relatedDepartment: string | null
    membershipId: string | null
    _count: MembershipsCountAggregateOutputType | null
    _avg: MembershipsAvgAggregateOutputType | null
    _sum: MembershipsSumAggregateOutputType | null
    _min: MembershipsMinAggregateOutputType | null
    _max: MembershipsMaxAggregateOutputType | null
  }

  type GetMembershipsGroupByPayload<T extends MembershipsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipsGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipsGroupByOutputType[P]>
        }
      >
    >


  export type MembershipsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    societyname?: boolean
    position?: boolean
    relatedDepartment?: boolean
    membershipId?: boolean
    User?: boolean | Memberships$UserArgs<ExtArgs>
  }, ExtArgs["result"]["memberships"]>

  export type MembershipsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    societyname?: boolean
    position?: boolean
    relatedDepartment?: boolean
    membershipId?: boolean
    User?: boolean | Memberships$UserArgs<ExtArgs>
  }, ExtArgs["result"]["memberships"]>

  export type MembershipsSelectScalar = {
    id?: boolean
    userId?: boolean
    societyname?: boolean
    position?: boolean
    relatedDepartment?: boolean
    membershipId?: boolean
  }

  export type MembershipsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Memberships$UserArgs<ExtArgs>
  }
  export type MembershipsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Memberships$UserArgs<ExtArgs>
  }

  export type $MembershipsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Memberships"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      societyname: string | null
      position: string | null
      relatedDepartment: string | null
      membershipId: string | null
    }, ExtArgs["result"]["memberships"]>
    composites: {}
  }

  type MembershipsGetPayload<S extends boolean | null | undefined | MembershipsDefaultArgs> = $Result.GetResult<Prisma.$MembershipsPayload, S>

  type MembershipsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MembershipsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MembershipsCountAggregateInputType | true
    }

  export interface MembershipsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Memberships'], meta: { name: 'Memberships' } }
    /**
     * Find zero or one Memberships that matches the filter.
     * @param {MembershipsFindUniqueArgs} args - Arguments to find a Memberships
     * @example
     * // Get one Memberships
     * const memberships = await prisma.memberships.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipsFindUniqueArgs>(args: SelectSubset<T, MembershipsFindUniqueArgs<ExtArgs>>): Prisma__MembershipsClient<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Memberships that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MembershipsFindUniqueOrThrowArgs} args - Arguments to find a Memberships
     * @example
     * // Get one Memberships
     * const memberships = await prisma.memberships.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipsFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipsClient<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipsFindFirstArgs} args - Arguments to find a Memberships
     * @example
     * // Get one Memberships
     * const memberships = await prisma.memberships.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipsFindFirstArgs>(args?: SelectSubset<T, MembershipsFindFirstArgs<ExtArgs>>): Prisma__MembershipsClient<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Memberships that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipsFindFirstOrThrowArgs} args - Arguments to find a Memberships
     * @example
     * // Get one Memberships
     * const memberships = await prisma.memberships.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipsFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipsClient<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.memberships.findMany()
     * 
     * // Get first 10 Memberships
     * const memberships = await prisma.memberships.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipsWithIdOnly = await prisma.memberships.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipsFindManyArgs>(args?: SelectSubset<T, MembershipsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Memberships.
     * @param {MembershipsCreateArgs} args - Arguments to create a Memberships.
     * @example
     * // Create one Memberships
     * const Memberships = await prisma.memberships.create({
     *   data: {
     *     // ... data to create a Memberships
     *   }
     * })
     * 
     */
    create<T extends MembershipsCreateArgs>(args: SelectSubset<T, MembershipsCreateArgs<ExtArgs>>): Prisma__MembershipsClient<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Memberships.
     * @param {MembershipsCreateManyArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const memberships = await prisma.memberships.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipsCreateManyArgs>(args?: SelectSubset<T, MembershipsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memberships and returns the data saved in the database.
     * @param {MembershipsCreateManyAndReturnArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const memberships = await prisma.memberships.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memberships and only return the `id`
     * const membershipsWithIdOnly = await prisma.memberships.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipsCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Memberships.
     * @param {MembershipsDeleteArgs} args - Arguments to delete one Memberships.
     * @example
     * // Delete one Memberships
     * const Memberships = await prisma.memberships.delete({
     *   where: {
     *     // ... filter to delete one Memberships
     *   }
     * })
     * 
     */
    delete<T extends MembershipsDeleteArgs>(args: SelectSubset<T, MembershipsDeleteArgs<ExtArgs>>): Prisma__MembershipsClient<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Memberships.
     * @param {MembershipsUpdateArgs} args - Arguments to update one Memberships.
     * @example
     * // Update one Memberships
     * const memberships = await prisma.memberships.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipsUpdateArgs>(args: SelectSubset<T, MembershipsUpdateArgs<ExtArgs>>): Prisma__MembershipsClient<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Memberships.
     * @param {MembershipsDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.memberships.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipsDeleteManyArgs>(args?: SelectSubset<T, MembershipsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const memberships = await prisma.memberships.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipsUpdateManyArgs>(args: SelectSubset<T, MembershipsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Memberships.
     * @param {MembershipsUpsertArgs} args - Arguments to update or create a Memberships.
     * @example
     * // Update or create a Memberships
     * const memberships = await prisma.memberships.upsert({
     *   create: {
     *     // ... data to create a Memberships
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Memberships we want to update
     *   }
     * })
     */
    upsert<T extends MembershipsUpsertArgs>(args: SelectSubset<T, MembershipsUpsertArgs<ExtArgs>>): Prisma__MembershipsClient<$Result.GetResult<Prisma.$MembershipsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipsCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.memberships.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
    **/
    count<T extends MembershipsCountArgs>(
      args?: Subset<T, MembershipsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipsAggregateArgs>(args: Subset<T, MembershipsAggregateArgs>): Prisma.PrismaPromise<GetMembershipsAggregateType<T>>

    /**
     * Group by Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipsGroupByArgs['orderBy'] }
        : { orderBy?: MembershipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Memberships model
   */
  readonly fields: MembershipsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Memberships.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Memberships$UserArgs<ExtArgs> = {}>(args?: Subset<T, Memberships$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Memberships model
   */ 
  interface MembershipsFieldRefs {
    readonly id: FieldRef<"Memberships", 'Int'>
    readonly userId: FieldRef<"Memberships", 'Int'>
    readonly societyname: FieldRef<"Memberships", 'String'>
    readonly position: FieldRef<"Memberships", 'String'>
    readonly relatedDepartment: FieldRef<"Memberships", 'String'>
    readonly membershipId: FieldRef<"Memberships", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Memberships findUnique
   */
  export type MembershipsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where: MembershipsWhereUniqueInput
  }

  /**
   * Memberships findUniqueOrThrow
   */
  export type MembershipsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where: MembershipsWhereUniqueInput
  }

  /**
   * Memberships findFirst
   */
  export type MembershipsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipsOrderByWithRelationInput | MembershipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipsScalarFieldEnum | MembershipsScalarFieldEnum[]
  }

  /**
   * Memberships findFirstOrThrow
   */
  export type MembershipsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipsOrderByWithRelationInput | MembershipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipsScalarFieldEnum | MembershipsScalarFieldEnum[]
  }

  /**
   * Memberships findMany
   */
  export type MembershipsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipsOrderByWithRelationInput | MembershipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memberships.
     */
    cursor?: MembershipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    distinct?: MembershipsScalarFieldEnum | MembershipsScalarFieldEnum[]
  }

  /**
   * Memberships create
   */
  export type MembershipsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    /**
     * The data needed to create a Memberships.
     */
    data?: XOR<MembershipsCreateInput, MembershipsUncheckedCreateInput>
  }

  /**
   * Memberships createMany
   */
  export type MembershipsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memberships.
     */
    data: MembershipsCreateManyInput | MembershipsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Memberships createManyAndReturn
   */
  export type MembershipsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Memberships.
     */
    data: MembershipsCreateManyInput | MembershipsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Memberships update
   */
  export type MembershipsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    /**
     * The data needed to update a Memberships.
     */
    data: XOR<MembershipsUpdateInput, MembershipsUncheckedUpdateInput>
    /**
     * Choose, which Memberships to update.
     */
    where: MembershipsWhereUniqueInput
  }

  /**
   * Memberships updateMany
   */
  export type MembershipsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipsUpdateManyMutationInput, MembershipsUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipsWhereInput
  }

  /**
   * Memberships upsert
   */
  export type MembershipsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    /**
     * The filter to search for the Memberships to update in case it exists.
     */
    where: MembershipsWhereUniqueInput
    /**
     * In case the Memberships found by the `where` argument doesn't exist, create a new Memberships with this data.
     */
    create: XOR<MembershipsCreateInput, MembershipsUncheckedCreateInput>
    /**
     * In case the Memberships was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipsUpdateInput, MembershipsUncheckedUpdateInput>
  }

  /**
   * Memberships delete
   */
  export type MembershipsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
    /**
     * Filter which Memberships to delete.
     */
    where: MembershipsWhereUniqueInput
  }

  /**
   * Memberships deleteMany
   */
  export type MembershipsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memberships to delete
     */
    where?: MembershipsWhereInput
  }

  /**
   * Memberships.User
   */
  export type Memberships$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Memberships without action
   */
  export type MembershipsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Memberships
     */
    select?: MembershipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipsInclude<ExtArgs> | null
  }


  /**
   * Model Education
   */

  export type AggregateEducation = {
    _count: EducationCountAggregateOutputType | null
    _avg: EducationAvgAggregateOutputType | null
    _sum: EducationSumAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  export type EducationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EducationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EducationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    schoolName: string | null
    degree: string | null
    department: string | null
    startDate: string | null
    endDate: string | null
    grade: string | null
  }

  export type EducationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    schoolName: string | null
    degree: string | null
    department: string | null
    startDate: string | null
    endDate: string | null
    grade: string | null
  }

  export type EducationCountAggregateOutputType = {
    id: number
    userId: number
    schoolName: number
    degree: number
    department: number
    startDate: number
    endDate: number
    grade: number
    _all: number
  }


  export type EducationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EducationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EducationMinAggregateInputType = {
    id?: true
    userId?: true
    schoolName?: true
    degree?: true
    department?: true
    startDate?: true
    endDate?: true
    grade?: true
  }

  export type EducationMaxAggregateInputType = {
    id?: true
    userId?: true
    schoolName?: true
    degree?: true
    department?: true
    startDate?: true
    endDate?: true
    grade?: true
  }

  export type EducationCountAggregateInputType = {
    id?: true
    userId?: true
    schoolName?: true
    degree?: true
    department?: true
    startDate?: true
    endDate?: true
    grade?: true
    _all?: true
  }

  export type EducationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Education to aggregate.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Educations
    **/
    _count?: true | EducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationMaxAggregateInputType
  }

  export type GetEducationAggregateType<T extends EducationAggregateArgs> = {
        [P in keyof T & keyof AggregateEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducation[P]>
      : GetScalarType<T[P], AggregateEducation[P]>
  }




  export type EducationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithAggregationInput | EducationOrderByWithAggregationInput[]
    by: EducationScalarFieldEnum[] | EducationScalarFieldEnum
    having?: EducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationCountAggregateInputType | true
    _avg?: EducationAvgAggregateInputType
    _sum?: EducationSumAggregateInputType
    _min?: EducationMinAggregateInputType
    _max?: EducationMaxAggregateInputType
  }

  export type EducationGroupByOutputType = {
    id: number
    userId: number | null
    schoolName: string | null
    degree: string | null
    department: string | null
    startDate: string | null
    endDate: string | null
    grade: string | null
    _count: EducationCountAggregateOutputType | null
    _avg: EducationAvgAggregateOutputType | null
    _sum: EducationSumAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  type GetEducationGroupByPayload<T extends EducationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationGroupByOutputType[P]>
            : GetScalarType<T[P], EducationGroupByOutputType[P]>
        }
      >
    >


  export type EducationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    schoolName?: boolean
    degree?: boolean
    department?: boolean
    startDate?: boolean
    endDate?: boolean
    grade?: boolean
    User?: boolean | Education$UserArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    schoolName?: boolean
    degree?: boolean
    department?: boolean
    startDate?: boolean
    endDate?: boolean
    grade?: boolean
    User?: boolean | Education$UserArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectScalar = {
    id?: boolean
    userId?: boolean
    schoolName?: boolean
    degree?: boolean
    department?: boolean
    startDate?: boolean
    endDate?: boolean
    grade?: boolean
  }

  export type EducationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Education$UserArgs<ExtArgs>
  }
  export type EducationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Education$UserArgs<ExtArgs>
  }

  export type $EducationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Education"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      schoolName: string | null
      degree: string | null
      department: string | null
      startDate: string | null
      endDate: string | null
      grade: string | null
    }, ExtArgs["result"]["education"]>
    composites: {}
  }

  type EducationGetPayload<S extends boolean | null | undefined | EducationDefaultArgs> = $Result.GetResult<Prisma.$EducationPayload, S>

  type EducationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EducationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EducationCountAggregateInputType | true
    }

  export interface EducationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Education'], meta: { name: 'Education' } }
    /**
     * Find zero or one Education that matches the filter.
     * @param {EducationFindUniqueArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationFindUniqueArgs>(args: SelectSubset<T, EducationFindUniqueArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Education that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EducationFindUniqueOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Education that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationFindFirstArgs>(args?: SelectSubset<T, EducationFindFirstArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Education that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Educations
     * const educations = await prisma.education.findMany()
     * 
     * // Get first 10 Educations
     * const educations = await prisma.education.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationWithIdOnly = await prisma.education.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationFindManyArgs>(args?: SelectSubset<T, EducationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Education.
     * @param {EducationCreateArgs} args - Arguments to create a Education.
     * @example
     * // Create one Education
     * const Education = await prisma.education.create({
     *   data: {
     *     // ... data to create a Education
     *   }
     * })
     * 
     */
    create<T extends EducationCreateArgs>(args: SelectSubset<T, EducationCreateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Educations.
     * @param {EducationCreateManyArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationCreateManyArgs>(args?: SelectSubset<T, EducationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Educations and returns the data saved in the database.
     * @param {EducationCreateManyAndReturnArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Educations and only return the `id`
     * const educationWithIdOnly = await prisma.education.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EducationCreateManyAndReturnArgs>(args?: SelectSubset<T, EducationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Education.
     * @param {EducationDeleteArgs} args - Arguments to delete one Education.
     * @example
     * // Delete one Education
     * const Education = await prisma.education.delete({
     *   where: {
     *     // ... filter to delete one Education
     *   }
     * })
     * 
     */
    delete<T extends EducationDeleteArgs>(args: SelectSubset<T, EducationDeleteArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Education.
     * @param {EducationUpdateArgs} args - Arguments to update one Education.
     * @example
     * // Update one Education
     * const education = await prisma.education.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationUpdateArgs>(args: SelectSubset<T, EducationUpdateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Educations.
     * @param {EducationDeleteManyArgs} args - Arguments to filter Educations to delete.
     * @example
     * // Delete a few Educations
     * const { count } = await prisma.education.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationDeleteManyArgs>(args?: SelectSubset<T, EducationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationUpdateManyArgs>(args: SelectSubset<T, EducationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Education.
     * @param {EducationUpsertArgs} args - Arguments to update or create a Education.
     * @example
     * // Update or create a Education
     * const education = await prisma.education.upsert({
     *   create: {
     *     // ... data to create a Education
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Education we want to update
     *   }
     * })
     */
    upsert<T extends EducationUpsertArgs>(args: SelectSubset<T, EducationUpsertArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationCountArgs} args - Arguments to filter Educations to count.
     * @example
     * // Count the number of Educations
     * const count = await prisma.education.count({
     *   where: {
     *     // ... the filter for the Educations we want to count
     *   }
     * })
    **/
    count<T extends EducationCountArgs>(
      args?: Subset<T, EducationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationAggregateArgs>(args: Subset<T, EducationAggregateArgs>): Prisma.PrismaPromise<GetEducationAggregateType<T>>

    /**
     * Group by Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationGroupByArgs['orderBy'] }
        : { orderBy?: EducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Education model
   */
  readonly fields: EducationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Education$UserArgs<ExtArgs> = {}>(args?: Subset<T, Education$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Education model
   */ 
  interface EducationFieldRefs {
    readonly id: FieldRef<"Education", 'Int'>
    readonly userId: FieldRef<"Education", 'Int'>
    readonly schoolName: FieldRef<"Education", 'String'>
    readonly degree: FieldRef<"Education", 'String'>
    readonly department: FieldRef<"Education", 'String'>
    readonly startDate: FieldRef<"Education", 'String'>
    readonly endDate: FieldRef<"Education", 'String'>
    readonly grade: FieldRef<"Education", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Education findUnique
   */
  export type EducationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findUniqueOrThrow
   */
  export type EducationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findFirst
   */
  export type EducationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findFirstOrThrow
   */
  export type EducationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findMany
   */
  export type EducationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Educations to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education create
   */
  export type EducationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to create a Education.
     */
    data?: XOR<EducationCreateInput, EducationUncheckedCreateInput>
  }

  /**
   * Education createMany
   */
  export type EducationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Education createManyAndReturn
   */
  export type EducationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Education update
   */
  export type EducationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to update a Education.
     */
    data: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
    /**
     * Choose, which Education to update.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education updateMany
   */
  export type EducationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
  }

  /**
   * Education upsert
   */
  export type EducationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The filter to search for the Education to update in case it exists.
     */
    where: EducationWhereUniqueInput
    /**
     * In case the Education found by the `where` argument doesn't exist, create a new Education with this data.
     */
    create: XOR<EducationCreateInput, EducationUncheckedCreateInput>
    /**
     * In case the Education was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
  }

  /**
   * Education delete
   */
  export type EducationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter which Education to delete.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education deleteMany
   */
  export type EducationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Educations to delete
     */
    where?: EducationWhereInput
  }

  /**
   * Education.User
   */
  export type Education$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Education without action
   */
  export type EducationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
  }


  /**
   * Model ProfessionalExperience
   */

  export type AggregateProfessionalExperience = {
    _count: ProfessionalExperienceCountAggregateOutputType | null
    _avg: ProfessionalExperienceAvgAggregateOutputType | null
    _sum: ProfessionalExperienceSumAggregateOutputType | null
    _min: ProfessionalExperienceMinAggregateOutputType | null
    _max: ProfessionalExperienceMaxAggregateOutputType | null
  }

  export type ProfessionalExperienceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfessionalExperienceSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfessionalExperienceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    organisation: string | null
    startDate: string | null
    endDate: string | null
    location: string | null
  }

  export type ProfessionalExperienceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    organisation: string | null
    startDate: string | null
    endDate: string | null
    location: string | null
  }

  export type ProfessionalExperienceCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    organisation: number
    startDate: number
    endDate: number
    location: number
    _all: number
  }


  export type ProfessionalExperienceAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfessionalExperienceSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfessionalExperienceMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    organisation?: true
    startDate?: true
    endDate?: true
    location?: true
  }

  export type ProfessionalExperienceMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    organisation?: true
    startDate?: true
    endDate?: true
    location?: true
  }

  export type ProfessionalExperienceCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    organisation?: true
    startDate?: true
    endDate?: true
    location?: true
    _all?: true
  }

  export type ProfessionalExperienceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfessionalExperience to aggregate.
     */
    where?: ProfessionalExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfessionalExperiences to fetch.
     */
    orderBy?: ProfessionalExperienceOrderByWithRelationInput | ProfessionalExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfessionalExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfessionalExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfessionalExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfessionalExperiences
    **/
    _count?: true | ProfessionalExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfessionalExperienceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfessionalExperienceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfessionalExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfessionalExperienceMaxAggregateInputType
  }

  export type GetProfessionalExperienceAggregateType<T extends ProfessionalExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateProfessionalExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfessionalExperience[P]>
      : GetScalarType<T[P], AggregateProfessionalExperience[P]>
  }




  export type ProfessionalExperienceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfessionalExperienceWhereInput
    orderBy?: ProfessionalExperienceOrderByWithAggregationInput | ProfessionalExperienceOrderByWithAggregationInput[]
    by: ProfessionalExperienceScalarFieldEnum[] | ProfessionalExperienceScalarFieldEnum
    having?: ProfessionalExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfessionalExperienceCountAggregateInputType | true
    _avg?: ProfessionalExperienceAvgAggregateInputType
    _sum?: ProfessionalExperienceSumAggregateInputType
    _min?: ProfessionalExperienceMinAggregateInputType
    _max?: ProfessionalExperienceMaxAggregateInputType
  }

  export type ProfessionalExperienceGroupByOutputType = {
    id: number
    userId: number | null
    title: string | null
    organisation: string | null
    startDate: string | null
    endDate: string | null
    location: string | null
    _count: ProfessionalExperienceCountAggregateOutputType | null
    _avg: ProfessionalExperienceAvgAggregateOutputType | null
    _sum: ProfessionalExperienceSumAggregateOutputType | null
    _min: ProfessionalExperienceMinAggregateOutputType | null
    _max: ProfessionalExperienceMaxAggregateOutputType | null
  }

  type GetProfessionalExperienceGroupByPayload<T extends ProfessionalExperienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfessionalExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfessionalExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfessionalExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], ProfessionalExperienceGroupByOutputType[P]>
        }
      >
    >


  export type ProfessionalExperienceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    organisation?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    User?: boolean | ProfessionalExperience$UserArgs<ExtArgs>
  }, ExtArgs["result"]["professionalExperience"]>

  export type ProfessionalExperienceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    organisation?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    User?: boolean | ProfessionalExperience$UserArgs<ExtArgs>
  }, ExtArgs["result"]["professionalExperience"]>

  export type ProfessionalExperienceSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    organisation?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
  }

  export type ProfessionalExperienceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | ProfessionalExperience$UserArgs<ExtArgs>
  }
  export type ProfessionalExperienceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | ProfessionalExperience$UserArgs<ExtArgs>
  }

  export type $ProfessionalExperiencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfessionalExperience"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      title: string | null
      organisation: string | null
      startDate: string | null
      endDate: string | null
      location: string | null
    }, ExtArgs["result"]["professionalExperience"]>
    composites: {}
  }

  type ProfessionalExperienceGetPayload<S extends boolean | null | undefined | ProfessionalExperienceDefaultArgs> = $Result.GetResult<Prisma.$ProfessionalExperiencePayload, S>

  type ProfessionalExperienceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfessionalExperienceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfessionalExperienceCountAggregateInputType | true
    }

  export interface ProfessionalExperienceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfessionalExperience'], meta: { name: 'ProfessionalExperience' } }
    /**
     * Find zero or one ProfessionalExperience that matches the filter.
     * @param {ProfessionalExperienceFindUniqueArgs} args - Arguments to find a ProfessionalExperience
     * @example
     * // Get one ProfessionalExperience
     * const professionalExperience = await prisma.professionalExperience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfessionalExperienceFindUniqueArgs>(args: SelectSubset<T, ProfessionalExperienceFindUniqueArgs<ExtArgs>>): Prisma__ProfessionalExperienceClient<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfessionalExperience that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfessionalExperienceFindUniqueOrThrowArgs} args - Arguments to find a ProfessionalExperience
     * @example
     * // Get one ProfessionalExperience
     * const professionalExperience = await prisma.professionalExperience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfessionalExperienceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfessionalExperienceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfessionalExperienceClient<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfessionalExperience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalExperienceFindFirstArgs} args - Arguments to find a ProfessionalExperience
     * @example
     * // Get one ProfessionalExperience
     * const professionalExperience = await prisma.professionalExperience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfessionalExperienceFindFirstArgs>(args?: SelectSubset<T, ProfessionalExperienceFindFirstArgs<ExtArgs>>): Prisma__ProfessionalExperienceClient<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfessionalExperience that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalExperienceFindFirstOrThrowArgs} args - Arguments to find a ProfessionalExperience
     * @example
     * // Get one ProfessionalExperience
     * const professionalExperience = await prisma.professionalExperience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfessionalExperienceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfessionalExperienceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfessionalExperienceClient<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfessionalExperiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalExperienceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfessionalExperiences
     * const professionalExperiences = await prisma.professionalExperience.findMany()
     * 
     * // Get first 10 ProfessionalExperiences
     * const professionalExperiences = await prisma.professionalExperience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const professionalExperienceWithIdOnly = await prisma.professionalExperience.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfessionalExperienceFindManyArgs>(args?: SelectSubset<T, ProfessionalExperienceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfessionalExperience.
     * @param {ProfessionalExperienceCreateArgs} args - Arguments to create a ProfessionalExperience.
     * @example
     * // Create one ProfessionalExperience
     * const ProfessionalExperience = await prisma.professionalExperience.create({
     *   data: {
     *     // ... data to create a ProfessionalExperience
     *   }
     * })
     * 
     */
    create<T extends ProfessionalExperienceCreateArgs>(args: SelectSubset<T, ProfessionalExperienceCreateArgs<ExtArgs>>): Prisma__ProfessionalExperienceClient<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfessionalExperiences.
     * @param {ProfessionalExperienceCreateManyArgs} args - Arguments to create many ProfessionalExperiences.
     * @example
     * // Create many ProfessionalExperiences
     * const professionalExperience = await prisma.professionalExperience.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfessionalExperienceCreateManyArgs>(args?: SelectSubset<T, ProfessionalExperienceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfessionalExperiences and returns the data saved in the database.
     * @param {ProfessionalExperienceCreateManyAndReturnArgs} args - Arguments to create many ProfessionalExperiences.
     * @example
     * // Create many ProfessionalExperiences
     * const professionalExperience = await prisma.professionalExperience.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfessionalExperiences and only return the `id`
     * const professionalExperienceWithIdOnly = await prisma.professionalExperience.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfessionalExperienceCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfessionalExperienceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfessionalExperience.
     * @param {ProfessionalExperienceDeleteArgs} args - Arguments to delete one ProfessionalExperience.
     * @example
     * // Delete one ProfessionalExperience
     * const ProfessionalExperience = await prisma.professionalExperience.delete({
     *   where: {
     *     // ... filter to delete one ProfessionalExperience
     *   }
     * })
     * 
     */
    delete<T extends ProfessionalExperienceDeleteArgs>(args: SelectSubset<T, ProfessionalExperienceDeleteArgs<ExtArgs>>): Prisma__ProfessionalExperienceClient<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfessionalExperience.
     * @param {ProfessionalExperienceUpdateArgs} args - Arguments to update one ProfessionalExperience.
     * @example
     * // Update one ProfessionalExperience
     * const professionalExperience = await prisma.professionalExperience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfessionalExperienceUpdateArgs>(args: SelectSubset<T, ProfessionalExperienceUpdateArgs<ExtArgs>>): Prisma__ProfessionalExperienceClient<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfessionalExperiences.
     * @param {ProfessionalExperienceDeleteManyArgs} args - Arguments to filter ProfessionalExperiences to delete.
     * @example
     * // Delete a few ProfessionalExperiences
     * const { count } = await prisma.professionalExperience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfessionalExperienceDeleteManyArgs>(args?: SelectSubset<T, ProfessionalExperienceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfessionalExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfessionalExperiences
     * const professionalExperience = await prisma.professionalExperience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfessionalExperienceUpdateManyArgs>(args: SelectSubset<T, ProfessionalExperienceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfessionalExperience.
     * @param {ProfessionalExperienceUpsertArgs} args - Arguments to update or create a ProfessionalExperience.
     * @example
     * // Update or create a ProfessionalExperience
     * const professionalExperience = await prisma.professionalExperience.upsert({
     *   create: {
     *     // ... data to create a ProfessionalExperience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfessionalExperience we want to update
     *   }
     * })
     */
    upsert<T extends ProfessionalExperienceUpsertArgs>(args: SelectSubset<T, ProfessionalExperienceUpsertArgs<ExtArgs>>): Prisma__ProfessionalExperienceClient<$Result.GetResult<Prisma.$ProfessionalExperiencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfessionalExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalExperienceCountArgs} args - Arguments to filter ProfessionalExperiences to count.
     * @example
     * // Count the number of ProfessionalExperiences
     * const count = await prisma.professionalExperience.count({
     *   where: {
     *     // ... the filter for the ProfessionalExperiences we want to count
     *   }
     * })
    **/
    count<T extends ProfessionalExperienceCountArgs>(
      args?: Subset<T, ProfessionalExperienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfessionalExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfessionalExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfessionalExperienceAggregateArgs>(args: Subset<T, ProfessionalExperienceAggregateArgs>): Prisma.PrismaPromise<GetProfessionalExperienceAggregateType<T>>

    /**
     * Group by ProfessionalExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfessionalExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfessionalExperienceGroupByArgs['orderBy'] }
        : { orderBy?: ProfessionalExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfessionalExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfessionalExperienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfessionalExperience model
   */
  readonly fields: ProfessionalExperienceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfessionalExperience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfessionalExperienceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends ProfessionalExperience$UserArgs<ExtArgs> = {}>(args?: Subset<T, ProfessionalExperience$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfessionalExperience model
   */ 
  interface ProfessionalExperienceFieldRefs {
    readonly id: FieldRef<"ProfessionalExperience", 'Int'>
    readonly userId: FieldRef<"ProfessionalExperience", 'Int'>
    readonly title: FieldRef<"ProfessionalExperience", 'String'>
    readonly organisation: FieldRef<"ProfessionalExperience", 'String'>
    readonly startDate: FieldRef<"ProfessionalExperience", 'String'>
    readonly endDate: FieldRef<"ProfessionalExperience", 'String'>
    readonly location: FieldRef<"ProfessionalExperience", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProfessionalExperience findUnique
   */
  export type ProfessionalExperienceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalExperience to fetch.
     */
    where: ProfessionalExperienceWhereUniqueInput
  }

  /**
   * ProfessionalExperience findUniqueOrThrow
   */
  export type ProfessionalExperienceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalExperience to fetch.
     */
    where: ProfessionalExperienceWhereUniqueInput
  }

  /**
   * ProfessionalExperience findFirst
   */
  export type ProfessionalExperienceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalExperience to fetch.
     */
    where?: ProfessionalExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfessionalExperiences to fetch.
     */
    orderBy?: ProfessionalExperienceOrderByWithRelationInput | ProfessionalExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfessionalExperiences.
     */
    cursor?: ProfessionalExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfessionalExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfessionalExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfessionalExperiences.
     */
    distinct?: ProfessionalExperienceScalarFieldEnum | ProfessionalExperienceScalarFieldEnum[]
  }

  /**
   * ProfessionalExperience findFirstOrThrow
   */
  export type ProfessionalExperienceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalExperience to fetch.
     */
    where?: ProfessionalExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfessionalExperiences to fetch.
     */
    orderBy?: ProfessionalExperienceOrderByWithRelationInput | ProfessionalExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfessionalExperiences.
     */
    cursor?: ProfessionalExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfessionalExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfessionalExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfessionalExperiences.
     */
    distinct?: ProfessionalExperienceScalarFieldEnum | ProfessionalExperienceScalarFieldEnum[]
  }

  /**
   * ProfessionalExperience findMany
   */
  export type ProfessionalExperienceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalExperiences to fetch.
     */
    where?: ProfessionalExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfessionalExperiences to fetch.
     */
    orderBy?: ProfessionalExperienceOrderByWithRelationInput | ProfessionalExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfessionalExperiences.
     */
    cursor?: ProfessionalExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfessionalExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfessionalExperiences.
     */
    skip?: number
    distinct?: ProfessionalExperienceScalarFieldEnum | ProfessionalExperienceScalarFieldEnum[]
  }

  /**
   * ProfessionalExperience create
   */
  export type ProfessionalExperienceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfessionalExperience.
     */
    data?: XOR<ProfessionalExperienceCreateInput, ProfessionalExperienceUncheckedCreateInput>
  }

  /**
   * ProfessionalExperience createMany
   */
  export type ProfessionalExperienceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfessionalExperiences.
     */
    data: ProfessionalExperienceCreateManyInput | ProfessionalExperienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfessionalExperience createManyAndReturn
   */
  export type ProfessionalExperienceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfessionalExperiences.
     */
    data: ProfessionalExperienceCreateManyInput | ProfessionalExperienceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfessionalExperience update
   */
  export type ProfessionalExperienceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfessionalExperience.
     */
    data: XOR<ProfessionalExperienceUpdateInput, ProfessionalExperienceUncheckedUpdateInput>
    /**
     * Choose, which ProfessionalExperience to update.
     */
    where: ProfessionalExperienceWhereUniqueInput
  }

  /**
   * ProfessionalExperience updateMany
   */
  export type ProfessionalExperienceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfessionalExperiences.
     */
    data: XOR<ProfessionalExperienceUpdateManyMutationInput, ProfessionalExperienceUncheckedUpdateManyInput>
    /**
     * Filter which ProfessionalExperiences to update
     */
    where?: ProfessionalExperienceWhereInput
  }

  /**
   * ProfessionalExperience upsert
   */
  export type ProfessionalExperienceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfessionalExperience to update in case it exists.
     */
    where: ProfessionalExperienceWhereUniqueInput
    /**
     * In case the ProfessionalExperience found by the `where` argument doesn't exist, create a new ProfessionalExperience with this data.
     */
    create: XOR<ProfessionalExperienceCreateInput, ProfessionalExperienceUncheckedCreateInput>
    /**
     * In case the ProfessionalExperience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfessionalExperienceUpdateInput, ProfessionalExperienceUncheckedUpdateInput>
  }

  /**
   * ProfessionalExperience delete
   */
  export type ProfessionalExperienceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
    /**
     * Filter which ProfessionalExperience to delete.
     */
    where: ProfessionalExperienceWhereUniqueInput
  }

  /**
   * ProfessionalExperience deleteMany
   */
  export type ProfessionalExperienceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfessionalExperiences to delete
     */
    where?: ProfessionalExperienceWhereInput
  }

  /**
   * ProfessionalExperience.User
   */
  export type ProfessionalExperience$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProfessionalExperience without action
   */
  export type ProfessionalExperienceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalExperience
     */
    select?: ProfessionalExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalExperienceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    category: 'category',
    email: 'email',
    password: 'password',
    name: 'name',
    gender: 'gender',
    department: 'department',
    country: 'country',
    city: 'city',
    organisation_name: 'organisation_name',
    specialisation_field_of_study: 'specialisation_field_of_study',
    register_number: 'register_number',
    verified: 'verified',
    date_of_birth: 'date_of_birth',
    created_at: 'created_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DoctorsScalarFieldEnum: {
    id: 'id',
    registrationNo: 'registrationNo',
    doctors: 'doctors'
  };

  export type DoctorsScalarFieldEnum = (typeof DoctorsScalarFieldEnum)[keyof typeof DoctorsScalarFieldEnum]


  export const AchievementsAwardsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    awardName: 'awardName',
    awardedBy: 'awardedBy',
    awardedOn: 'awardedOn',
    descreption: 'descreption'
  };

  export type AchievementsAwardsScalarFieldEnum = (typeof AchievementsAwardsScalarFieldEnum)[keyof typeof AchievementsAwardsScalarFieldEnum]


  export const OrganisationsScalarFieldEnum: {
    id: 'id',
    category: 'category',
    email: 'email',
    password: 'password',
    organisation_name: 'organisation_name',
    country: 'country',
    city: 'city',
    organisation_type: 'organisation_type',
    register_number: 'register_number',
    verified: 'verified',
    founding_year: 'founding_year',
    created_at: 'created_at'
  };

  export type OrganisationsScalarFieldEnum = (typeof OrganisationsScalarFieldEnum)[keyof typeof OrganisationsScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const ConferrencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type ConferrencesScalarFieldEnum = (typeof ConferrencesScalarFieldEnum)[keyof typeof ConferrencesScalarFieldEnum]


  export const SkillsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    skill: 'skill'
  };

  export type SkillsScalarFieldEnum = (typeof SkillsScalarFieldEnum)[keyof typeof SkillsScalarFieldEnum]


  export const PostsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    posted_at: 'posted_at'
  };

  export type PostsScalarFieldEnum = (typeof PostsScalarFieldEnum)[keyof typeof PostsScalarFieldEnum]


  export const PostImageLinksScalarFieldEnum: {
    id: 'id',
    postsId: 'postsId',
    postImageLink: 'postImageLink'
  };

  export type PostImageLinksScalarFieldEnum = (typeof PostImageLinksScalarFieldEnum)[keyof typeof PostImageLinksScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    postsId: 'postsId',
    comment: 'comment',
    commented_at: 'commented_at'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const LikesScalarFieldEnum: {
    id: 'id',
    postsId: 'postsId',
    liked_user_id: 'liked_user_id'
  };

  export type LikesScalarFieldEnum = (typeof LikesScalarFieldEnum)[keyof typeof LikesScalarFieldEnum]


  export const RepostsScalarFieldEnum: {
    id: 'id',
    postsId: 'postsId',
    reposted_user_id: 'reposted_user_id'
  };

  export type RepostsScalarFieldEnum = (typeof RepostsScalarFieldEnum)[keyof typeof RepostsScalarFieldEnum]


  export const SharesScalarFieldEnum: {
    id: 'id',
    postsId: 'postsId',
    shared_user_id: 'shared_user_id'
  };

  export type SharesScalarFieldEnum = (typeof SharesScalarFieldEnum)[keyof typeof SharesScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    question: 'question',
    question_description: 'question_description',
    asked_at: 'asked_at'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const QuestionReferencesScalarFieldEnum: {
    id: 'id',
    questionsId: 'questionsId',
    reference: 'reference'
  };

  export type QuestionReferencesScalarFieldEnum = (typeof QuestionReferencesScalarFieldEnum)[keyof typeof QuestionReferencesScalarFieldEnum]


  export const QuestionCommentsScalarFieldEnum: {
    id: 'id',
    questionsId: 'questionsId',
    comment: 'comment',
    comment_user_id: 'comment_user_id'
  };

  export type QuestionCommentsScalarFieldEnum = (typeof QuestionCommentsScalarFieldEnum)[keyof typeof QuestionCommentsScalarFieldEnum]


  export const AnswersScalarFieldEnum: {
    id: 'id',
    questionsId: 'questionsId',
    answered_user_id: 'answered_user_id',
    answer_description: 'answer_description'
  };

  export type AnswersScalarFieldEnum = (typeof AnswersScalarFieldEnum)[keyof typeof AnswersScalarFieldEnum]


  export const Answer_Image_LinksScalarFieldEnum: {
    id: 'id',
    answersId: 'answersId',
    answer_image_link: 'answer_image_link'
  };

  export type Answer_Image_LinksScalarFieldEnum = (typeof Answer_Image_LinksScalarFieldEnum)[keyof typeof Answer_Image_LinksScalarFieldEnum]


  export const QuestionImageLinksScalarFieldEnum: {
    id: 'id',
    questionsId: 'questionsId'
  };

  export type QuestionImageLinksScalarFieldEnum = (typeof QuestionImageLinksScalarFieldEnum)[keyof typeof QuestionImageLinksScalarFieldEnum]


  export const InsightfulScalarFieldEnum: {
    id: 'id',
    questionsId: 'questionsId',
    insightful_user_id: 'insightful_user_id'
  };

  export type InsightfulScalarFieldEnum = (typeof InsightfulScalarFieldEnum)[keyof typeof InsightfulScalarFieldEnum]


  export const FriendsScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type FriendsScalarFieldEnum = (typeof FriendsScalarFieldEnum)[keyof typeof FriendsScalarFieldEnum]


  export const CertificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    certificateName: 'certificateName',
    issuingOrganisation: 'issuingOrganisation',
    issueDate: 'issueDate',
    descreption: 'descreption',
    certificateURL: 'certificateURL',
    certificateMediaLink: 'certificateMediaLink'
  };

  export type CertificationsScalarFieldEnum = (typeof CertificationsScalarFieldEnum)[keyof typeof CertificationsScalarFieldEnum]


  export const MembershipsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    societyname: 'societyname',
    position: 'position',
    relatedDepartment: 'relatedDepartment',
    membershipId: 'membershipId'
  };

  export type MembershipsScalarFieldEnum = (typeof MembershipsScalarFieldEnum)[keyof typeof MembershipsScalarFieldEnum]


  export const EducationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    schoolName: 'schoolName',
    degree: 'degree',
    department: 'department',
    startDate: 'startDate',
    endDate: 'endDate',
    grade: 'grade'
  };

  export type EducationScalarFieldEnum = (typeof EducationScalarFieldEnum)[keyof typeof EducationScalarFieldEnum]


  export const ProfessionalExperienceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    organisation: 'organisation',
    startDate: 'startDate',
    endDate: 'endDate',
    location: 'location'
  };

  export type ProfessionalExperienceScalarFieldEnum = (typeof ProfessionalExperienceScalarFieldEnum)[keyof typeof ProfessionalExperienceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    category?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    organisation_name?: StringNullableFilter<"User"> | string | null
    specialisation_field_of_study?: StringNullableFilter<"User"> | string | null
    register_number?: StringNullableFilter<"User"> | string | null
    verified?: BoolFilter<"User"> | boolean
    date_of_birth?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    skills?: SkillsListRelationFilter
    posts?: PostsListRelationFilter
    questions?: QuestionsListRelationFilter
    friends?: FriendsListRelationFilter
    certifications?: CertificationsListRelationFilter
    memberships?: MembershipsListRelationFilter
    education?: EducationListRelationFilter
    professionalExperience?: ProfessionalExperienceListRelationFilter
    jobs?: JobsListRelationFilter
    conferrences?: ConferrencesListRelationFilter
    achievementsAwards?: AchievementsAwardsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    organisation_name?: SortOrderInput | SortOrder
    specialisation_field_of_study?: SortOrderInput | SortOrder
    register_number?: SortOrderInput | SortOrder
    verified?: SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    created_at?: SortOrder
    skills?: SkillsOrderByRelationAggregateInput
    posts?: PostsOrderByRelationAggregateInput
    questions?: QuestionsOrderByRelationAggregateInput
    friends?: FriendsOrderByRelationAggregateInput
    certifications?: CertificationsOrderByRelationAggregateInput
    memberships?: MembershipsOrderByRelationAggregateInput
    education?: EducationOrderByRelationAggregateInput
    professionalExperience?: ProfessionalExperienceOrderByRelationAggregateInput
    jobs?: JobsOrderByRelationAggregateInput
    conferrences?: ConferrencesOrderByRelationAggregateInput
    achievementsAwards?: AchievementsAwardsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    category?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    organisation_name?: StringNullableFilter<"User"> | string | null
    specialisation_field_of_study?: StringNullableFilter<"User"> | string | null
    register_number?: StringNullableFilter<"User"> | string | null
    verified?: BoolFilter<"User"> | boolean
    date_of_birth?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    skills?: SkillsListRelationFilter
    posts?: PostsListRelationFilter
    questions?: QuestionsListRelationFilter
    friends?: FriendsListRelationFilter
    certifications?: CertificationsListRelationFilter
    memberships?: MembershipsListRelationFilter
    education?: EducationListRelationFilter
    professionalExperience?: ProfessionalExperienceListRelationFilter
    jobs?: JobsListRelationFilter
    conferrences?: ConferrencesListRelationFilter
    achievementsAwards?: AchievementsAwardsListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    organisation_name?: SortOrderInput | SortOrder
    specialisation_field_of_study?: SortOrderInput | SortOrder
    register_number?: SortOrderInput | SortOrder
    verified?: SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    category?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    organisation_name?: StringNullableWithAggregatesFilter<"User"> | string | null
    specialisation_field_of_study?: StringNullableWithAggregatesFilter<"User"> | string | null
    register_number?: StringNullableWithAggregatesFilter<"User"> | string | null
    verified?: BoolWithAggregatesFilter<"User"> | boolean
    date_of_birth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DoctorsWhereInput = {
    AND?: DoctorsWhereInput | DoctorsWhereInput[]
    OR?: DoctorsWhereInput[]
    NOT?: DoctorsWhereInput | DoctorsWhereInput[]
    id?: IntFilter<"Doctors"> | number
    registrationNo?: StringFilter<"Doctors"> | string
    doctors?: StringFilter<"Doctors"> | string
  }

  export type DoctorsOrderByWithRelationInput = {
    id?: SortOrder
    registrationNo?: SortOrder
    doctors?: SortOrder
  }

  export type DoctorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DoctorsWhereInput | DoctorsWhereInput[]
    OR?: DoctorsWhereInput[]
    NOT?: DoctorsWhereInput | DoctorsWhereInput[]
    registrationNo?: StringFilter<"Doctors"> | string
    doctors?: StringFilter<"Doctors"> | string
  }, "id">

  export type DoctorsOrderByWithAggregationInput = {
    id?: SortOrder
    registrationNo?: SortOrder
    doctors?: SortOrder
    _count?: DoctorsCountOrderByAggregateInput
    _avg?: DoctorsAvgOrderByAggregateInput
    _max?: DoctorsMaxOrderByAggregateInput
    _min?: DoctorsMinOrderByAggregateInput
    _sum?: DoctorsSumOrderByAggregateInput
  }

  export type DoctorsScalarWhereWithAggregatesInput = {
    AND?: DoctorsScalarWhereWithAggregatesInput | DoctorsScalarWhereWithAggregatesInput[]
    OR?: DoctorsScalarWhereWithAggregatesInput[]
    NOT?: DoctorsScalarWhereWithAggregatesInput | DoctorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Doctors"> | number
    registrationNo?: StringWithAggregatesFilter<"Doctors"> | string
    doctors?: StringWithAggregatesFilter<"Doctors"> | string
  }

  export type AchievementsAwardsWhereInput = {
    AND?: AchievementsAwardsWhereInput | AchievementsAwardsWhereInput[]
    OR?: AchievementsAwardsWhereInput[]
    NOT?: AchievementsAwardsWhereInput | AchievementsAwardsWhereInput[]
    id?: IntFilter<"AchievementsAwards"> | number
    userId?: IntNullableFilter<"AchievementsAwards"> | number | null
    awardName?: StringNullableFilter<"AchievementsAwards"> | string | null
    awardedBy?: StringNullableFilter<"AchievementsAwards"> | string | null
    awardedOn?: StringNullableFilter<"AchievementsAwards"> | string | null
    descreption?: StringNullableFilter<"AchievementsAwards"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AchievementsAwardsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    awardName?: SortOrderInput | SortOrder
    awardedBy?: SortOrderInput | SortOrder
    awardedOn?: SortOrderInput | SortOrder
    descreption?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type AchievementsAwardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AchievementsAwardsWhereInput | AchievementsAwardsWhereInput[]
    OR?: AchievementsAwardsWhereInput[]
    NOT?: AchievementsAwardsWhereInput | AchievementsAwardsWhereInput[]
    userId?: IntNullableFilter<"AchievementsAwards"> | number | null
    awardName?: StringNullableFilter<"AchievementsAwards"> | string | null
    awardedBy?: StringNullableFilter<"AchievementsAwards"> | string | null
    awardedOn?: StringNullableFilter<"AchievementsAwards"> | string | null
    descreption?: StringNullableFilter<"AchievementsAwards"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AchievementsAwardsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    awardName?: SortOrderInput | SortOrder
    awardedBy?: SortOrderInput | SortOrder
    awardedOn?: SortOrderInput | SortOrder
    descreption?: SortOrderInput | SortOrder
    _count?: AchievementsAwardsCountOrderByAggregateInput
    _avg?: AchievementsAwardsAvgOrderByAggregateInput
    _max?: AchievementsAwardsMaxOrderByAggregateInput
    _min?: AchievementsAwardsMinOrderByAggregateInput
    _sum?: AchievementsAwardsSumOrderByAggregateInput
  }

  export type AchievementsAwardsScalarWhereWithAggregatesInput = {
    AND?: AchievementsAwardsScalarWhereWithAggregatesInput | AchievementsAwardsScalarWhereWithAggregatesInput[]
    OR?: AchievementsAwardsScalarWhereWithAggregatesInput[]
    NOT?: AchievementsAwardsScalarWhereWithAggregatesInput | AchievementsAwardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AchievementsAwards"> | number
    userId?: IntNullableWithAggregatesFilter<"AchievementsAwards"> | number | null
    awardName?: StringNullableWithAggregatesFilter<"AchievementsAwards"> | string | null
    awardedBy?: StringNullableWithAggregatesFilter<"AchievementsAwards"> | string | null
    awardedOn?: StringNullableWithAggregatesFilter<"AchievementsAwards"> | string | null
    descreption?: StringNullableWithAggregatesFilter<"AchievementsAwards"> | string | null
  }

  export type OrganisationsWhereInput = {
    AND?: OrganisationsWhereInput | OrganisationsWhereInput[]
    OR?: OrganisationsWhereInput[]
    NOT?: OrganisationsWhereInput | OrganisationsWhereInput[]
    id?: IntFilter<"Organisations"> | number
    category?: StringFilter<"Organisations"> | string
    email?: StringFilter<"Organisations"> | string
    password?: StringFilter<"Organisations"> | string
    organisation_name?: StringNullableFilter<"Organisations"> | string | null
    country?: StringNullableFilter<"Organisations"> | string | null
    city?: StringNullableFilter<"Organisations"> | string | null
    organisation_type?: StringNullableFilter<"Organisations"> | string | null
    register_number?: StringNullableFilter<"Organisations"> | string | null
    verified?: BoolFilter<"Organisations"> | boolean
    founding_year?: DateTimeNullableFilter<"Organisations"> | Date | string | null
    created_at?: DateTimeFilter<"Organisations"> | Date | string
  }

  export type OrganisationsOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organisation_name?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    organisation_type?: SortOrderInput | SortOrder
    register_number?: SortOrderInput | SortOrder
    verified?: SortOrder
    founding_year?: SortOrderInput | SortOrder
    created_at?: SortOrder
  }

  export type OrganisationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: OrganisationsWhereInput | OrganisationsWhereInput[]
    OR?: OrganisationsWhereInput[]
    NOT?: OrganisationsWhereInput | OrganisationsWhereInput[]
    category?: StringFilter<"Organisations"> | string
    password?: StringFilter<"Organisations"> | string
    organisation_name?: StringNullableFilter<"Organisations"> | string | null
    country?: StringNullableFilter<"Organisations"> | string | null
    city?: StringNullableFilter<"Organisations"> | string | null
    organisation_type?: StringNullableFilter<"Organisations"> | string | null
    register_number?: StringNullableFilter<"Organisations"> | string | null
    verified?: BoolFilter<"Organisations"> | boolean
    founding_year?: DateTimeNullableFilter<"Organisations"> | Date | string | null
    created_at?: DateTimeFilter<"Organisations"> | Date | string
  }, "id" | "email">

  export type OrganisationsOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organisation_name?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    organisation_type?: SortOrderInput | SortOrder
    register_number?: SortOrderInput | SortOrder
    verified?: SortOrder
    founding_year?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: OrganisationsCountOrderByAggregateInput
    _avg?: OrganisationsAvgOrderByAggregateInput
    _max?: OrganisationsMaxOrderByAggregateInput
    _min?: OrganisationsMinOrderByAggregateInput
    _sum?: OrganisationsSumOrderByAggregateInput
  }

  export type OrganisationsScalarWhereWithAggregatesInput = {
    AND?: OrganisationsScalarWhereWithAggregatesInput | OrganisationsScalarWhereWithAggregatesInput[]
    OR?: OrganisationsScalarWhereWithAggregatesInput[]
    NOT?: OrganisationsScalarWhereWithAggregatesInput | OrganisationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Organisations"> | number
    category?: StringWithAggregatesFilter<"Organisations"> | string
    email?: StringWithAggregatesFilter<"Organisations"> | string
    password?: StringWithAggregatesFilter<"Organisations"> | string
    organisation_name?: StringNullableWithAggregatesFilter<"Organisations"> | string | null
    country?: StringNullableWithAggregatesFilter<"Organisations"> | string | null
    city?: StringNullableWithAggregatesFilter<"Organisations"> | string | null
    organisation_type?: StringNullableWithAggregatesFilter<"Organisations"> | string | null
    register_number?: StringNullableWithAggregatesFilter<"Organisations"> | string | null
    verified?: BoolWithAggregatesFilter<"Organisations"> | boolean
    founding_year?: DateTimeNullableWithAggregatesFilter<"Organisations"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Organisations"> | Date | string
  }

  export type JobsWhereInput = {
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    id?: IntFilter<"Jobs"> | number
    userId?: IntNullableFilter<"Jobs"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type JobsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type JobsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    userId?: IntNullableFilter<"Jobs"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type JobsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: JobsCountOrderByAggregateInput
    _avg?: JobsAvgOrderByAggregateInput
    _max?: JobsMaxOrderByAggregateInput
    _min?: JobsMinOrderByAggregateInput
    _sum?: JobsSumOrderByAggregateInput
  }

  export type JobsScalarWhereWithAggregatesInput = {
    AND?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    OR?: JobsScalarWhereWithAggregatesInput[]
    NOT?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Jobs"> | number
    userId?: IntNullableWithAggregatesFilter<"Jobs"> | number | null
  }

  export type ConferrencesWhereInput = {
    AND?: ConferrencesWhereInput | ConferrencesWhereInput[]
    OR?: ConferrencesWhereInput[]
    NOT?: ConferrencesWhereInput | ConferrencesWhereInput[]
    id?: IntFilter<"Conferrences"> | number
    userId?: IntNullableFilter<"Conferrences"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ConferrencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type ConferrencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConferrencesWhereInput | ConferrencesWhereInput[]
    OR?: ConferrencesWhereInput[]
    NOT?: ConferrencesWhereInput | ConferrencesWhereInput[]
    userId?: IntNullableFilter<"Conferrences"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ConferrencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ConferrencesCountOrderByAggregateInput
    _avg?: ConferrencesAvgOrderByAggregateInput
    _max?: ConferrencesMaxOrderByAggregateInput
    _min?: ConferrencesMinOrderByAggregateInput
    _sum?: ConferrencesSumOrderByAggregateInput
  }

  export type ConferrencesScalarWhereWithAggregatesInput = {
    AND?: ConferrencesScalarWhereWithAggregatesInput | ConferrencesScalarWhereWithAggregatesInput[]
    OR?: ConferrencesScalarWhereWithAggregatesInput[]
    NOT?: ConferrencesScalarWhereWithAggregatesInput | ConferrencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conferrences"> | number
    userId?: IntNullableWithAggregatesFilter<"Conferrences"> | number | null
  }

  export type SkillsWhereInput = {
    AND?: SkillsWhereInput | SkillsWhereInput[]
    OR?: SkillsWhereInput[]
    NOT?: SkillsWhereInput | SkillsWhereInput[]
    id?: IntFilter<"Skills"> | number
    userId?: IntNullableFilter<"Skills"> | number | null
    skill?: StringFilter<"Skills"> | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SkillsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    skill?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type SkillsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SkillsWhereInput | SkillsWhereInput[]
    OR?: SkillsWhereInput[]
    NOT?: SkillsWhereInput | SkillsWhereInput[]
    userId?: IntNullableFilter<"Skills"> | number | null
    skill?: StringFilter<"Skills"> | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SkillsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    skill?: SortOrder
    _count?: SkillsCountOrderByAggregateInput
    _avg?: SkillsAvgOrderByAggregateInput
    _max?: SkillsMaxOrderByAggregateInput
    _min?: SkillsMinOrderByAggregateInput
    _sum?: SkillsSumOrderByAggregateInput
  }

  export type SkillsScalarWhereWithAggregatesInput = {
    AND?: SkillsScalarWhereWithAggregatesInput | SkillsScalarWhereWithAggregatesInput[]
    OR?: SkillsScalarWhereWithAggregatesInput[]
    NOT?: SkillsScalarWhereWithAggregatesInput | SkillsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Skills"> | number
    userId?: IntNullableWithAggregatesFilter<"Skills"> | number | null
    skill?: StringWithAggregatesFilter<"Skills"> | string
  }

  export type PostsWhereInput = {
    AND?: PostsWhereInput | PostsWhereInput[]
    OR?: PostsWhereInput[]
    NOT?: PostsWhereInput | PostsWhereInput[]
    id?: IntFilter<"Posts"> | number
    userId?: IntNullableFilter<"Posts"> | number | null
    title?: StringNullableFilter<"Posts"> | string | null
    description?: StringNullableFilter<"Posts"> | string | null
    posted_at?: DateTimeFilter<"Posts"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    postImageLinks?: PostImageLinksListRelationFilter
    comments?: CommentsListRelationFilter
    likes?: LikesListRelationFilter
    reposts?: RepostsListRelationFilter
    shares?: SharesListRelationFilter
  }

  export type PostsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    posted_at?: SortOrder
    User?: UserOrderByWithRelationInput
    postImageLinks?: PostImageLinksOrderByRelationAggregateInput
    comments?: CommentsOrderByRelationAggregateInput
    likes?: LikesOrderByRelationAggregateInput
    reposts?: RepostsOrderByRelationAggregateInput
    shares?: SharesOrderByRelationAggregateInput
  }

  export type PostsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostsWhereInput | PostsWhereInput[]
    OR?: PostsWhereInput[]
    NOT?: PostsWhereInput | PostsWhereInput[]
    userId?: IntNullableFilter<"Posts"> | number | null
    title?: StringNullableFilter<"Posts"> | string | null
    description?: StringNullableFilter<"Posts"> | string | null
    posted_at?: DateTimeFilter<"Posts"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    postImageLinks?: PostImageLinksListRelationFilter
    comments?: CommentsListRelationFilter
    likes?: LikesListRelationFilter
    reposts?: RepostsListRelationFilter
    shares?: SharesListRelationFilter
  }, "id">

  export type PostsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    posted_at?: SortOrder
    _count?: PostsCountOrderByAggregateInput
    _avg?: PostsAvgOrderByAggregateInput
    _max?: PostsMaxOrderByAggregateInput
    _min?: PostsMinOrderByAggregateInput
    _sum?: PostsSumOrderByAggregateInput
  }

  export type PostsScalarWhereWithAggregatesInput = {
    AND?: PostsScalarWhereWithAggregatesInput | PostsScalarWhereWithAggregatesInput[]
    OR?: PostsScalarWhereWithAggregatesInput[]
    NOT?: PostsScalarWhereWithAggregatesInput | PostsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Posts"> | number
    userId?: IntNullableWithAggregatesFilter<"Posts"> | number | null
    title?: StringNullableWithAggregatesFilter<"Posts"> | string | null
    description?: StringNullableWithAggregatesFilter<"Posts"> | string | null
    posted_at?: DateTimeWithAggregatesFilter<"Posts"> | Date | string
  }

  export type PostImageLinksWhereInput = {
    AND?: PostImageLinksWhereInput | PostImageLinksWhereInput[]
    OR?: PostImageLinksWhereInput[]
    NOT?: PostImageLinksWhereInput | PostImageLinksWhereInput[]
    id?: IntFilter<"PostImageLinks"> | number
    postsId?: IntNullableFilter<"PostImageLinks"> | number | null
    postImageLink?: StringNullableFilter<"PostImageLinks"> | string | null
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }

  export type PostImageLinksOrderByWithRelationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    postImageLink?: SortOrderInput | SortOrder
    Posts?: PostsOrderByWithRelationInput
  }

  export type PostImageLinksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostImageLinksWhereInput | PostImageLinksWhereInput[]
    OR?: PostImageLinksWhereInput[]
    NOT?: PostImageLinksWhereInput | PostImageLinksWhereInput[]
    postsId?: IntNullableFilter<"PostImageLinks"> | number | null
    postImageLink?: StringNullableFilter<"PostImageLinks"> | string | null
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }, "id">

  export type PostImageLinksOrderByWithAggregationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    postImageLink?: SortOrderInput | SortOrder
    _count?: PostImageLinksCountOrderByAggregateInput
    _avg?: PostImageLinksAvgOrderByAggregateInput
    _max?: PostImageLinksMaxOrderByAggregateInput
    _min?: PostImageLinksMinOrderByAggregateInput
    _sum?: PostImageLinksSumOrderByAggregateInput
  }

  export type PostImageLinksScalarWhereWithAggregatesInput = {
    AND?: PostImageLinksScalarWhereWithAggregatesInput | PostImageLinksScalarWhereWithAggregatesInput[]
    OR?: PostImageLinksScalarWhereWithAggregatesInput[]
    NOT?: PostImageLinksScalarWhereWithAggregatesInput | PostImageLinksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PostImageLinks"> | number
    postsId?: IntNullableWithAggregatesFilter<"PostImageLinks"> | number | null
    postImageLink?: StringNullableWithAggregatesFilter<"PostImageLinks"> | string | null
  }

  export type CommentsWhereInput = {
    AND?: CommentsWhereInput | CommentsWhereInput[]
    OR?: CommentsWhereInput[]
    NOT?: CommentsWhereInput | CommentsWhereInput[]
    id?: IntFilter<"Comments"> | number
    postsId?: IntNullableFilter<"Comments"> | number | null
    comment?: StringFilter<"Comments"> | string
    commented_at?: DateTimeFilter<"Comments"> | Date | string
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }

  export type CommentsOrderByWithRelationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    comment?: SortOrder
    commented_at?: SortOrder
    Posts?: PostsOrderByWithRelationInput
  }

  export type CommentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentsWhereInput | CommentsWhereInput[]
    OR?: CommentsWhereInput[]
    NOT?: CommentsWhereInput | CommentsWhereInput[]
    postsId?: IntNullableFilter<"Comments"> | number | null
    comment?: StringFilter<"Comments"> | string
    commented_at?: DateTimeFilter<"Comments"> | Date | string
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }, "id">

  export type CommentsOrderByWithAggregationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    comment?: SortOrder
    commented_at?: SortOrder
    _count?: CommentsCountOrderByAggregateInput
    _avg?: CommentsAvgOrderByAggregateInput
    _max?: CommentsMaxOrderByAggregateInput
    _min?: CommentsMinOrderByAggregateInput
    _sum?: CommentsSumOrderByAggregateInput
  }

  export type CommentsScalarWhereWithAggregatesInput = {
    AND?: CommentsScalarWhereWithAggregatesInput | CommentsScalarWhereWithAggregatesInput[]
    OR?: CommentsScalarWhereWithAggregatesInput[]
    NOT?: CommentsScalarWhereWithAggregatesInput | CommentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comments"> | number
    postsId?: IntNullableWithAggregatesFilter<"Comments"> | number | null
    comment?: StringWithAggregatesFilter<"Comments"> | string
    commented_at?: DateTimeWithAggregatesFilter<"Comments"> | Date | string
  }

  export type LikesWhereInput = {
    AND?: LikesWhereInput | LikesWhereInput[]
    OR?: LikesWhereInput[]
    NOT?: LikesWhereInput | LikesWhereInput[]
    id?: IntFilter<"Likes"> | number
    postsId?: IntNullableFilter<"Likes"> | number | null
    liked_user_id?: IntNullableFilter<"Likes"> | number | null
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }

  export type LikesOrderByWithRelationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    liked_user_id?: SortOrderInput | SortOrder
    Posts?: PostsOrderByWithRelationInput
  }

  export type LikesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LikesWhereInput | LikesWhereInput[]
    OR?: LikesWhereInput[]
    NOT?: LikesWhereInput | LikesWhereInput[]
    postsId?: IntNullableFilter<"Likes"> | number | null
    liked_user_id?: IntNullableFilter<"Likes"> | number | null
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }, "id">

  export type LikesOrderByWithAggregationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    liked_user_id?: SortOrderInput | SortOrder
    _count?: LikesCountOrderByAggregateInput
    _avg?: LikesAvgOrderByAggregateInput
    _max?: LikesMaxOrderByAggregateInput
    _min?: LikesMinOrderByAggregateInput
    _sum?: LikesSumOrderByAggregateInput
  }

  export type LikesScalarWhereWithAggregatesInput = {
    AND?: LikesScalarWhereWithAggregatesInput | LikesScalarWhereWithAggregatesInput[]
    OR?: LikesScalarWhereWithAggregatesInput[]
    NOT?: LikesScalarWhereWithAggregatesInput | LikesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Likes"> | number
    postsId?: IntNullableWithAggregatesFilter<"Likes"> | number | null
    liked_user_id?: IntNullableWithAggregatesFilter<"Likes"> | number | null
  }

  export type RepostsWhereInput = {
    AND?: RepostsWhereInput | RepostsWhereInput[]
    OR?: RepostsWhereInput[]
    NOT?: RepostsWhereInput | RepostsWhereInput[]
    id?: IntFilter<"Reposts"> | number
    postsId?: IntNullableFilter<"Reposts"> | number | null
    reposted_user_id?: IntNullableFilter<"Reposts"> | number | null
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }

  export type RepostsOrderByWithRelationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    reposted_user_id?: SortOrderInput | SortOrder
    Posts?: PostsOrderByWithRelationInput
  }

  export type RepostsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RepostsWhereInput | RepostsWhereInput[]
    OR?: RepostsWhereInput[]
    NOT?: RepostsWhereInput | RepostsWhereInput[]
    postsId?: IntNullableFilter<"Reposts"> | number | null
    reposted_user_id?: IntNullableFilter<"Reposts"> | number | null
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }, "id">

  export type RepostsOrderByWithAggregationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    reposted_user_id?: SortOrderInput | SortOrder
    _count?: RepostsCountOrderByAggregateInput
    _avg?: RepostsAvgOrderByAggregateInput
    _max?: RepostsMaxOrderByAggregateInput
    _min?: RepostsMinOrderByAggregateInput
    _sum?: RepostsSumOrderByAggregateInput
  }

  export type RepostsScalarWhereWithAggregatesInput = {
    AND?: RepostsScalarWhereWithAggregatesInput | RepostsScalarWhereWithAggregatesInput[]
    OR?: RepostsScalarWhereWithAggregatesInput[]
    NOT?: RepostsScalarWhereWithAggregatesInput | RepostsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reposts"> | number
    postsId?: IntNullableWithAggregatesFilter<"Reposts"> | number | null
    reposted_user_id?: IntNullableWithAggregatesFilter<"Reposts"> | number | null
  }

  export type SharesWhereInput = {
    AND?: SharesWhereInput | SharesWhereInput[]
    OR?: SharesWhereInput[]
    NOT?: SharesWhereInput | SharesWhereInput[]
    id?: IntFilter<"Shares"> | number
    postsId?: IntNullableFilter<"Shares"> | number | null
    shared_user_id?: IntNullableFilter<"Shares"> | number | null
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }

  export type SharesOrderByWithRelationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    shared_user_id?: SortOrderInput | SortOrder
    Posts?: PostsOrderByWithRelationInput
  }

  export type SharesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SharesWhereInput | SharesWhereInput[]
    OR?: SharesWhereInput[]
    NOT?: SharesWhereInput | SharesWhereInput[]
    postsId?: IntNullableFilter<"Shares"> | number | null
    shared_user_id?: IntNullableFilter<"Shares"> | number | null
    Posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
  }, "id">

  export type SharesOrderByWithAggregationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    shared_user_id?: SortOrderInput | SortOrder
    _count?: SharesCountOrderByAggregateInput
    _avg?: SharesAvgOrderByAggregateInput
    _max?: SharesMaxOrderByAggregateInput
    _min?: SharesMinOrderByAggregateInput
    _sum?: SharesSumOrderByAggregateInput
  }

  export type SharesScalarWhereWithAggregatesInput = {
    AND?: SharesScalarWhereWithAggregatesInput | SharesScalarWhereWithAggregatesInput[]
    OR?: SharesScalarWhereWithAggregatesInput[]
    NOT?: SharesScalarWhereWithAggregatesInput | SharesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shares"> | number
    postsId?: IntNullableWithAggregatesFilter<"Shares"> | number | null
    shared_user_id?: IntNullableWithAggregatesFilter<"Shares"> | number | null
  }

  export type QuestionsWhereInput = {
    AND?: QuestionsWhereInput | QuestionsWhereInput[]
    OR?: QuestionsWhereInput[]
    NOT?: QuestionsWhereInput | QuestionsWhereInput[]
    id?: IntFilter<"Questions"> | number
    userId?: IntNullableFilter<"Questions"> | number | null
    question?: StringFilter<"Questions"> | string
    question_description?: StringFilter<"Questions"> | string
    asked_at?: DateTimeFilter<"Questions"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    question_image_links?: QuestionImageLinksListRelationFilter
    insightful?: InsightfulListRelationFilter
    answers?: AnswersListRelationFilter
    questionComments?: QuestionCommentsListRelationFilter
    questionReferences?: QuestionReferencesListRelationFilter
  }

  export type QuestionsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    question?: SortOrder
    question_description?: SortOrder
    asked_at?: SortOrder
    User?: UserOrderByWithRelationInput
    question_image_links?: QuestionImageLinksOrderByRelationAggregateInput
    insightful?: InsightfulOrderByRelationAggregateInput
    answers?: AnswersOrderByRelationAggregateInput
    questionComments?: QuestionCommentsOrderByRelationAggregateInput
    questionReferences?: QuestionReferencesOrderByRelationAggregateInput
  }

  export type QuestionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionsWhereInput | QuestionsWhereInput[]
    OR?: QuestionsWhereInput[]
    NOT?: QuestionsWhereInput | QuestionsWhereInput[]
    userId?: IntNullableFilter<"Questions"> | number | null
    question?: StringFilter<"Questions"> | string
    question_description?: StringFilter<"Questions"> | string
    asked_at?: DateTimeFilter<"Questions"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    question_image_links?: QuestionImageLinksListRelationFilter
    insightful?: InsightfulListRelationFilter
    answers?: AnswersListRelationFilter
    questionComments?: QuestionCommentsListRelationFilter
    questionReferences?: QuestionReferencesListRelationFilter
  }, "id">

  export type QuestionsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    question?: SortOrder
    question_description?: SortOrder
    asked_at?: SortOrder
    _count?: QuestionsCountOrderByAggregateInput
    _avg?: QuestionsAvgOrderByAggregateInput
    _max?: QuestionsMaxOrderByAggregateInput
    _min?: QuestionsMinOrderByAggregateInput
    _sum?: QuestionsSumOrderByAggregateInput
  }

  export type QuestionsScalarWhereWithAggregatesInput = {
    AND?: QuestionsScalarWhereWithAggregatesInput | QuestionsScalarWhereWithAggregatesInput[]
    OR?: QuestionsScalarWhereWithAggregatesInput[]
    NOT?: QuestionsScalarWhereWithAggregatesInput | QuestionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Questions"> | number
    userId?: IntNullableWithAggregatesFilter<"Questions"> | number | null
    question?: StringWithAggregatesFilter<"Questions"> | string
    question_description?: StringWithAggregatesFilter<"Questions"> | string
    asked_at?: DateTimeWithAggregatesFilter<"Questions"> | Date | string
  }

  export type QuestionReferencesWhereInput = {
    AND?: QuestionReferencesWhereInput | QuestionReferencesWhereInput[]
    OR?: QuestionReferencesWhereInput[]
    NOT?: QuestionReferencesWhereInput | QuestionReferencesWhereInput[]
    id?: IntFilter<"QuestionReferences"> | number
    questionsId?: IntNullableFilter<"QuestionReferences"> | number | null
    reference?: StringNullableFilter<"QuestionReferences"> | string | null
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
  }

  export type QuestionReferencesOrderByWithRelationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    Questions?: QuestionsOrderByWithRelationInput
  }

  export type QuestionReferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionReferencesWhereInput | QuestionReferencesWhereInput[]
    OR?: QuestionReferencesWhereInput[]
    NOT?: QuestionReferencesWhereInput | QuestionReferencesWhereInput[]
    questionsId?: IntNullableFilter<"QuestionReferences"> | number | null
    reference?: StringNullableFilter<"QuestionReferences"> | string | null
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
  }, "id">

  export type QuestionReferencesOrderByWithAggregationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    _count?: QuestionReferencesCountOrderByAggregateInput
    _avg?: QuestionReferencesAvgOrderByAggregateInput
    _max?: QuestionReferencesMaxOrderByAggregateInput
    _min?: QuestionReferencesMinOrderByAggregateInput
    _sum?: QuestionReferencesSumOrderByAggregateInput
  }

  export type QuestionReferencesScalarWhereWithAggregatesInput = {
    AND?: QuestionReferencesScalarWhereWithAggregatesInput | QuestionReferencesScalarWhereWithAggregatesInput[]
    OR?: QuestionReferencesScalarWhereWithAggregatesInput[]
    NOT?: QuestionReferencesScalarWhereWithAggregatesInput | QuestionReferencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuestionReferences"> | number
    questionsId?: IntNullableWithAggregatesFilter<"QuestionReferences"> | number | null
    reference?: StringNullableWithAggregatesFilter<"QuestionReferences"> | string | null
  }

  export type QuestionCommentsWhereInput = {
    AND?: QuestionCommentsWhereInput | QuestionCommentsWhereInput[]
    OR?: QuestionCommentsWhereInput[]
    NOT?: QuestionCommentsWhereInput | QuestionCommentsWhereInput[]
    id?: IntFilter<"QuestionComments"> | number
    questionsId?: IntNullableFilter<"QuestionComments"> | number | null
    comment?: StringFilter<"QuestionComments"> | string
    comment_user_id?: IntFilter<"QuestionComments"> | number
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
  }

  export type QuestionCommentsOrderByWithRelationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    comment?: SortOrder
    comment_user_id?: SortOrder
    Questions?: QuestionsOrderByWithRelationInput
  }

  export type QuestionCommentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionCommentsWhereInput | QuestionCommentsWhereInput[]
    OR?: QuestionCommentsWhereInput[]
    NOT?: QuestionCommentsWhereInput | QuestionCommentsWhereInput[]
    questionsId?: IntNullableFilter<"QuestionComments"> | number | null
    comment?: StringFilter<"QuestionComments"> | string
    comment_user_id?: IntFilter<"QuestionComments"> | number
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
  }, "id">

  export type QuestionCommentsOrderByWithAggregationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    comment?: SortOrder
    comment_user_id?: SortOrder
    _count?: QuestionCommentsCountOrderByAggregateInput
    _avg?: QuestionCommentsAvgOrderByAggregateInput
    _max?: QuestionCommentsMaxOrderByAggregateInput
    _min?: QuestionCommentsMinOrderByAggregateInput
    _sum?: QuestionCommentsSumOrderByAggregateInput
  }

  export type QuestionCommentsScalarWhereWithAggregatesInput = {
    AND?: QuestionCommentsScalarWhereWithAggregatesInput | QuestionCommentsScalarWhereWithAggregatesInput[]
    OR?: QuestionCommentsScalarWhereWithAggregatesInput[]
    NOT?: QuestionCommentsScalarWhereWithAggregatesInput | QuestionCommentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuestionComments"> | number
    questionsId?: IntNullableWithAggregatesFilter<"QuestionComments"> | number | null
    comment?: StringWithAggregatesFilter<"QuestionComments"> | string
    comment_user_id?: IntWithAggregatesFilter<"QuestionComments"> | number
  }

  export type AnswersWhereInput = {
    AND?: AnswersWhereInput | AnswersWhereInput[]
    OR?: AnswersWhereInput[]
    NOT?: AnswersWhereInput | AnswersWhereInput[]
    id?: IntFilter<"Answers"> | number
    questionsId?: IntNullableFilter<"Answers"> | number | null
    answered_user_id?: StringFilter<"Answers"> | string
    answer_description?: StringFilter<"Answers"> | string
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
    answer_image_links?: Answer_Image_LinksListRelationFilter
  }

  export type AnswersOrderByWithRelationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    answered_user_id?: SortOrder
    answer_description?: SortOrder
    Questions?: QuestionsOrderByWithRelationInput
    answer_image_links?: Answer_Image_LinksOrderByRelationAggregateInput
  }

  export type AnswersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnswersWhereInput | AnswersWhereInput[]
    OR?: AnswersWhereInput[]
    NOT?: AnswersWhereInput | AnswersWhereInput[]
    questionsId?: IntNullableFilter<"Answers"> | number | null
    answered_user_id?: StringFilter<"Answers"> | string
    answer_description?: StringFilter<"Answers"> | string
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
    answer_image_links?: Answer_Image_LinksListRelationFilter
  }, "id">

  export type AnswersOrderByWithAggregationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    answered_user_id?: SortOrder
    answer_description?: SortOrder
    _count?: AnswersCountOrderByAggregateInput
    _avg?: AnswersAvgOrderByAggregateInput
    _max?: AnswersMaxOrderByAggregateInput
    _min?: AnswersMinOrderByAggregateInput
    _sum?: AnswersSumOrderByAggregateInput
  }

  export type AnswersScalarWhereWithAggregatesInput = {
    AND?: AnswersScalarWhereWithAggregatesInput | AnswersScalarWhereWithAggregatesInput[]
    OR?: AnswersScalarWhereWithAggregatesInput[]
    NOT?: AnswersScalarWhereWithAggregatesInput | AnswersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Answers"> | number
    questionsId?: IntNullableWithAggregatesFilter<"Answers"> | number | null
    answered_user_id?: StringWithAggregatesFilter<"Answers"> | string
    answer_description?: StringWithAggregatesFilter<"Answers"> | string
  }

  export type Answer_Image_LinksWhereInput = {
    AND?: Answer_Image_LinksWhereInput | Answer_Image_LinksWhereInput[]
    OR?: Answer_Image_LinksWhereInput[]
    NOT?: Answer_Image_LinksWhereInput | Answer_Image_LinksWhereInput[]
    id?: IntFilter<"Answer_Image_Links"> | number
    answersId?: IntNullableFilter<"Answer_Image_Links"> | number | null
    answer_image_link?: StringNullableFilter<"Answer_Image_Links"> | string | null
    Answers?: XOR<AnswersNullableScalarRelationFilter, AnswersWhereInput> | null
  }

  export type Answer_Image_LinksOrderByWithRelationInput = {
    id?: SortOrder
    answersId?: SortOrderInput | SortOrder
    answer_image_link?: SortOrderInput | SortOrder
    Answers?: AnswersOrderByWithRelationInput
  }

  export type Answer_Image_LinksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Answer_Image_LinksWhereInput | Answer_Image_LinksWhereInput[]
    OR?: Answer_Image_LinksWhereInput[]
    NOT?: Answer_Image_LinksWhereInput | Answer_Image_LinksWhereInput[]
    answersId?: IntNullableFilter<"Answer_Image_Links"> | number | null
    answer_image_link?: StringNullableFilter<"Answer_Image_Links"> | string | null
    Answers?: XOR<AnswersNullableScalarRelationFilter, AnswersWhereInput> | null
  }, "id">

  export type Answer_Image_LinksOrderByWithAggregationInput = {
    id?: SortOrder
    answersId?: SortOrderInput | SortOrder
    answer_image_link?: SortOrderInput | SortOrder
    _count?: Answer_Image_LinksCountOrderByAggregateInput
    _avg?: Answer_Image_LinksAvgOrderByAggregateInput
    _max?: Answer_Image_LinksMaxOrderByAggregateInput
    _min?: Answer_Image_LinksMinOrderByAggregateInput
    _sum?: Answer_Image_LinksSumOrderByAggregateInput
  }

  export type Answer_Image_LinksScalarWhereWithAggregatesInput = {
    AND?: Answer_Image_LinksScalarWhereWithAggregatesInput | Answer_Image_LinksScalarWhereWithAggregatesInput[]
    OR?: Answer_Image_LinksScalarWhereWithAggregatesInput[]
    NOT?: Answer_Image_LinksScalarWhereWithAggregatesInput | Answer_Image_LinksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Answer_Image_Links"> | number
    answersId?: IntNullableWithAggregatesFilter<"Answer_Image_Links"> | number | null
    answer_image_link?: StringNullableWithAggregatesFilter<"Answer_Image_Links"> | string | null
  }

  export type QuestionImageLinksWhereInput = {
    AND?: QuestionImageLinksWhereInput | QuestionImageLinksWhereInput[]
    OR?: QuestionImageLinksWhereInput[]
    NOT?: QuestionImageLinksWhereInput | QuestionImageLinksWhereInput[]
    id?: IntFilter<"QuestionImageLinks"> | number
    questionsId?: IntNullableFilter<"QuestionImageLinks"> | number | null
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
  }

  export type QuestionImageLinksOrderByWithRelationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    Questions?: QuestionsOrderByWithRelationInput
  }

  export type QuestionImageLinksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionImageLinksWhereInput | QuestionImageLinksWhereInput[]
    OR?: QuestionImageLinksWhereInput[]
    NOT?: QuestionImageLinksWhereInput | QuestionImageLinksWhereInput[]
    questionsId?: IntNullableFilter<"QuestionImageLinks"> | number | null
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
  }, "id">

  export type QuestionImageLinksOrderByWithAggregationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    _count?: QuestionImageLinksCountOrderByAggregateInput
    _avg?: QuestionImageLinksAvgOrderByAggregateInput
    _max?: QuestionImageLinksMaxOrderByAggregateInput
    _min?: QuestionImageLinksMinOrderByAggregateInput
    _sum?: QuestionImageLinksSumOrderByAggregateInput
  }

  export type QuestionImageLinksScalarWhereWithAggregatesInput = {
    AND?: QuestionImageLinksScalarWhereWithAggregatesInput | QuestionImageLinksScalarWhereWithAggregatesInput[]
    OR?: QuestionImageLinksScalarWhereWithAggregatesInput[]
    NOT?: QuestionImageLinksScalarWhereWithAggregatesInput | QuestionImageLinksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuestionImageLinks"> | number
    questionsId?: IntNullableWithAggregatesFilter<"QuestionImageLinks"> | number | null
  }

  export type InsightfulWhereInput = {
    AND?: InsightfulWhereInput | InsightfulWhereInput[]
    OR?: InsightfulWhereInput[]
    NOT?: InsightfulWhereInput | InsightfulWhereInput[]
    id?: IntFilter<"Insightful"> | number
    questionsId?: IntNullableFilter<"Insightful"> | number | null
    insightful_user_id?: StringNullableFilter<"Insightful"> | string | null
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
  }

  export type InsightfulOrderByWithRelationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    insightful_user_id?: SortOrderInput | SortOrder
    Questions?: QuestionsOrderByWithRelationInput
  }

  export type InsightfulWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InsightfulWhereInput | InsightfulWhereInput[]
    OR?: InsightfulWhereInput[]
    NOT?: InsightfulWhereInput | InsightfulWhereInput[]
    questionsId?: IntNullableFilter<"Insightful"> | number | null
    insightful_user_id?: StringNullableFilter<"Insightful"> | string | null
    Questions?: XOR<QuestionsNullableScalarRelationFilter, QuestionsWhereInput> | null
  }, "id">

  export type InsightfulOrderByWithAggregationInput = {
    id?: SortOrder
    questionsId?: SortOrderInput | SortOrder
    insightful_user_id?: SortOrderInput | SortOrder
    _count?: InsightfulCountOrderByAggregateInput
    _avg?: InsightfulAvgOrderByAggregateInput
    _max?: InsightfulMaxOrderByAggregateInput
    _min?: InsightfulMinOrderByAggregateInput
    _sum?: InsightfulSumOrderByAggregateInput
  }

  export type InsightfulScalarWhereWithAggregatesInput = {
    AND?: InsightfulScalarWhereWithAggregatesInput | InsightfulScalarWhereWithAggregatesInput[]
    OR?: InsightfulScalarWhereWithAggregatesInput[]
    NOT?: InsightfulScalarWhereWithAggregatesInput | InsightfulScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Insightful"> | number
    questionsId?: IntNullableWithAggregatesFilter<"Insightful"> | number | null
    insightful_user_id?: StringNullableWithAggregatesFilter<"Insightful"> | string | null
  }

  export type FriendsWhereInput = {
    AND?: FriendsWhereInput | FriendsWhereInput[]
    OR?: FriendsWhereInput[]
    NOT?: FriendsWhereInput | FriendsWhereInput[]
    id?: IntFilter<"Friends"> | number
    userId?: IntNullableFilter<"Friends"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type FriendsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type FriendsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FriendsWhereInput | FriendsWhereInput[]
    OR?: FriendsWhereInput[]
    NOT?: FriendsWhereInput | FriendsWhereInput[]
    userId?: IntNullableFilter<"Friends"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type FriendsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: FriendsCountOrderByAggregateInput
    _avg?: FriendsAvgOrderByAggregateInput
    _max?: FriendsMaxOrderByAggregateInput
    _min?: FriendsMinOrderByAggregateInput
    _sum?: FriendsSumOrderByAggregateInput
  }

  export type FriendsScalarWhereWithAggregatesInput = {
    AND?: FriendsScalarWhereWithAggregatesInput | FriendsScalarWhereWithAggregatesInput[]
    OR?: FriendsScalarWhereWithAggregatesInput[]
    NOT?: FriendsScalarWhereWithAggregatesInput | FriendsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Friends"> | number
    userId?: IntNullableWithAggregatesFilter<"Friends"> | number | null
  }

  export type CertificationsWhereInput = {
    AND?: CertificationsWhereInput | CertificationsWhereInput[]
    OR?: CertificationsWhereInput[]
    NOT?: CertificationsWhereInput | CertificationsWhereInput[]
    id?: IntFilter<"Certifications"> | number
    userId?: IntNullableFilter<"Certifications"> | number | null
    certificateName?: StringNullableFilter<"Certifications"> | string | null
    issuingOrganisation?: StringNullableFilter<"Certifications"> | string | null
    issueDate?: StringNullableFilter<"Certifications"> | string | null
    descreption?: StringNullableFilter<"Certifications"> | string | null
    certificateURL?: StringNullableFilter<"Certifications"> | string | null
    certificateMediaLink?: StringNullableFilter<"Certifications"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CertificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    certificateName?: SortOrderInput | SortOrder
    issuingOrganisation?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    descreption?: SortOrderInput | SortOrder
    certificateURL?: SortOrderInput | SortOrder
    certificateMediaLink?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type CertificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CertificationsWhereInput | CertificationsWhereInput[]
    OR?: CertificationsWhereInput[]
    NOT?: CertificationsWhereInput | CertificationsWhereInput[]
    userId?: IntNullableFilter<"Certifications"> | number | null
    certificateName?: StringNullableFilter<"Certifications"> | string | null
    issuingOrganisation?: StringNullableFilter<"Certifications"> | string | null
    issueDate?: StringNullableFilter<"Certifications"> | string | null
    descreption?: StringNullableFilter<"Certifications"> | string | null
    certificateURL?: StringNullableFilter<"Certifications"> | string | null
    certificateMediaLink?: StringNullableFilter<"Certifications"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CertificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    certificateName?: SortOrderInput | SortOrder
    issuingOrganisation?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    descreption?: SortOrderInput | SortOrder
    certificateURL?: SortOrderInput | SortOrder
    certificateMediaLink?: SortOrderInput | SortOrder
    _count?: CertificationsCountOrderByAggregateInput
    _avg?: CertificationsAvgOrderByAggregateInput
    _max?: CertificationsMaxOrderByAggregateInput
    _min?: CertificationsMinOrderByAggregateInput
    _sum?: CertificationsSumOrderByAggregateInput
  }

  export type CertificationsScalarWhereWithAggregatesInput = {
    AND?: CertificationsScalarWhereWithAggregatesInput | CertificationsScalarWhereWithAggregatesInput[]
    OR?: CertificationsScalarWhereWithAggregatesInput[]
    NOT?: CertificationsScalarWhereWithAggregatesInput | CertificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Certifications"> | number
    userId?: IntNullableWithAggregatesFilter<"Certifications"> | number | null
    certificateName?: StringNullableWithAggregatesFilter<"Certifications"> | string | null
    issuingOrganisation?: StringNullableWithAggregatesFilter<"Certifications"> | string | null
    issueDate?: StringNullableWithAggregatesFilter<"Certifications"> | string | null
    descreption?: StringNullableWithAggregatesFilter<"Certifications"> | string | null
    certificateURL?: StringNullableWithAggregatesFilter<"Certifications"> | string | null
    certificateMediaLink?: StringNullableWithAggregatesFilter<"Certifications"> | string | null
  }

  export type MembershipsWhereInput = {
    AND?: MembershipsWhereInput | MembershipsWhereInput[]
    OR?: MembershipsWhereInput[]
    NOT?: MembershipsWhereInput | MembershipsWhereInput[]
    id?: IntFilter<"Memberships"> | number
    userId?: IntNullableFilter<"Memberships"> | number | null
    societyname?: StringNullableFilter<"Memberships"> | string | null
    position?: StringNullableFilter<"Memberships"> | string | null
    relatedDepartment?: StringNullableFilter<"Memberships"> | string | null
    membershipId?: StringNullableFilter<"Memberships"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MembershipsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    societyname?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    relatedDepartment?: SortOrderInput | SortOrder
    membershipId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type MembershipsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MembershipsWhereInput | MembershipsWhereInput[]
    OR?: MembershipsWhereInput[]
    NOT?: MembershipsWhereInput | MembershipsWhereInput[]
    userId?: IntNullableFilter<"Memberships"> | number | null
    societyname?: StringNullableFilter<"Memberships"> | string | null
    position?: StringNullableFilter<"Memberships"> | string | null
    relatedDepartment?: StringNullableFilter<"Memberships"> | string | null
    membershipId?: StringNullableFilter<"Memberships"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type MembershipsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    societyname?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    relatedDepartment?: SortOrderInput | SortOrder
    membershipId?: SortOrderInput | SortOrder
    _count?: MembershipsCountOrderByAggregateInput
    _avg?: MembershipsAvgOrderByAggregateInput
    _max?: MembershipsMaxOrderByAggregateInput
    _min?: MembershipsMinOrderByAggregateInput
    _sum?: MembershipsSumOrderByAggregateInput
  }

  export type MembershipsScalarWhereWithAggregatesInput = {
    AND?: MembershipsScalarWhereWithAggregatesInput | MembershipsScalarWhereWithAggregatesInput[]
    OR?: MembershipsScalarWhereWithAggregatesInput[]
    NOT?: MembershipsScalarWhereWithAggregatesInput | MembershipsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Memberships"> | number
    userId?: IntNullableWithAggregatesFilter<"Memberships"> | number | null
    societyname?: StringNullableWithAggregatesFilter<"Memberships"> | string | null
    position?: StringNullableWithAggregatesFilter<"Memberships"> | string | null
    relatedDepartment?: StringNullableWithAggregatesFilter<"Memberships"> | string | null
    membershipId?: StringNullableWithAggregatesFilter<"Memberships"> | string | null
  }

  export type EducationWhereInput = {
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    id?: IntFilter<"Education"> | number
    userId?: IntNullableFilter<"Education"> | number | null
    schoolName?: StringNullableFilter<"Education"> | string | null
    degree?: StringNullableFilter<"Education"> | string | null
    department?: StringNullableFilter<"Education"> | string | null
    startDate?: StringNullableFilter<"Education"> | string | null
    endDate?: StringNullableFilter<"Education"> | string | null
    grade?: StringNullableFilter<"Education"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type EducationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    schoolName?: SortOrderInput | SortOrder
    degree?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type EducationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    userId?: IntNullableFilter<"Education"> | number | null
    schoolName?: StringNullableFilter<"Education"> | string | null
    degree?: StringNullableFilter<"Education"> | string | null
    department?: StringNullableFilter<"Education"> | string | null
    startDate?: StringNullableFilter<"Education"> | string | null
    endDate?: StringNullableFilter<"Education"> | string | null
    grade?: StringNullableFilter<"Education"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type EducationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    schoolName?: SortOrderInput | SortOrder
    degree?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    _count?: EducationCountOrderByAggregateInput
    _avg?: EducationAvgOrderByAggregateInput
    _max?: EducationMaxOrderByAggregateInput
    _min?: EducationMinOrderByAggregateInput
    _sum?: EducationSumOrderByAggregateInput
  }

  export type EducationScalarWhereWithAggregatesInput = {
    AND?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    OR?: EducationScalarWhereWithAggregatesInput[]
    NOT?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Education"> | number
    userId?: IntNullableWithAggregatesFilter<"Education"> | number | null
    schoolName?: StringNullableWithAggregatesFilter<"Education"> | string | null
    degree?: StringNullableWithAggregatesFilter<"Education"> | string | null
    department?: StringNullableWithAggregatesFilter<"Education"> | string | null
    startDate?: StringNullableWithAggregatesFilter<"Education"> | string | null
    endDate?: StringNullableWithAggregatesFilter<"Education"> | string | null
    grade?: StringNullableWithAggregatesFilter<"Education"> | string | null
  }

  export type ProfessionalExperienceWhereInput = {
    AND?: ProfessionalExperienceWhereInput | ProfessionalExperienceWhereInput[]
    OR?: ProfessionalExperienceWhereInput[]
    NOT?: ProfessionalExperienceWhereInput | ProfessionalExperienceWhereInput[]
    id?: IntFilter<"ProfessionalExperience"> | number
    userId?: IntNullableFilter<"ProfessionalExperience"> | number | null
    title?: StringNullableFilter<"ProfessionalExperience"> | string | null
    organisation?: StringNullableFilter<"ProfessionalExperience"> | string | null
    startDate?: StringNullableFilter<"ProfessionalExperience"> | string | null
    endDate?: StringNullableFilter<"ProfessionalExperience"> | string | null
    location?: StringNullableFilter<"ProfessionalExperience"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ProfessionalExperienceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    organisation?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type ProfessionalExperienceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfessionalExperienceWhereInput | ProfessionalExperienceWhereInput[]
    OR?: ProfessionalExperienceWhereInput[]
    NOT?: ProfessionalExperienceWhereInput | ProfessionalExperienceWhereInput[]
    userId?: IntNullableFilter<"ProfessionalExperience"> | number | null
    title?: StringNullableFilter<"ProfessionalExperience"> | string | null
    organisation?: StringNullableFilter<"ProfessionalExperience"> | string | null
    startDate?: StringNullableFilter<"ProfessionalExperience"> | string | null
    endDate?: StringNullableFilter<"ProfessionalExperience"> | string | null
    location?: StringNullableFilter<"ProfessionalExperience"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProfessionalExperienceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    organisation?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    _count?: ProfessionalExperienceCountOrderByAggregateInput
    _avg?: ProfessionalExperienceAvgOrderByAggregateInput
    _max?: ProfessionalExperienceMaxOrderByAggregateInput
    _min?: ProfessionalExperienceMinOrderByAggregateInput
    _sum?: ProfessionalExperienceSumOrderByAggregateInput
  }

  export type ProfessionalExperienceScalarWhereWithAggregatesInput = {
    AND?: ProfessionalExperienceScalarWhereWithAggregatesInput | ProfessionalExperienceScalarWhereWithAggregatesInput[]
    OR?: ProfessionalExperienceScalarWhereWithAggregatesInput[]
    NOT?: ProfessionalExperienceScalarWhereWithAggregatesInput | ProfessionalExperienceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProfessionalExperience"> | number
    userId?: IntNullableWithAggregatesFilter<"ProfessionalExperience"> | number | null
    title?: StringNullableWithAggregatesFilter<"ProfessionalExperience"> | string | null
    organisation?: StringNullableWithAggregatesFilter<"ProfessionalExperience"> | string | null
    startDate?: StringNullableWithAggregatesFilter<"ProfessionalExperience"> | string | null
    endDate?: StringNullableWithAggregatesFilter<"ProfessionalExperience"> | string | null
    location?: StringNullableWithAggregatesFilter<"ProfessionalExperience"> | string | null
  }

  export type UserCreateInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorsCreateInput = {
    registrationNo: string
    doctors: string
  }

  export type DoctorsUncheckedCreateInput = {
    id?: number
    registrationNo: string
    doctors: string
  }

  export type DoctorsUpdateInput = {
    registrationNo?: StringFieldUpdateOperationsInput | string
    doctors?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    registrationNo?: StringFieldUpdateOperationsInput | string
    doctors?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorsCreateManyInput = {
    id?: number
    registrationNo: string
    doctors: string
  }

  export type DoctorsUpdateManyMutationInput = {
    registrationNo?: StringFieldUpdateOperationsInput | string
    doctors?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    registrationNo?: StringFieldUpdateOperationsInput | string
    doctors?: StringFieldUpdateOperationsInput | string
  }

  export type AchievementsAwardsCreateInput = {
    awardName?: string | null
    awardedBy?: string | null
    awardedOn?: string | null
    descreption?: string | null
    User?: UserCreateNestedOneWithoutAchievementsAwardsInput
  }

  export type AchievementsAwardsUncheckedCreateInput = {
    id?: number
    userId?: number | null
    awardName?: string | null
    awardedBy?: string | null
    awardedOn?: string | null
    descreption?: string | null
  }

  export type AchievementsAwardsUpdateInput = {
    awardName?: NullableStringFieldUpdateOperationsInput | string | null
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutAchievementsAwardsNestedInput
  }

  export type AchievementsAwardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    awardName?: NullableStringFieldUpdateOperationsInput | string | null
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AchievementsAwardsCreateManyInput = {
    id?: number
    userId?: number | null
    awardName?: string | null
    awardedBy?: string | null
    awardedOn?: string | null
    descreption?: string | null
  }

  export type AchievementsAwardsUpdateManyMutationInput = {
    awardName?: NullableStringFieldUpdateOperationsInput | string | null
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AchievementsAwardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    awardName?: NullableStringFieldUpdateOperationsInput | string | null
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganisationsCreateInput = {
    category: string
    email: string
    password: string
    organisation_name?: string | null
    country?: string | null
    city?: string | null
    organisation_type?: string | null
    register_number?: string | null
    verified?: boolean
    founding_year?: Date | string | null
    created_at?: Date | string
  }

  export type OrganisationsUncheckedCreateInput = {
    id?: number
    category: string
    email: string
    password: string
    organisation_name?: string | null
    country?: string | null
    city?: string | null
    organisation_type?: string | null
    register_number?: string | null
    verified?: boolean
    founding_year?: Date | string | null
    created_at?: Date | string
  }

  export type OrganisationsUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_type?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    founding_year?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_type?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    founding_year?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationsCreateManyInput = {
    id?: number
    category: string
    email: string
    password: string
    organisation_name?: string | null
    country?: string | null
    city?: string | null
    organisation_type?: string | null
    register_number?: string | null
    verified?: boolean
    founding_year?: Date | string | null
    created_at?: Date | string
  }

  export type OrganisationsUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_type?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    founding_year?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_type?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    founding_year?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsCreateInput = {
    User?: UserCreateNestedOneWithoutJobsInput
  }

  export type JobsUncheckedCreateInput = {
    id?: number
    userId?: number | null
  }

  export type JobsUpdateInput = {
    User?: UserUpdateOneWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JobsCreateManyInput = {
    id?: number
    userId?: number | null
  }

  export type JobsUpdateManyMutationInput = {

  }

  export type JobsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ConferrencesCreateInput = {
    User?: UserCreateNestedOneWithoutConferrencesInput
  }

  export type ConferrencesUncheckedCreateInput = {
    id?: number
    userId?: number | null
  }

  export type ConferrencesUpdateInput = {
    User?: UserUpdateOneWithoutConferrencesNestedInput
  }

  export type ConferrencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ConferrencesCreateManyInput = {
    id?: number
    userId?: number | null
  }

  export type ConferrencesUpdateManyMutationInput = {

  }

  export type ConferrencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SkillsCreateInput = {
    skill: string
    User?: UserCreateNestedOneWithoutSkillsInput
  }

  export type SkillsUncheckedCreateInput = {
    id?: number
    userId?: number | null
    skill: string
  }

  export type SkillsUpdateInput = {
    skill?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutSkillsNestedInput
  }

  export type SkillsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsCreateManyInput = {
    id?: number
    userId?: number | null
    skill: string
  }

  export type SkillsUpdateManyMutationInput = {
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type PostsCreateInput = {
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    User?: UserCreateNestedOneWithoutPostsInput
    postImageLinks?: PostImageLinksCreateNestedManyWithoutPostsInput
    comments?: CommentsCreateNestedManyWithoutPostsInput
    likes?: LikesCreateNestedManyWithoutPostsInput
    reposts?: RepostsCreateNestedManyWithoutPostsInput
    shares?: SharesCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateInput = {
    id?: number
    userId?: number | null
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    postImageLinks?: PostImageLinksUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentsUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikesUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RepostsUncheckedCreateNestedManyWithoutPostsInput
    shares?: SharesUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutPostsNestedInput
    postImageLinks?: PostImageLinksUpdateManyWithoutPostsNestedInput
    comments?: CommentsUpdateManyWithoutPostsNestedInput
    likes?: LikesUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUpdateManyWithoutPostsNestedInput
    shares?: SharesUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    postImageLinks?: PostImageLinksUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikesUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUncheckedUpdateManyWithoutPostsNestedInput
    shares?: SharesUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsCreateManyInput = {
    id?: number
    userId?: number | null
    title?: string | null
    description?: string | null
    posted_at?: Date | string
  }

  export type PostsUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageLinksCreateInput = {
    postImageLink?: string | null
    Posts?: PostsCreateNestedOneWithoutPostImageLinksInput
  }

  export type PostImageLinksUncheckedCreateInput = {
    id?: number
    postsId?: number | null
    postImageLink?: string | null
  }

  export type PostImageLinksUpdateInput = {
    postImageLink?: NullableStringFieldUpdateOperationsInput | string | null
    Posts?: PostsUpdateOneWithoutPostImageLinksNestedInput
  }

  export type PostImageLinksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    postImageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostImageLinksCreateManyInput = {
    id?: number
    postsId?: number | null
    postImageLink?: string | null
  }

  export type PostImageLinksUpdateManyMutationInput = {
    postImageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostImageLinksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    postImageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentsCreateInput = {
    comment: string
    commented_at?: Date | string
    Posts?: PostsCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateInput = {
    id?: number
    postsId?: number | null
    comment: string
    commented_at?: Date | string
  }

  export type CommentsUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    commented_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Posts?: PostsUpdateOneWithoutCommentsNestedInput
  }

  export type CommentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: StringFieldUpdateOperationsInput | string
    commented_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsCreateManyInput = {
    id?: number
    postsId?: number | null
    comment: string
    commented_at?: Date | string
  }

  export type CommentsUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    commented_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: StringFieldUpdateOperationsInput | string
    commented_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikesCreateInput = {
    liked_user_id?: number | null
    Posts?: PostsCreateNestedOneWithoutLikesInput
  }

  export type LikesUncheckedCreateInput = {
    id?: number
    postsId?: number | null
    liked_user_id?: number | null
  }

  export type LikesUpdateInput = {
    liked_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    Posts?: PostsUpdateOneWithoutLikesNestedInput
  }

  export type LikesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    liked_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LikesCreateManyInput = {
    id?: number
    postsId?: number | null
    liked_user_id?: number | null
  }

  export type LikesUpdateManyMutationInput = {
    liked_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LikesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    liked_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepostsCreateInput = {
    reposted_user_id?: number | null
    Posts?: PostsCreateNestedOneWithoutRepostsInput
  }

  export type RepostsUncheckedCreateInput = {
    id?: number
    postsId?: number | null
    reposted_user_id?: number | null
  }

  export type RepostsUpdateInput = {
    reposted_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    Posts?: PostsUpdateOneWithoutRepostsNestedInput
  }

  export type RepostsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    reposted_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepostsCreateManyInput = {
    id?: number
    postsId?: number | null
    reposted_user_id?: number | null
  }

  export type RepostsUpdateManyMutationInput = {
    reposted_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepostsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    reposted_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SharesCreateInput = {
    shared_user_id?: number | null
    Posts?: PostsCreateNestedOneWithoutSharesInput
  }

  export type SharesUncheckedCreateInput = {
    id?: number
    postsId?: number | null
    shared_user_id?: number | null
  }

  export type SharesUpdateInput = {
    shared_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    Posts?: PostsUpdateOneWithoutSharesNestedInput
  }

  export type SharesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    shared_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SharesCreateManyInput = {
    id?: number
    postsId?: number | null
    shared_user_id?: number | null
  }

  export type SharesUpdateManyMutationInput = {
    shared_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SharesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postsId?: NullableIntFieldUpdateOperationsInput | number | null
    shared_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionsCreateInput = {
    question: string
    question_description: string
    asked_at?: Date | string
    User?: UserCreateNestedOneWithoutQuestionsInput
    question_image_links?: QuestionImageLinksCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulCreateNestedManyWithoutQuestionsInput
    answers?: AnswersCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateInput = {
    id?: number
    userId?: number | null
    question: string
    question_description: string
    asked_at?: Date | string
    question_image_links?: QuestionImageLinksUncheckedCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulUncheckedCreateNestedManyWithoutQuestionsInput
    answers?: AnswersUncheckedCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsUncheckedCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutQuestionsNestedInput
    question_image_links?: QuestionImageLinksUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_image_links?: QuestionImageLinksUncheckedUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUncheckedUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUncheckedUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUncheckedUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsCreateManyInput = {
    id?: number
    userId?: number | null
    question: string
    question_description: string
    asked_at?: Date | string
  }

  export type QuestionsUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionReferencesCreateInput = {
    reference?: string | null
    Questions?: QuestionsCreateNestedOneWithoutQuestionReferencesInput
  }

  export type QuestionReferencesUncheckedCreateInput = {
    id?: number
    questionsId?: number | null
    reference?: string | null
  }

  export type QuestionReferencesUpdateInput = {
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    Questions?: QuestionsUpdateOneWithoutQuestionReferencesNestedInput
  }

  export type QuestionReferencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionReferencesCreateManyInput = {
    id?: number
    questionsId?: number | null
    reference?: string | null
  }

  export type QuestionReferencesUpdateManyMutationInput = {
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionReferencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionCommentsCreateInput = {
    comment: string
    comment_user_id: number
    Questions?: QuestionsCreateNestedOneWithoutQuestionCommentsInput
  }

  export type QuestionCommentsUncheckedCreateInput = {
    id?: number
    questionsId?: number | null
    comment: string
    comment_user_id: number
  }

  export type QuestionCommentsUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    comment_user_id?: IntFieldUpdateOperationsInput | number
    Questions?: QuestionsUpdateOneWithoutQuestionCommentsNestedInput
  }

  export type QuestionCommentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: StringFieldUpdateOperationsInput | string
    comment_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionCommentsCreateManyInput = {
    id?: number
    questionsId?: number | null
    comment: string
    comment_user_id: number
  }

  export type QuestionCommentsUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    comment_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionCommentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: StringFieldUpdateOperationsInput | string
    comment_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type AnswersCreateInput = {
    answered_user_id: string
    answer_description: string
    Questions?: QuestionsCreateNestedOneWithoutAnswersInput
    answer_image_links?: Answer_Image_LinksCreateNestedManyWithoutAnswersInput
  }

  export type AnswersUncheckedCreateInput = {
    id?: number
    questionsId?: number | null
    answered_user_id: string
    answer_description: string
    answer_image_links?: Answer_Image_LinksUncheckedCreateNestedManyWithoutAnswersInput
  }

  export type AnswersUpdateInput = {
    answered_user_id?: StringFieldUpdateOperationsInput | string
    answer_description?: StringFieldUpdateOperationsInput | string
    Questions?: QuestionsUpdateOneWithoutAnswersNestedInput
    answer_image_links?: Answer_Image_LinksUpdateManyWithoutAnswersNestedInput
  }

  export type AnswersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
    answered_user_id?: StringFieldUpdateOperationsInput | string
    answer_description?: StringFieldUpdateOperationsInput | string
    answer_image_links?: Answer_Image_LinksUncheckedUpdateManyWithoutAnswersNestedInput
  }

  export type AnswersCreateManyInput = {
    id?: number
    questionsId?: number | null
    answered_user_id: string
    answer_description: string
  }

  export type AnswersUpdateManyMutationInput = {
    answered_user_id?: StringFieldUpdateOperationsInput | string
    answer_description?: StringFieldUpdateOperationsInput | string
  }

  export type AnswersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
    answered_user_id?: StringFieldUpdateOperationsInput | string
    answer_description?: StringFieldUpdateOperationsInput | string
  }

  export type Answer_Image_LinksCreateInput = {
    answer_image_link?: string | null
    Answers?: AnswersCreateNestedOneWithoutAnswer_image_linksInput
  }

  export type Answer_Image_LinksUncheckedCreateInput = {
    id?: number
    answersId?: number | null
    answer_image_link?: string | null
  }

  export type Answer_Image_LinksUpdateInput = {
    answer_image_link?: NullableStringFieldUpdateOperationsInput | string | null
    Answers?: AnswersUpdateOneWithoutAnswer_image_linksNestedInput
  }

  export type Answer_Image_LinksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    answersId?: NullableIntFieldUpdateOperationsInput | number | null
    answer_image_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Answer_Image_LinksCreateManyInput = {
    id?: number
    answersId?: number | null
    answer_image_link?: string | null
  }

  export type Answer_Image_LinksUpdateManyMutationInput = {
    answer_image_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Answer_Image_LinksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    answersId?: NullableIntFieldUpdateOperationsInput | number | null
    answer_image_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionImageLinksCreateInput = {
    Questions?: QuestionsCreateNestedOneWithoutQuestion_image_linksInput
  }

  export type QuestionImageLinksUncheckedCreateInput = {
    id?: number
    questionsId?: number | null
  }

  export type QuestionImageLinksUpdateInput = {
    Questions?: QuestionsUpdateOneWithoutQuestion_image_linksNestedInput
  }

  export type QuestionImageLinksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionImageLinksCreateManyInput = {
    id?: number
    questionsId?: number | null
  }

  export type QuestionImageLinksUpdateManyMutationInput = {

  }

  export type QuestionImageLinksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InsightfulCreateInput = {
    insightful_user_id?: string | null
    Questions?: QuestionsCreateNestedOneWithoutInsightfulInput
  }

  export type InsightfulUncheckedCreateInput = {
    id?: number
    questionsId?: number | null
    insightful_user_id?: string | null
  }

  export type InsightfulUpdateInput = {
    insightful_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    Questions?: QuestionsUpdateOneWithoutInsightfulNestedInput
  }

  export type InsightfulUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
    insightful_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InsightfulCreateManyInput = {
    id?: number
    questionsId?: number | null
    insightful_user_id?: string | null
  }

  export type InsightfulUpdateManyMutationInput = {
    insightful_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InsightfulUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
    insightful_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FriendsCreateInput = {
    User?: UserCreateNestedOneWithoutFriendsInput
  }

  export type FriendsUncheckedCreateInput = {
    id?: number
    userId?: number | null
  }

  export type FriendsUpdateInput = {
    User?: UserUpdateOneWithoutFriendsNestedInput
  }

  export type FriendsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FriendsCreateManyInput = {
    id?: number
    userId?: number | null
  }

  export type FriendsUpdateManyMutationInput = {

  }

  export type FriendsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CertificationsCreateInput = {
    certificateName?: string | null
    issuingOrganisation?: string | null
    issueDate?: string | null
    descreption?: string | null
    certificateURL?: string | null
    certificateMediaLink?: string | null
    User?: UserCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationsUncheckedCreateInput = {
    id?: number
    userId?: number | null
    certificateName?: string | null
    issuingOrganisation?: string | null
    issueDate?: string | null
    descreption?: string | null
    certificateURL?: string | null
    certificateMediaLink?: string | null
  }

  export type CertificationsUpdateInput = {
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    issuingOrganisation?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
    certificateURL?: NullableStringFieldUpdateOperationsInput | string | null
    certificateMediaLink?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutCertificationsNestedInput
  }

  export type CertificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    issuingOrganisation?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
    certificateURL?: NullableStringFieldUpdateOperationsInput | string | null
    certificateMediaLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificationsCreateManyInput = {
    id?: number
    userId?: number | null
    certificateName?: string | null
    issuingOrganisation?: string | null
    issueDate?: string | null
    descreption?: string | null
    certificateURL?: string | null
    certificateMediaLink?: string | null
  }

  export type CertificationsUpdateManyMutationInput = {
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    issuingOrganisation?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
    certificateURL?: NullableStringFieldUpdateOperationsInput | string | null
    certificateMediaLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    issuingOrganisation?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
    certificateURL?: NullableStringFieldUpdateOperationsInput | string | null
    certificateMediaLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MembershipsCreateInput = {
    societyname?: string | null
    position?: string | null
    relatedDepartment?: string | null
    membershipId?: string | null
    User?: UserCreateNestedOneWithoutMembershipsInput
  }

  export type MembershipsUncheckedCreateInput = {
    id?: number
    userId?: number | null
    societyname?: string | null
    position?: string | null
    relatedDepartment?: string | null
    membershipId?: string | null
  }

  export type MembershipsUpdateInput = {
    societyname?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    relatedDepartment?: NullableStringFieldUpdateOperationsInput | string | null
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutMembershipsNestedInput
  }

  export type MembershipsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    societyname?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    relatedDepartment?: NullableStringFieldUpdateOperationsInput | string | null
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MembershipsCreateManyInput = {
    id?: number
    userId?: number | null
    societyname?: string | null
    position?: string | null
    relatedDepartment?: string | null
    membershipId?: string | null
  }

  export type MembershipsUpdateManyMutationInput = {
    societyname?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    relatedDepartment?: NullableStringFieldUpdateOperationsInput | string | null
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MembershipsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    societyname?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    relatedDepartment?: NullableStringFieldUpdateOperationsInput | string | null
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationCreateInput = {
    schoolName?: string | null
    degree?: string | null
    department?: string | null
    startDate?: string | null
    endDate?: string | null
    grade?: string | null
    User?: UserCreateNestedOneWithoutEducationInput
  }

  export type EducationUncheckedCreateInput = {
    id?: number
    userId?: number | null
    schoolName?: string | null
    degree?: string | null
    department?: string | null
    startDate?: string | null
    endDate?: string | null
    grade?: string | null
  }

  export type EducationUpdateInput = {
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationCreateManyInput = {
    id?: number
    userId?: number | null
    schoolName?: string | null
    degree?: string | null
    department?: string | null
    startDate?: string | null
    endDate?: string | null
    grade?: string | null
  }

  export type EducationUpdateManyMutationInput = {
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfessionalExperienceCreateInput = {
    title?: string | null
    organisation?: string | null
    startDate?: string | null
    endDate?: string | null
    location?: string | null
    User?: UserCreateNestedOneWithoutProfessionalExperienceInput
  }

  export type ProfessionalExperienceUncheckedCreateInput = {
    id?: number
    userId?: number | null
    title?: string | null
    organisation?: string | null
    startDate?: string | null
    endDate?: string | null
    location?: string | null
  }

  export type ProfessionalExperienceUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutProfessionalExperienceNestedInput
  }

  export type ProfessionalExperienceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfessionalExperienceCreateManyInput = {
    id?: number
    userId?: number | null
    title?: string | null
    organisation?: string | null
    startDate?: string | null
    endDate?: string | null
    location?: string | null
  }

  export type ProfessionalExperienceUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfessionalExperienceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SkillsListRelationFilter = {
    every?: SkillsWhereInput
    some?: SkillsWhereInput
    none?: SkillsWhereInput
  }

  export type PostsListRelationFilter = {
    every?: PostsWhereInput
    some?: PostsWhereInput
    none?: PostsWhereInput
  }

  export type QuestionsListRelationFilter = {
    every?: QuestionsWhereInput
    some?: QuestionsWhereInput
    none?: QuestionsWhereInput
  }

  export type FriendsListRelationFilter = {
    every?: FriendsWhereInput
    some?: FriendsWhereInput
    none?: FriendsWhereInput
  }

  export type CertificationsListRelationFilter = {
    every?: CertificationsWhereInput
    some?: CertificationsWhereInput
    none?: CertificationsWhereInput
  }

  export type MembershipsListRelationFilter = {
    every?: MembershipsWhereInput
    some?: MembershipsWhereInput
    none?: MembershipsWhereInput
  }

  export type EducationListRelationFilter = {
    every?: EducationWhereInput
    some?: EducationWhereInput
    none?: EducationWhereInput
  }

  export type ProfessionalExperienceListRelationFilter = {
    every?: ProfessionalExperienceWhereInput
    some?: ProfessionalExperienceWhereInput
    none?: ProfessionalExperienceWhereInput
  }

  export type JobsListRelationFilter = {
    every?: JobsWhereInput
    some?: JobsWhereInput
    none?: JobsWhereInput
  }

  export type ConferrencesListRelationFilter = {
    every?: ConferrencesWhereInput
    some?: ConferrencesWhereInput
    none?: ConferrencesWhereInput
  }

  export type AchievementsAwardsListRelationFilter = {
    every?: AchievementsAwardsWhereInput
    some?: AchievementsAwardsWhereInput
    none?: AchievementsAwardsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SkillsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfessionalExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferrencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementsAwardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    department?: SortOrder
    country?: SortOrder
    city?: SortOrder
    organisation_name?: SortOrder
    specialisation_field_of_study?: SortOrder
    register_number?: SortOrder
    verified?: SortOrder
    date_of_birth?: SortOrder
    created_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    department?: SortOrder
    country?: SortOrder
    city?: SortOrder
    organisation_name?: SortOrder
    specialisation_field_of_study?: SortOrder
    register_number?: SortOrder
    verified?: SortOrder
    date_of_birth?: SortOrder
    created_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    department?: SortOrder
    country?: SortOrder
    city?: SortOrder
    organisation_name?: SortOrder
    specialisation_field_of_study?: SortOrder
    register_number?: SortOrder
    verified?: SortOrder
    date_of_birth?: SortOrder
    created_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DoctorsCountOrderByAggregateInput = {
    id?: SortOrder
    registrationNo?: SortOrder
    doctors?: SortOrder
  }

  export type DoctorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DoctorsMaxOrderByAggregateInput = {
    id?: SortOrder
    registrationNo?: SortOrder
    doctors?: SortOrder
  }

  export type DoctorsMinOrderByAggregateInput = {
    id?: SortOrder
    registrationNo?: SortOrder
    doctors?: SortOrder
  }

  export type DoctorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AchievementsAwardsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    awardName?: SortOrder
    awardedBy?: SortOrder
    awardedOn?: SortOrder
    descreption?: SortOrder
  }

  export type AchievementsAwardsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AchievementsAwardsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    awardName?: SortOrder
    awardedBy?: SortOrder
    awardedOn?: SortOrder
    descreption?: SortOrder
  }

  export type AchievementsAwardsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    awardName?: SortOrder
    awardedBy?: SortOrder
    awardedOn?: SortOrder
    descreption?: SortOrder
  }

  export type AchievementsAwardsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrganisationsCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organisation_name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    organisation_type?: SortOrder
    register_number?: SortOrder
    verified?: SortOrder
    founding_year?: SortOrder
    created_at?: SortOrder
  }

  export type OrganisationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganisationsMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organisation_name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    organisation_type?: SortOrder
    register_number?: SortOrder
    verified?: SortOrder
    founding_year?: SortOrder
    created_at?: SortOrder
  }

  export type OrganisationsMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organisation_name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    organisation_type?: SortOrder
    register_number?: SortOrder
    verified?: SortOrder
    founding_year?: SortOrder
    created_at?: SortOrder
  }

  export type OrganisationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JobsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type JobsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type JobsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type JobsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type JobsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ConferrencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ConferrencesAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ConferrencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ConferrencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ConferrencesSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SkillsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skill?: SortOrder
  }

  export type SkillsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SkillsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skill?: SortOrder
  }

  export type SkillsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skill?: SortOrder
  }

  export type SkillsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostImageLinksListRelationFilter = {
    every?: PostImageLinksWhereInput
    some?: PostImageLinksWhereInput
    none?: PostImageLinksWhereInput
  }

  export type CommentsListRelationFilter = {
    every?: CommentsWhereInput
    some?: CommentsWhereInput
    none?: CommentsWhereInput
  }

  export type LikesListRelationFilter = {
    every?: LikesWhereInput
    some?: LikesWhereInput
    none?: LikesWhereInput
  }

  export type RepostsListRelationFilter = {
    every?: RepostsWhereInput
    some?: RepostsWhereInput
    none?: RepostsWhereInput
  }

  export type SharesListRelationFilter = {
    every?: SharesWhereInput
    some?: SharesWhereInput
    none?: SharesWhereInput
  }

  export type PostImageLinksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepostsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    posted_at?: SortOrder
  }

  export type PostsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    posted_at?: SortOrder
  }

  export type PostsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    posted_at?: SortOrder
  }

  export type PostsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostsNullableScalarRelationFilter = {
    is?: PostsWhereInput | null
    isNot?: PostsWhereInput | null
  }

  export type PostImageLinksCountOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    postImageLink?: SortOrder
  }

  export type PostImageLinksAvgOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
  }

  export type PostImageLinksMaxOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    postImageLink?: SortOrder
  }

  export type PostImageLinksMinOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    postImageLink?: SortOrder
  }

  export type PostImageLinksSumOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
  }

  export type CommentsCountOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    comment?: SortOrder
    commented_at?: SortOrder
  }

  export type CommentsAvgOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
  }

  export type CommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    comment?: SortOrder
    commented_at?: SortOrder
  }

  export type CommentsMinOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    comment?: SortOrder
    commented_at?: SortOrder
  }

  export type CommentsSumOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
  }

  export type LikesCountOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    liked_user_id?: SortOrder
  }

  export type LikesAvgOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    liked_user_id?: SortOrder
  }

  export type LikesMaxOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    liked_user_id?: SortOrder
  }

  export type LikesMinOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    liked_user_id?: SortOrder
  }

  export type LikesSumOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    liked_user_id?: SortOrder
  }

  export type RepostsCountOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    reposted_user_id?: SortOrder
  }

  export type RepostsAvgOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    reposted_user_id?: SortOrder
  }

  export type RepostsMaxOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    reposted_user_id?: SortOrder
  }

  export type RepostsMinOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    reposted_user_id?: SortOrder
  }

  export type RepostsSumOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    reposted_user_id?: SortOrder
  }

  export type SharesCountOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    shared_user_id?: SortOrder
  }

  export type SharesAvgOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    shared_user_id?: SortOrder
  }

  export type SharesMaxOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    shared_user_id?: SortOrder
  }

  export type SharesMinOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    shared_user_id?: SortOrder
  }

  export type SharesSumOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    shared_user_id?: SortOrder
  }

  export type QuestionImageLinksListRelationFilter = {
    every?: QuestionImageLinksWhereInput
    some?: QuestionImageLinksWhereInput
    none?: QuestionImageLinksWhereInput
  }

  export type InsightfulListRelationFilter = {
    every?: InsightfulWhereInput
    some?: InsightfulWhereInput
    none?: InsightfulWhereInput
  }

  export type AnswersListRelationFilter = {
    every?: AnswersWhereInput
    some?: AnswersWhereInput
    none?: AnswersWhereInput
  }

  export type QuestionCommentsListRelationFilter = {
    every?: QuestionCommentsWhereInput
    some?: QuestionCommentsWhereInput
    none?: QuestionCommentsWhereInput
  }

  export type QuestionReferencesListRelationFilter = {
    every?: QuestionReferencesWhereInput
    some?: QuestionReferencesWhereInput
    none?: QuestionReferencesWhereInput
  }

  export type QuestionImageLinksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsightfulOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnswersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionReferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    question_description?: SortOrder
    asked_at?: SortOrder
  }

  export type QuestionsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type QuestionsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    question_description?: SortOrder
    asked_at?: SortOrder
  }

  export type QuestionsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    question_description?: SortOrder
    asked_at?: SortOrder
  }

  export type QuestionsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type QuestionsNullableScalarRelationFilter = {
    is?: QuestionsWhereInput | null
    isNot?: QuestionsWhereInput | null
  }

  export type QuestionReferencesCountOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    reference?: SortOrder
  }

  export type QuestionReferencesAvgOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type QuestionReferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    reference?: SortOrder
  }

  export type QuestionReferencesMinOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    reference?: SortOrder
  }

  export type QuestionReferencesSumOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type QuestionCommentsCountOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    comment?: SortOrder
    comment_user_id?: SortOrder
  }

  export type QuestionCommentsAvgOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    comment_user_id?: SortOrder
  }

  export type QuestionCommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    comment?: SortOrder
    comment_user_id?: SortOrder
  }

  export type QuestionCommentsMinOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    comment?: SortOrder
    comment_user_id?: SortOrder
  }

  export type QuestionCommentsSumOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    comment_user_id?: SortOrder
  }

  export type Answer_Image_LinksListRelationFilter = {
    every?: Answer_Image_LinksWhereInput
    some?: Answer_Image_LinksWhereInput
    none?: Answer_Image_LinksWhereInput
  }

  export type Answer_Image_LinksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnswersCountOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    answered_user_id?: SortOrder
    answer_description?: SortOrder
  }

  export type AnswersAvgOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type AnswersMaxOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    answered_user_id?: SortOrder
    answer_description?: SortOrder
  }

  export type AnswersMinOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    answered_user_id?: SortOrder
    answer_description?: SortOrder
  }

  export type AnswersSumOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type AnswersNullableScalarRelationFilter = {
    is?: AnswersWhereInput | null
    isNot?: AnswersWhereInput | null
  }

  export type Answer_Image_LinksCountOrderByAggregateInput = {
    id?: SortOrder
    answersId?: SortOrder
    answer_image_link?: SortOrder
  }

  export type Answer_Image_LinksAvgOrderByAggregateInput = {
    id?: SortOrder
    answersId?: SortOrder
  }

  export type Answer_Image_LinksMaxOrderByAggregateInput = {
    id?: SortOrder
    answersId?: SortOrder
    answer_image_link?: SortOrder
  }

  export type Answer_Image_LinksMinOrderByAggregateInput = {
    id?: SortOrder
    answersId?: SortOrder
    answer_image_link?: SortOrder
  }

  export type Answer_Image_LinksSumOrderByAggregateInput = {
    id?: SortOrder
    answersId?: SortOrder
  }

  export type QuestionImageLinksCountOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type QuestionImageLinksAvgOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type QuestionImageLinksMaxOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type QuestionImageLinksMinOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type QuestionImageLinksSumOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type InsightfulCountOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    insightful_user_id?: SortOrder
  }

  export type InsightfulAvgOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type InsightfulMaxOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    insightful_user_id?: SortOrder
  }

  export type InsightfulMinOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
    insightful_user_id?: SortOrder
  }

  export type InsightfulSumOrderByAggregateInput = {
    id?: SortOrder
    questionsId?: SortOrder
  }

  export type FriendsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FriendsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FriendsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FriendsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FriendsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CertificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    certificateName?: SortOrder
    issuingOrganisation?: SortOrder
    issueDate?: SortOrder
    descreption?: SortOrder
    certificateURL?: SortOrder
    certificateMediaLink?: SortOrder
  }

  export type CertificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CertificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    certificateName?: SortOrder
    issuingOrganisation?: SortOrder
    issueDate?: SortOrder
    descreption?: SortOrder
    certificateURL?: SortOrder
    certificateMediaLink?: SortOrder
  }

  export type CertificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    certificateName?: SortOrder
    issuingOrganisation?: SortOrder
    issueDate?: SortOrder
    descreption?: SortOrder
    certificateURL?: SortOrder
    certificateMediaLink?: SortOrder
  }

  export type CertificationsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MembershipsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    societyname?: SortOrder
    position?: SortOrder
    relatedDepartment?: SortOrder
    membershipId?: SortOrder
  }

  export type MembershipsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MembershipsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    societyname?: SortOrder
    position?: SortOrder
    relatedDepartment?: SortOrder
    membershipId?: SortOrder
  }

  export type MembershipsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    societyname?: SortOrder
    position?: SortOrder
    relatedDepartment?: SortOrder
    membershipId?: SortOrder
  }

  export type MembershipsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EducationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolName?: SortOrder
    degree?: SortOrder
    department?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    grade?: SortOrder
  }

  export type EducationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EducationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolName?: SortOrder
    degree?: SortOrder
    department?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    grade?: SortOrder
  }

  export type EducationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolName?: SortOrder
    degree?: SortOrder
    department?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    grade?: SortOrder
  }

  export type EducationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProfessionalExperienceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    organisation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
  }

  export type ProfessionalExperienceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProfessionalExperienceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    organisation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
  }

  export type ProfessionalExperienceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    organisation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
  }

  export type ProfessionalExperienceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SkillsCreateNestedManyWithoutUserInput = {
    create?: XOR<SkillsCreateWithoutUserInput, SkillsUncheckedCreateWithoutUserInput> | SkillsCreateWithoutUserInput[] | SkillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkillsCreateOrConnectWithoutUserInput | SkillsCreateOrConnectWithoutUserInput[]
    createMany?: SkillsCreateManyUserInputEnvelope
    connect?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
  }

  export type PostsCreateNestedManyWithoutUserInput = {
    create?: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput> | PostsCreateWithoutUserInput[] | PostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUserInput | PostsCreateOrConnectWithoutUserInput[]
    createMany?: PostsCreateManyUserInputEnvelope
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
  }

  export type QuestionsCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionsCreateWithoutUserInput, QuestionsUncheckedCreateWithoutUserInput> | QuestionsCreateWithoutUserInput[] | QuestionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionsCreateOrConnectWithoutUserInput | QuestionsCreateOrConnectWithoutUserInput[]
    createMany?: QuestionsCreateManyUserInputEnvelope
    connect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
  }

  export type FriendsCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput> | FriendsCreateWithoutUserInput[] | FriendsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUserInput | FriendsCreateOrConnectWithoutUserInput[]
    createMany?: FriendsCreateManyUserInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type CertificationsCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificationsCreateWithoutUserInput, CertificationsUncheckedCreateWithoutUserInput> | CertificationsCreateWithoutUserInput[] | CertificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificationsCreateOrConnectWithoutUserInput | CertificationsCreateOrConnectWithoutUserInput[]
    createMany?: CertificationsCreateManyUserInputEnvelope
    connect?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
  }

  export type MembershipsCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipsCreateWithoutUserInput, MembershipsUncheckedCreateWithoutUserInput> | MembershipsCreateWithoutUserInput[] | MembershipsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipsCreateOrConnectWithoutUserInput | MembershipsCreateOrConnectWithoutUserInput[]
    createMany?: MembershipsCreateManyUserInputEnvelope
    connect?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
  }

  export type EducationCreateNestedManyWithoutUserInput = {
    create?: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput> | EducationCreateWithoutUserInput[] | EducationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutUserInput | EducationCreateOrConnectWithoutUserInput[]
    createMany?: EducationCreateManyUserInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type ProfessionalExperienceCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfessionalExperienceCreateWithoutUserInput, ProfessionalExperienceUncheckedCreateWithoutUserInput> | ProfessionalExperienceCreateWithoutUserInput[] | ProfessionalExperienceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfessionalExperienceCreateOrConnectWithoutUserInput | ProfessionalExperienceCreateOrConnectWithoutUserInput[]
    createMany?: ProfessionalExperienceCreateManyUserInputEnvelope
    connect?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
  }

  export type JobsCreateNestedManyWithoutUserInput = {
    create?: XOR<JobsCreateWithoutUserInput, JobsUncheckedCreateWithoutUserInput> | JobsCreateWithoutUserInput[] | JobsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutUserInput | JobsCreateOrConnectWithoutUserInput[]
    createMany?: JobsCreateManyUserInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type ConferrencesCreateNestedManyWithoutUserInput = {
    create?: XOR<ConferrencesCreateWithoutUserInput, ConferrencesUncheckedCreateWithoutUserInput> | ConferrencesCreateWithoutUserInput[] | ConferrencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferrencesCreateOrConnectWithoutUserInput | ConferrencesCreateOrConnectWithoutUserInput[]
    createMany?: ConferrencesCreateManyUserInputEnvelope
    connect?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
  }

  export type AchievementsAwardsCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementsAwardsCreateWithoutUserInput, AchievementsAwardsUncheckedCreateWithoutUserInput> | AchievementsAwardsCreateWithoutUserInput[] | AchievementsAwardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementsAwardsCreateOrConnectWithoutUserInput | AchievementsAwardsCreateOrConnectWithoutUserInput[]
    createMany?: AchievementsAwardsCreateManyUserInputEnvelope
    connect?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
  }

  export type SkillsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SkillsCreateWithoutUserInput, SkillsUncheckedCreateWithoutUserInput> | SkillsCreateWithoutUserInput[] | SkillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkillsCreateOrConnectWithoutUserInput | SkillsCreateOrConnectWithoutUserInput[]
    createMany?: SkillsCreateManyUserInputEnvelope
    connect?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
  }

  export type PostsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput> | PostsCreateWithoutUserInput[] | PostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUserInput | PostsCreateOrConnectWithoutUserInput[]
    createMany?: PostsCreateManyUserInputEnvelope
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
  }

  export type QuestionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionsCreateWithoutUserInput, QuestionsUncheckedCreateWithoutUserInput> | QuestionsCreateWithoutUserInput[] | QuestionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionsCreateOrConnectWithoutUserInput | QuestionsCreateOrConnectWithoutUserInput[]
    createMany?: QuestionsCreateManyUserInputEnvelope
    connect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
  }

  export type FriendsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput> | FriendsCreateWithoutUserInput[] | FriendsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUserInput | FriendsCreateOrConnectWithoutUserInput[]
    createMany?: FriendsCreateManyUserInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type CertificationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificationsCreateWithoutUserInput, CertificationsUncheckedCreateWithoutUserInput> | CertificationsCreateWithoutUserInput[] | CertificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificationsCreateOrConnectWithoutUserInput | CertificationsCreateOrConnectWithoutUserInput[]
    createMany?: CertificationsCreateManyUserInputEnvelope
    connect?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
  }

  export type MembershipsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipsCreateWithoutUserInput, MembershipsUncheckedCreateWithoutUserInput> | MembershipsCreateWithoutUserInput[] | MembershipsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipsCreateOrConnectWithoutUserInput | MembershipsCreateOrConnectWithoutUserInput[]
    createMany?: MembershipsCreateManyUserInputEnvelope
    connect?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
  }

  export type EducationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput> | EducationCreateWithoutUserInput[] | EducationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutUserInput | EducationCreateOrConnectWithoutUserInput[]
    createMany?: EducationCreateManyUserInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfessionalExperienceCreateWithoutUserInput, ProfessionalExperienceUncheckedCreateWithoutUserInput> | ProfessionalExperienceCreateWithoutUserInput[] | ProfessionalExperienceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfessionalExperienceCreateOrConnectWithoutUserInput | ProfessionalExperienceCreateOrConnectWithoutUserInput[]
    createMany?: ProfessionalExperienceCreateManyUserInputEnvelope
    connect?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JobsCreateWithoutUserInput, JobsUncheckedCreateWithoutUserInput> | JobsCreateWithoutUserInput[] | JobsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutUserInput | JobsCreateOrConnectWithoutUserInput[]
    createMany?: JobsCreateManyUserInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type ConferrencesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConferrencesCreateWithoutUserInput, ConferrencesUncheckedCreateWithoutUserInput> | ConferrencesCreateWithoutUserInput[] | ConferrencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferrencesCreateOrConnectWithoutUserInput | ConferrencesCreateOrConnectWithoutUserInput[]
    createMany?: ConferrencesCreateManyUserInputEnvelope
    connect?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
  }

  export type AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementsAwardsCreateWithoutUserInput, AchievementsAwardsUncheckedCreateWithoutUserInput> | AchievementsAwardsCreateWithoutUserInput[] | AchievementsAwardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementsAwardsCreateOrConnectWithoutUserInput | AchievementsAwardsCreateOrConnectWithoutUserInput[]
    createMany?: AchievementsAwardsCreateManyUserInputEnvelope
    connect?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SkillsUpdateManyWithoutUserNestedInput = {
    create?: XOR<SkillsCreateWithoutUserInput, SkillsUncheckedCreateWithoutUserInput> | SkillsCreateWithoutUserInput[] | SkillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkillsCreateOrConnectWithoutUserInput | SkillsCreateOrConnectWithoutUserInput[]
    upsert?: SkillsUpsertWithWhereUniqueWithoutUserInput | SkillsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SkillsCreateManyUserInputEnvelope
    set?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
    disconnect?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
    delete?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
    connect?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
    update?: SkillsUpdateWithWhereUniqueWithoutUserInput | SkillsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SkillsUpdateManyWithWhereWithoutUserInput | SkillsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SkillsScalarWhereInput | SkillsScalarWhereInput[]
  }

  export type PostsUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput> | PostsCreateWithoutUserInput[] | PostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUserInput | PostsCreateOrConnectWithoutUserInput[]
    upsert?: PostsUpsertWithWhereUniqueWithoutUserInput | PostsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostsCreateManyUserInputEnvelope
    set?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    disconnect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    delete?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    update?: PostsUpdateWithWhereUniqueWithoutUserInput | PostsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostsUpdateManyWithWhereWithoutUserInput | PostsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostsScalarWhereInput | PostsScalarWhereInput[]
  }

  export type QuestionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionsCreateWithoutUserInput, QuestionsUncheckedCreateWithoutUserInput> | QuestionsCreateWithoutUserInput[] | QuestionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionsCreateOrConnectWithoutUserInput | QuestionsCreateOrConnectWithoutUserInput[]
    upsert?: QuestionsUpsertWithWhereUniqueWithoutUserInput | QuestionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionsCreateManyUserInputEnvelope
    set?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    disconnect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    delete?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    connect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    update?: QuestionsUpdateWithWhereUniqueWithoutUserInput | QuestionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionsUpdateManyWithWhereWithoutUserInput | QuestionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionsScalarWhereInput | QuestionsScalarWhereInput[]
  }

  export type FriendsUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput> | FriendsCreateWithoutUserInput[] | FriendsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUserInput | FriendsCreateOrConnectWithoutUserInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutUserInput | FriendsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendsCreateManyUserInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutUserInput | FriendsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutUserInput | FriendsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type CertificationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificationsCreateWithoutUserInput, CertificationsUncheckedCreateWithoutUserInput> | CertificationsCreateWithoutUserInput[] | CertificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificationsCreateOrConnectWithoutUserInput | CertificationsCreateOrConnectWithoutUserInput[]
    upsert?: CertificationsUpsertWithWhereUniqueWithoutUserInput | CertificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificationsCreateManyUserInputEnvelope
    set?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
    disconnect?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
    delete?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
    connect?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
    update?: CertificationsUpdateWithWhereUniqueWithoutUserInput | CertificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificationsUpdateManyWithWhereWithoutUserInput | CertificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificationsScalarWhereInput | CertificationsScalarWhereInput[]
  }

  export type MembershipsUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipsCreateWithoutUserInput, MembershipsUncheckedCreateWithoutUserInput> | MembershipsCreateWithoutUserInput[] | MembershipsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipsCreateOrConnectWithoutUserInput | MembershipsCreateOrConnectWithoutUserInput[]
    upsert?: MembershipsUpsertWithWhereUniqueWithoutUserInput | MembershipsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipsCreateManyUserInputEnvelope
    set?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
    disconnect?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
    delete?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
    connect?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
    update?: MembershipsUpdateWithWhereUniqueWithoutUserInput | MembershipsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipsUpdateManyWithWhereWithoutUserInput | MembershipsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipsScalarWhereInput | MembershipsScalarWhereInput[]
  }

  export type EducationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput> | EducationCreateWithoutUserInput[] | EducationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutUserInput | EducationCreateOrConnectWithoutUserInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutUserInput | EducationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EducationCreateManyUserInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutUserInput | EducationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutUserInput | EducationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type ProfessionalExperienceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfessionalExperienceCreateWithoutUserInput, ProfessionalExperienceUncheckedCreateWithoutUserInput> | ProfessionalExperienceCreateWithoutUserInput[] | ProfessionalExperienceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfessionalExperienceCreateOrConnectWithoutUserInput | ProfessionalExperienceCreateOrConnectWithoutUserInput[]
    upsert?: ProfessionalExperienceUpsertWithWhereUniqueWithoutUserInput | ProfessionalExperienceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfessionalExperienceCreateManyUserInputEnvelope
    set?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
    disconnect?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
    delete?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
    connect?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
    update?: ProfessionalExperienceUpdateWithWhereUniqueWithoutUserInput | ProfessionalExperienceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfessionalExperienceUpdateManyWithWhereWithoutUserInput | ProfessionalExperienceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfessionalExperienceScalarWhereInput | ProfessionalExperienceScalarWhereInput[]
  }

  export type JobsUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobsCreateWithoutUserInput, JobsUncheckedCreateWithoutUserInput> | JobsCreateWithoutUserInput[] | JobsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutUserInput | JobsCreateOrConnectWithoutUserInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutUserInput | JobsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobsCreateManyUserInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutUserInput | JobsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutUserInput | JobsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type ConferrencesUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConferrencesCreateWithoutUserInput, ConferrencesUncheckedCreateWithoutUserInput> | ConferrencesCreateWithoutUserInput[] | ConferrencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferrencesCreateOrConnectWithoutUserInput | ConferrencesCreateOrConnectWithoutUserInput[]
    upsert?: ConferrencesUpsertWithWhereUniqueWithoutUserInput | ConferrencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConferrencesCreateManyUserInputEnvelope
    set?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
    disconnect?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
    delete?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
    connect?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
    update?: ConferrencesUpdateWithWhereUniqueWithoutUserInput | ConferrencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConferrencesUpdateManyWithWhereWithoutUserInput | ConferrencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConferrencesScalarWhereInput | ConferrencesScalarWhereInput[]
  }

  export type AchievementsAwardsUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementsAwardsCreateWithoutUserInput, AchievementsAwardsUncheckedCreateWithoutUserInput> | AchievementsAwardsCreateWithoutUserInput[] | AchievementsAwardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementsAwardsCreateOrConnectWithoutUserInput | AchievementsAwardsCreateOrConnectWithoutUserInput[]
    upsert?: AchievementsAwardsUpsertWithWhereUniqueWithoutUserInput | AchievementsAwardsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementsAwardsCreateManyUserInputEnvelope
    set?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
    disconnect?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
    delete?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
    connect?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
    update?: AchievementsAwardsUpdateWithWhereUniqueWithoutUserInput | AchievementsAwardsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementsAwardsUpdateManyWithWhereWithoutUserInput | AchievementsAwardsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementsAwardsScalarWhereInput | AchievementsAwardsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SkillsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SkillsCreateWithoutUserInput, SkillsUncheckedCreateWithoutUserInput> | SkillsCreateWithoutUserInput[] | SkillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SkillsCreateOrConnectWithoutUserInput | SkillsCreateOrConnectWithoutUserInput[]
    upsert?: SkillsUpsertWithWhereUniqueWithoutUserInput | SkillsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SkillsCreateManyUserInputEnvelope
    set?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
    disconnect?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
    delete?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
    connect?: SkillsWhereUniqueInput | SkillsWhereUniqueInput[]
    update?: SkillsUpdateWithWhereUniqueWithoutUserInput | SkillsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SkillsUpdateManyWithWhereWithoutUserInput | SkillsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SkillsScalarWhereInput | SkillsScalarWhereInput[]
  }

  export type PostsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput> | PostsCreateWithoutUserInput[] | PostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUserInput | PostsCreateOrConnectWithoutUserInput[]
    upsert?: PostsUpsertWithWhereUniqueWithoutUserInput | PostsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostsCreateManyUserInputEnvelope
    set?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    disconnect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    delete?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    update?: PostsUpdateWithWhereUniqueWithoutUserInput | PostsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostsUpdateManyWithWhereWithoutUserInput | PostsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostsScalarWhereInput | PostsScalarWhereInput[]
  }

  export type QuestionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionsCreateWithoutUserInput, QuestionsUncheckedCreateWithoutUserInput> | QuestionsCreateWithoutUserInput[] | QuestionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionsCreateOrConnectWithoutUserInput | QuestionsCreateOrConnectWithoutUserInput[]
    upsert?: QuestionsUpsertWithWhereUniqueWithoutUserInput | QuestionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionsCreateManyUserInputEnvelope
    set?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    disconnect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    delete?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    connect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    update?: QuestionsUpdateWithWhereUniqueWithoutUserInput | QuestionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionsUpdateManyWithWhereWithoutUserInput | QuestionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionsScalarWhereInput | QuestionsScalarWhereInput[]
  }

  export type FriendsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput> | FriendsCreateWithoutUserInput[] | FriendsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUserInput | FriendsCreateOrConnectWithoutUserInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutUserInput | FriendsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendsCreateManyUserInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutUserInput | FriendsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutUserInput | FriendsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type CertificationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificationsCreateWithoutUserInput, CertificationsUncheckedCreateWithoutUserInput> | CertificationsCreateWithoutUserInput[] | CertificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificationsCreateOrConnectWithoutUserInput | CertificationsCreateOrConnectWithoutUserInput[]
    upsert?: CertificationsUpsertWithWhereUniqueWithoutUserInput | CertificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificationsCreateManyUserInputEnvelope
    set?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
    disconnect?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
    delete?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
    connect?: CertificationsWhereUniqueInput | CertificationsWhereUniqueInput[]
    update?: CertificationsUpdateWithWhereUniqueWithoutUserInput | CertificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificationsUpdateManyWithWhereWithoutUserInput | CertificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificationsScalarWhereInput | CertificationsScalarWhereInput[]
  }

  export type MembershipsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipsCreateWithoutUserInput, MembershipsUncheckedCreateWithoutUserInput> | MembershipsCreateWithoutUserInput[] | MembershipsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipsCreateOrConnectWithoutUserInput | MembershipsCreateOrConnectWithoutUserInput[]
    upsert?: MembershipsUpsertWithWhereUniqueWithoutUserInput | MembershipsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipsCreateManyUserInputEnvelope
    set?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
    disconnect?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
    delete?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
    connect?: MembershipsWhereUniqueInput | MembershipsWhereUniqueInput[]
    update?: MembershipsUpdateWithWhereUniqueWithoutUserInput | MembershipsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipsUpdateManyWithWhereWithoutUserInput | MembershipsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipsScalarWhereInput | MembershipsScalarWhereInput[]
  }

  export type EducationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput> | EducationCreateWithoutUserInput[] | EducationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutUserInput | EducationCreateOrConnectWithoutUserInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutUserInput | EducationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EducationCreateManyUserInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutUserInput | EducationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutUserInput | EducationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfessionalExperienceCreateWithoutUserInput, ProfessionalExperienceUncheckedCreateWithoutUserInput> | ProfessionalExperienceCreateWithoutUserInput[] | ProfessionalExperienceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfessionalExperienceCreateOrConnectWithoutUserInput | ProfessionalExperienceCreateOrConnectWithoutUserInput[]
    upsert?: ProfessionalExperienceUpsertWithWhereUniqueWithoutUserInput | ProfessionalExperienceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfessionalExperienceCreateManyUserInputEnvelope
    set?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
    disconnect?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
    delete?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
    connect?: ProfessionalExperienceWhereUniqueInput | ProfessionalExperienceWhereUniqueInput[]
    update?: ProfessionalExperienceUpdateWithWhereUniqueWithoutUserInput | ProfessionalExperienceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfessionalExperienceUpdateManyWithWhereWithoutUserInput | ProfessionalExperienceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfessionalExperienceScalarWhereInput | ProfessionalExperienceScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobsCreateWithoutUserInput, JobsUncheckedCreateWithoutUserInput> | JobsCreateWithoutUserInput[] | JobsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutUserInput | JobsCreateOrConnectWithoutUserInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutUserInput | JobsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobsCreateManyUserInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutUserInput | JobsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutUserInput | JobsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type ConferrencesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConferrencesCreateWithoutUserInput, ConferrencesUncheckedCreateWithoutUserInput> | ConferrencesCreateWithoutUserInput[] | ConferrencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConferrencesCreateOrConnectWithoutUserInput | ConferrencesCreateOrConnectWithoutUserInput[]
    upsert?: ConferrencesUpsertWithWhereUniqueWithoutUserInput | ConferrencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConferrencesCreateManyUserInputEnvelope
    set?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
    disconnect?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
    delete?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
    connect?: ConferrencesWhereUniqueInput | ConferrencesWhereUniqueInput[]
    update?: ConferrencesUpdateWithWhereUniqueWithoutUserInput | ConferrencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConferrencesUpdateManyWithWhereWithoutUserInput | ConferrencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConferrencesScalarWhereInput | ConferrencesScalarWhereInput[]
  }

  export type AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementsAwardsCreateWithoutUserInput, AchievementsAwardsUncheckedCreateWithoutUserInput> | AchievementsAwardsCreateWithoutUserInput[] | AchievementsAwardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementsAwardsCreateOrConnectWithoutUserInput | AchievementsAwardsCreateOrConnectWithoutUserInput[]
    upsert?: AchievementsAwardsUpsertWithWhereUniqueWithoutUserInput | AchievementsAwardsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementsAwardsCreateManyUserInputEnvelope
    set?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
    disconnect?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
    delete?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
    connect?: AchievementsAwardsWhereUniqueInput | AchievementsAwardsWhereUniqueInput[]
    update?: AchievementsAwardsUpdateWithWhereUniqueWithoutUserInput | AchievementsAwardsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementsAwardsUpdateManyWithWhereWithoutUserInput | AchievementsAwardsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementsAwardsScalarWhereInput | AchievementsAwardsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsAwardsInput = {
    create?: XOR<UserCreateWithoutAchievementsAwardsInput, UserUncheckedCreateWithoutAchievementsAwardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsAwardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAchievementsAwardsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsAwardsInput, UserUncheckedCreateWithoutAchievementsAwardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsAwardsInput
    upsert?: UserUpsertWithoutAchievementsAwardsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsAwardsInput, UserUpdateWithoutAchievementsAwardsInput>, UserUncheckedUpdateWithoutAchievementsAwardsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutJobsInput = {
    create?: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutJobsNestedInput = {
    create?: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsInput
    upsert?: UserUpsertWithoutJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobsInput, UserUpdateWithoutJobsInput>, UserUncheckedUpdateWithoutJobsInput>
  }

  export type UserCreateNestedOneWithoutConferrencesInput = {
    create?: XOR<UserCreateWithoutConferrencesInput, UserUncheckedCreateWithoutConferrencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConferrencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutConferrencesNestedInput = {
    create?: XOR<UserCreateWithoutConferrencesInput, UserUncheckedCreateWithoutConferrencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConferrencesInput
    upsert?: UserUpsertWithoutConferrencesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConferrencesInput, UserUpdateWithoutConferrencesInput>, UserUncheckedUpdateWithoutConferrencesInput>
  }

  export type UserCreateNestedOneWithoutSkillsInput = {
    create?: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkillsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSkillsNestedInput = {
    create?: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkillsInput
    upsert?: UserUpsertWithoutSkillsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSkillsInput, UserUpdateWithoutSkillsInput>, UserUncheckedUpdateWithoutSkillsInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostImageLinksCreateNestedManyWithoutPostsInput = {
    create?: XOR<PostImageLinksCreateWithoutPostsInput, PostImageLinksUncheckedCreateWithoutPostsInput> | PostImageLinksCreateWithoutPostsInput[] | PostImageLinksUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostImageLinksCreateOrConnectWithoutPostsInput | PostImageLinksCreateOrConnectWithoutPostsInput[]
    createMany?: PostImageLinksCreateManyPostsInputEnvelope
    connect?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
  }

  export type CommentsCreateNestedManyWithoutPostsInput = {
    create?: XOR<CommentsCreateWithoutPostsInput, CommentsUncheckedCreateWithoutPostsInput> | CommentsCreateWithoutPostsInput[] | CommentsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutPostsInput | CommentsCreateOrConnectWithoutPostsInput[]
    createMany?: CommentsCreateManyPostsInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type LikesCreateNestedManyWithoutPostsInput = {
    create?: XOR<LikesCreateWithoutPostsInput, LikesUncheckedCreateWithoutPostsInput> | LikesCreateWithoutPostsInput[] | LikesUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: LikesCreateOrConnectWithoutPostsInput | LikesCreateOrConnectWithoutPostsInput[]
    createMany?: LikesCreateManyPostsInputEnvelope
    connect?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
  }

  export type RepostsCreateNestedManyWithoutPostsInput = {
    create?: XOR<RepostsCreateWithoutPostsInput, RepostsUncheckedCreateWithoutPostsInput> | RepostsCreateWithoutPostsInput[] | RepostsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: RepostsCreateOrConnectWithoutPostsInput | RepostsCreateOrConnectWithoutPostsInput[]
    createMany?: RepostsCreateManyPostsInputEnvelope
    connect?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
  }

  export type SharesCreateNestedManyWithoutPostsInput = {
    create?: XOR<SharesCreateWithoutPostsInput, SharesUncheckedCreateWithoutPostsInput> | SharesCreateWithoutPostsInput[] | SharesUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: SharesCreateOrConnectWithoutPostsInput | SharesCreateOrConnectWithoutPostsInput[]
    createMany?: SharesCreateManyPostsInputEnvelope
    connect?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
  }

  export type PostImageLinksUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<PostImageLinksCreateWithoutPostsInput, PostImageLinksUncheckedCreateWithoutPostsInput> | PostImageLinksCreateWithoutPostsInput[] | PostImageLinksUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostImageLinksCreateOrConnectWithoutPostsInput | PostImageLinksCreateOrConnectWithoutPostsInput[]
    createMany?: PostImageLinksCreateManyPostsInputEnvelope
    connect?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
  }

  export type CommentsUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<CommentsCreateWithoutPostsInput, CommentsUncheckedCreateWithoutPostsInput> | CommentsCreateWithoutPostsInput[] | CommentsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutPostsInput | CommentsCreateOrConnectWithoutPostsInput[]
    createMany?: CommentsCreateManyPostsInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type LikesUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<LikesCreateWithoutPostsInput, LikesUncheckedCreateWithoutPostsInput> | LikesCreateWithoutPostsInput[] | LikesUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: LikesCreateOrConnectWithoutPostsInput | LikesCreateOrConnectWithoutPostsInput[]
    createMany?: LikesCreateManyPostsInputEnvelope
    connect?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
  }

  export type RepostsUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<RepostsCreateWithoutPostsInput, RepostsUncheckedCreateWithoutPostsInput> | RepostsCreateWithoutPostsInput[] | RepostsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: RepostsCreateOrConnectWithoutPostsInput | RepostsCreateOrConnectWithoutPostsInput[]
    createMany?: RepostsCreateManyPostsInputEnvelope
    connect?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
  }

  export type SharesUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<SharesCreateWithoutPostsInput, SharesUncheckedCreateWithoutPostsInput> | SharesCreateWithoutPostsInput[] | SharesUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: SharesCreateOrConnectWithoutPostsInput | SharesCreateOrConnectWithoutPostsInput[]
    createMany?: SharesCreateManyPostsInputEnvelope
    connect?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type PostImageLinksUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PostImageLinksCreateWithoutPostsInput, PostImageLinksUncheckedCreateWithoutPostsInput> | PostImageLinksCreateWithoutPostsInput[] | PostImageLinksUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostImageLinksCreateOrConnectWithoutPostsInput | PostImageLinksCreateOrConnectWithoutPostsInput[]
    upsert?: PostImageLinksUpsertWithWhereUniqueWithoutPostsInput | PostImageLinksUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: PostImageLinksCreateManyPostsInputEnvelope
    set?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
    disconnect?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
    delete?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
    connect?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
    update?: PostImageLinksUpdateWithWhereUniqueWithoutPostsInput | PostImageLinksUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PostImageLinksUpdateManyWithWhereWithoutPostsInput | PostImageLinksUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PostImageLinksScalarWhereInput | PostImageLinksScalarWhereInput[]
  }

  export type CommentsUpdateManyWithoutPostsNestedInput = {
    create?: XOR<CommentsCreateWithoutPostsInput, CommentsUncheckedCreateWithoutPostsInput> | CommentsCreateWithoutPostsInput[] | CommentsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutPostsInput | CommentsCreateOrConnectWithoutPostsInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutPostsInput | CommentsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: CommentsCreateManyPostsInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutPostsInput | CommentsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutPostsInput | CommentsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type LikesUpdateManyWithoutPostsNestedInput = {
    create?: XOR<LikesCreateWithoutPostsInput, LikesUncheckedCreateWithoutPostsInput> | LikesCreateWithoutPostsInput[] | LikesUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: LikesCreateOrConnectWithoutPostsInput | LikesCreateOrConnectWithoutPostsInput[]
    upsert?: LikesUpsertWithWhereUniqueWithoutPostsInput | LikesUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: LikesCreateManyPostsInputEnvelope
    set?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
    disconnect?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
    delete?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
    connect?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
    update?: LikesUpdateWithWhereUniqueWithoutPostsInput | LikesUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: LikesUpdateManyWithWhereWithoutPostsInput | LikesUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: LikesScalarWhereInput | LikesScalarWhereInput[]
  }

  export type RepostsUpdateManyWithoutPostsNestedInput = {
    create?: XOR<RepostsCreateWithoutPostsInput, RepostsUncheckedCreateWithoutPostsInput> | RepostsCreateWithoutPostsInput[] | RepostsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: RepostsCreateOrConnectWithoutPostsInput | RepostsCreateOrConnectWithoutPostsInput[]
    upsert?: RepostsUpsertWithWhereUniqueWithoutPostsInput | RepostsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: RepostsCreateManyPostsInputEnvelope
    set?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
    disconnect?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
    delete?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
    connect?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
    update?: RepostsUpdateWithWhereUniqueWithoutPostsInput | RepostsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: RepostsUpdateManyWithWhereWithoutPostsInput | RepostsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: RepostsScalarWhereInput | RepostsScalarWhereInput[]
  }

  export type SharesUpdateManyWithoutPostsNestedInput = {
    create?: XOR<SharesCreateWithoutPostsInput, SharesUncheckedCreateWithoutPostsInput> | SharesCreateWithoutPostsInput[] | SharesUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: SharesCreateOrConnectWithoutPostsInput | SharesCreateOrConnectWithoutPostsInput[]
    upsert?: SharesUpsertWithWhereUniqueWithoutPostsInput | SharesUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: SharesCreateManyPostsInputEnvelope
    set?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
    disconnect?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
    delete?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
    connect?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
    update?: SharesUpdateWithWhereUniqueWithoutPostsInput | SharesUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: SharesUpdateManyWithWhereWithoutPostsInput | SharesUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: SharesScalarWhereInput | SharesScalarWhereInput[]
  }

  export type PostImageLinksUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PostImageLinksCreateWithoutPostsInput, PostImageLinksUncheckedCreateWithoutPostsInput> | PostImageLinksCreateWithoutPostsInput[] | PostImageLinksUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostImageLinksCreateOrConnectWithoutPostsInput | PostImageLinksCreateOrConnectWithoutPostsInput[]
    upsert?: PostImageLinksUpsertWithWhereUniqueWithoutPostsInput | PostImageLinksUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: PostImageLinksCreateManyPostsInputEnvelope
    set?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
    disconnect?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
    delete?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
    connect?: PostImageLinksWhereUniqueInput | PostImageLinksWhereUniqueInput[]
    update?: PostImageLinksUpdateWithWhereUniqueWithoutPostsInput | PostImageLinksUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PostImageLinksUpdateManyWithWhereWithoutPostsInput | PostImageLinksUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PostImageLinksScalarWhereInput | PostImageLinksScalarWhereInput[]
  }

  export type CommentsUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<CommentsCreateWithoutPostsInput, CommentsUncheckedCreateWithoutPostsInput> | CommentsCreateWithoutPostsInput[] | CommentsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutPostsInput | CommentsCreateOrConnectWithoutPostsInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutPostsInput | CommentsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: CommentsCreateManyPostsInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutPostsInput | CommentsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutPostsInput | CommentsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type LikesUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<LikesCreateWithoutPostsInput, LikesUncheckedCreateWithoutPostsInput> | LikesCreateWithoutPostsInput[] | LikesUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: LikesCreateOrConnectWithoutPostsInput | LikesCreateOrConnectWithoutPostsInput[]
    upsert?: LikesUpsertWithWhereUniqueWithoutPostsInput | LikesUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: LikesCreateManyPostsInputEnvelope
    set?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
    disconnect?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
    delete?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
    connect?: LikesWhereUniqueInput | LikesWhereUniqueInput[]
    update?: LikesUpdateWithWhereUniqueWithoutPostsInput | LikesUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: LikesUpdateManyWithWhereWithoutPostsInput | LikesUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: LikesScalarWhereInput | LikesScalarWhereInput[]
  }

  export type RepostsUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<RepostsCreateWithoutPostsInput, RepostsUncheckedCreateWithoutPostsInput> | RepostsCreateWithoutPostsInput[] | RepostsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: RepostsCreateOrConnectWithoutPostsInput | RepostsCreateOrConnectWithoutPostsInput[]
    upsert?: RepostsUpsertWithWhereUniqueWithoutPostsInput | RepostsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: RepostsCreateManyPostsInputEnvelope
    set?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
    disconnect?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
    delete?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
    connect?: RepostsWhereUniqueInput | RepostsWhereUniqueInput[]
    update?: RepostsUpdateWithWhereUniqueWithoutPostsInput | RepostsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: RepostsUpdateManyWithWhereWithoutPostsInput | RepostsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: RepostsScalarWhereInput | RepostsScalarWhereInput[]
  }

  export type SharesUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<SharesCreateWithoutPostsInput, SharesUncheckedCreateWithoutPostsInput> | SharesCreateWithoutPostsInput[] | SharesUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: SharesCreateOrConnectWithoutPostsInput | SharesCreateOrConnectWithoutPostsInput[]
    upsert?: SharesUpsertWithWhereUniqueWithoutPostsInput | SharesUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: SharesCreateManyPostsInputEnvelope
    set?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
    disconnect?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
    delete?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
    connect?: SharesWhereUniqueInput | SharesWhereUniqueInput[]
    update?: SharesUpdateWithWhereUniqueWithoutPostsInput | SharesUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: SharesUpdateManyWithWhereWithoutPostsInput | SharesUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: SharesScalarWhereInput | SharesScalarWhereInput[]
  }

  export type PostsCreateNestedOneWithoutPostImageLinksInput = {
    create?: XOR<PostsCreateWithoutPostImageLinksInput, PostsUncheckedCreateWithoutPostImageLinksInput>
    connectOrCreate?: PostsCreateOrConnectWithoutPostImageLinksInput
    connect?: PostsWhereUniqueInput
  }

  export type PostsUpdateOneWithoutPostImageLinksNestedInput = {
    create?: XOR<PostsCreateWithoutPostImageLinksInput, PostsUncheckedCreateWithoutPostImageLinksInput>
    connectOrCreate?: PostsCreateOrConnectWithoutPostImageLinksInput
    upsert?: PostsUpsertWithoutPostImageLinksInput
    disconnect?: PostsWhereInput | boolean
    delete?: PostsWhereInput | boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutPostImageLinksInput, PostsUpdateWithoutPostImageLinksInput>, PostsUncheckedUpdateWithoutPostImageLinksInput>
  }

  export type PostsCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostsCreateWithoutCommentsInput, PostsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutCommentsInput
    connect?: PostsWhereUniqueInput
  }

  export type PostsUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<PostsCreateWithoutCommentsInput, PostsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutCommentsInput
    upsert?: PostsUpsertWithoutCommentsInput
    disconnect?: PostsWhereInput | boolean
    delete?: PostsWhereInput | boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutCommentsInput, PostsUpdateWithoutCommentsInput>, PostsUncheckedUpdateWithoutCommentsInput>
  }

  export type PostsCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostsCreateWithoutLikesInput, PostsUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostsCreateOrConnectWithoutLikesInput
    connect?: PostsWhereUniqueInput
  }

  export type PostsUpdateOneWithoutLikesNestedInput = {
    create?: XOR<PostsCreateWithoutLikesInput, PostsUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostsCreateOrConnectWithoutLikesInput
    upsert?: PostsUpsertWithoutLikesInput
    disconnect?: PostsWhereInput | boolean
    delete?: PostsWhereInput | boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutLikesInput, PostsUpdateWithoutLikesInput>, PostsUncheckedUpdateWithoutLikesInput>
  }

  export type PostsCreateNestedOneWithoutRepostsInput = {
    create?: XOR<PostsCreateWithoutRepostsInput, PostsUncheckedCreateWithoutRepostsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutRepostsInput
    connect?: PostsWhereUniqueInput
  }

  export type PostsUpdateOneWithoutRepostsNestedInput = {
    create?: XOR<PostsCreateWithoutRepostsInput, PostsUncheckedCreateWithoutRepostsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutRepostsInput
    upsert?: PostsUpsertWithoutRepostsInput
    disconnect?: PostsWhereInput | boolean
    delete?: PostsWhereInput | boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutRepostsInput, PostsUpdateWithoutRepostsInput>, PostsUncheckedUpdateWithoutRepostsInput>
  }

  export type PostsCreateNestedOneWithoutSharesInput = {
    create?: XOR<PostsCreateWithoutSharesInput, PostsUncheckedCreateWithoutSharesInput>
    connectOrCreate?: PostsCreateOrConnectWithoutSharesInput
    connect?: PostsWhereUniqueInput
  }

  export type PostsUpdateOneWithoutSharesNestedInput = {
    create?: XOR<PostsCreateWithoutSharesInput, PostsUncheckedCreateWithoutSharesInput>
    connectOrCreate?: PostsCreateOrConnectWithoutSharesInput
    upsert?: PostsUpsertWithoutSharesInput
    disconnect?: PostsWhereInput | boolean
    delete?: PostsWhereInput | boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutSharesInput, PostsUpdateWithoutSharesInput>, PostsUncheckedUpdateWithoutSharesInput>
  }

  export type UserCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionImageLinksCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<QuestionImageLinksCreateWithoutQuestionsInput, QuestionImageLinksUncheckedCreateWithoutQuestionsInput> | QuestionImageLinksCreateWithoutQuestionsInput[] | QuestionImageLinksUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionImageLinksCreateOrConnectWithoutQuestionsInput | QuestionImageLinksCreateOrConnectWithoutQuestionsInput[]
    createMany?: QuestionImageLinksCreateManyQuestionsInputEnvelope
    connect?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
  }

  export type InsightfulCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<InsightfulCreateWithoutQuestionsInput, InsightfulUncheckedCreateWithoutQuestionsInput> | InsightfulCreateWithoutQuestionsInput[] | InsightfulUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: InsightfulCreateOrConnectWithoutQuestionsInput | InsightfulCreateOrConnectWithoutQuestionsInput[]
    createMany?: InsightfulCreateManyQuestionsInputEnvelope
    connect?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
  }

  export type AnswersCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<AnswersCreateWithoutQuestionsInput, AnswersUncheckedCreateWithoutQuestionsInput> | AnswersCreateWithoutQuestionsInput[] | AnswersUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutQuestionsInput | AnswersCreateOrConnectWithoutQuestionsInput[]
    createMany?: AnswersCreateManyQuestionsInputEnvelope
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
  }

  export type QuestionCommentsCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<QuestionCommentsCreateWithoutQuestionsInput, QuestionCommentsUncheckedCreateWithoutQuestionsInput> | QuestionCommentsCreateWithoutQuestionsInput[] | QuestionCommentsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionCommentsCreateOrConnectWithoutQuestionsInput | QuestionCommentsCreateOrConnectWithoutQuestionsInput[]
    createMany?: QuestionCommentsCreateManyQuestionsInputEnvelope
    connect?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
  }

  export type QuestionReferencesCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<QuestionReferencesCreateWithoutQuestionsInput, QuestionReferencesUncheckedCreateWithoutQuestionsInput> | QuestionReferencesCreateWithoutQuestionsInput[] | QuestionReferencesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionReferencesCreateOrConnectWithoutQuestionsInput | QuestionReferencesCreateOrConnectWithoutQuestionsInput[]
    createMany?: QuestionReferencesCreateManyQuestionsInputEnvelope
    connect?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
  }

  export type QuestionImageLinksUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<QuestionImageLinksCreateWithoutQuestionsInput, QuestionImageLinksUncheckedCreateWithoutQuestionsInput> | QuestionImageLinksCreateWithoutQuestionsInput[] | QuestionImageLinksUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionImageLinksCreateOrConnectWithoutQuestionsInput | QuestionImageLinksCreateOrConnectWithoutQuestionsInput[]
    createMany?: QuestionImageLinksCreateManyQuestionsInputEnvelope
    connect?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
  }

  export type InsightfulUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<InsightfulCreateWithoutQuestionsInput, InsightfulUncheckedCreateWithoutQuestionsInput> | InsightfulCreateWithoutQuestionsInput[] | InsightfulUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: InsightfulCreateOrConnectWithoutQuestionsInput | InsightfulCreateOrConnectWithoutQuestionsInput[]
    createMany?: InsightfulCreateManyQuestionsInputEnvelope
    connect?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
  }

  export type AnswersUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<AnswersCreateWithoutQuestionsInput, AnswersUncheckedCreateWithoutQuestionsInput> | AnswersCreateWithoutQuestionsInput[] | AnswersUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutQuestionsInput | AnswersCreateOrConnectWithoutQuestionsInput[]
    createMany?: AnswersCreateManyQuestionsInputEnvelope
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
  }

  export type QuestionCommentsUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<QuestionCommentsCreateWithoutQuestionsInput, QuestionCommentsUncheckedCreateWithoutQuestionsInput> | QuestionCommentsCreateWithoutQuestionsInput[] | QuestionCommentsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionCommentsCreateOrConnectWithoutQuestionsInput | QuestionCommentsCreateOrConnectWithoutQuestionsInput[]
    createMany?: QuestionCommentsCreateManyQuestionsInputEnvelope
    connect?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
  }

  export type QuestionReferencesUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<QuestionReferencesCreateWithoutQuestionsInput, QuestionReferencesUncheckedCreateWithoutQuestionsInput> | QuestionReferencesCreateWithoutQuestionsInput[] | QuestionReferencesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionReferencesCreateOrConnectWithoutQuestionsInput | QuestionReferencesCreateOrConnectWithoutQuestionsInput[]
    createMany?: QuestionReferencesCreateManyQuestionsInputEnvelope
    connect?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsInput
    upsert?: UserUpsertWithoutQuestionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuestionsInput, UserUpdateWithoutQuestionsInput>, UserUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionImageLinksUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<QuestionImageLinksCreateWithoutQuestionsInput, QuestionImageLinksUncheckedCreateWithoutQuestionsInput> | QuestionImageLinksCreateWithoutQuestionsInput[] | QuestionImageLinksUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionImageLinksCreateOrConnectWithoutQuestionsInput | QuestionImageLinksCreateOrConnectWithoutQuestionsInput[]
    upsert?: QuestionImageLinksUpsertWithWhereUniqueWithoutQuestionsInput | QuestionImageLinksUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: QuestionImageLinksCreateManyQuestionsInputEnvelope
    set?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
    disconnect?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
    delete?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
    connect?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
    update?: QuestionImageLinksUpdateWithWhereUniqueWithoutQuestionsInput | QuestionImageLinksUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: QuestionImageLinksUpdateManyWithWhereWithoutQuestionsInput | QuestionImageLinksUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: QuestionImageLinksScalarWhereInput | QuestionImageLinksScalarWhereInput[]
  }

  export type InsightfulUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<InsightfulCreateWithoutQuestionsInput, InsightfulUncheckedCreateWithoutQuestionsInput> | InsightfulCreateWithoutQuestionsInput[] | InsightfulUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: InsightfulCreateOrConnectWithoutQuestionsInput | InsightfulCreateOrConnectWithoutQuestionsInput[]
    upsert?: InsightfulUpsertWithWhereUniqueWithoutQuestionsInput | InsightfulUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: InsightfulCreateManyQuestionsInputEnvelope
    set?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
    disconnect?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
    delete?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
    connect?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
    update?: InsightfulUpdateWithWhereUniqueWithoutQuestionsInput | InsightfulUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: InsightfulUpdateManyWithWhereWithoutQuestionsInput | InsightfulUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: InsightfulScalarWhereInput | InsightfulScalarWhereInput[]
  }

  export type AnswersUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<AnswersCreateWithoutQuestionsInput, AnswersUncheckedCreateWithoutQuestionsInput> | AnswersCreateWithoutQuestionsInput[] | AnswersUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutQuestionsInput | AnswersCreateOrConnectWithoutQuestionsInput[]
    upsert?: AnswersUpsertWithWhereUniqueWithoutQuestionsInput | AnswersUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: AnswersCreateManyQuestionsInputEnvelope
    set?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    disconnect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    delete?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    update?: AnswersUpdateWithWhereUniqueWithoutQuestionsInput | AnswersUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: AnswersUpdateManyWithWhereWithoutQuestionsInput | AnswersUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
  }

  export type QuestionCommentsUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<QuestionCommentsCreateWithoutQuestionsInput, QuestionCommentsUncheckedCreateWithoutQuestionsInput> | QuestionCommentsCreateWithoutQuestionsInput[] | QuestionCommentsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionCommentsCreateOrConnectWithoutQuestionsInput | QuestionCommentsCreateOrConnectWithoutQuestionsInput[]
    upsert?: QuestionCommentsUpsertWithWhereUniqueWithoutQuestionsInput | QuestionCommentsUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: QuestionCommentsCreateManyQuestionsInputEnvelope
    set?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
    disconnect?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
    delete?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
    connect?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
    update?: QuestionCommentsUpdateWithWhereUniqueWithoutQuestionsInput | QuestionCommentsUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: QuestionCommentsUpdateManyWithWhereWithoutQuestionsInput | QuestionCommentsUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: QuestionCommentsScalarWhereInput | QuestionCommentsScalarWhereInput[]
  }

  export type QuestionReferencesUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<QuestionReferencesCreateWithoutQuestionsInput, QuestionReferencesUncheckedCreateWithoutQuestionsInput> | QuestionReferencesCreateWithoutQuestionsInput[] | QuestionReferencesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionReferencesCreateOrConnectWithoutQuestionsInput | QuestionReferencesCreateOrConnectWithoutQuestionsInput[]
    upsert?: QuestionReferencesUpsertWithWhereUniqueWithoutQuestionsInput | QuestionReferencesUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: QuestionReferencesCreateManyQuestionsInputEnvelope
    set?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
    disconnect?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
    delete?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
    connect?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
    update?: QuestionReferencesUpdateWithWhereUniqueWithoutQuestionsInput | QuestionReferencesUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: QuestionReferencesUpdateManyWithWhereWithoutQuestionsInput | QuestionReferencesUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: QuestionReferencesScalarWhereInput | QuestionReferencesScalarWhereInput[]
  }

  export type QuestionImageLinksUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<QuestionImageLinksCreateWithoutQuestionsInput, QuestionImageLinksUncheckedCreateWithoutQuestionsInput> | QuestionImageLinksCreateWithoutQuestionsInput[] | QuestionImageLinksUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionImageLinksCreateOrConnectWithoutQuestionsInput | QuestionImageLinksCreateOrConnectWithoutQuestionsInput[]
    upsert?: QuestionImageLinksUpsertWithWhereUniqueWithoutQuestionsInput | QuestionImageLinksUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: QuestionImageLinksCreateManyQuestionsInputEnvelope
    set?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
    disconnect?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
    delete?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
    connect?: QuestionImageLinksWhereUniqueInput | QuestionImageLinksWhereUniqueInput[]
    update?: QuestionImageLinksUpdateWithWhereUniqueWithoutQuestionsInput | QuestionImageLinksUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: QuestionImageLinksUpdateManyWithWhereWithoutQuestionsInput | QuestionImageLinksUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: QuestionImageLinksScalarWhereInput | QuestionImageLinksScalarWhereInput[]
  }

  export type InsightfulUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<InsightfulCreateWithoutQuestionsInput, InsightfulUncheckedCreateWithoutQuestionsInput> | InsightfulCreateWithoutQuestionsInput[] | InsightfulUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: InsightfulCreateOrConnectWithoutQuestionsInput | InsightfulCreateOrConnectWithoutQuestionsInput[]
    upsert?: InsightfulUpsertWithWhereUniqueWithoutQuestionsInput | InsightfulUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: InsightfulCreateManyQuestionsInputEnvelope
    set?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
    disconnect?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
    delete?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
    connect?: InsightfulWhereUniqueInput | InsightfulWhereUniqueInput[]
    update?: InsightfulUpdateWithWhereUniqueWithoutQuestionsInput | InsightfulUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: InsightfulUpdateManyWithWhereWithoutQuestionsInput | InsightfulUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: InsightfulScalarWhereInput | InsightfulScalarWhereInput[]
  }

  export type AnswersUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<AnswersCreateWithoutQuestionsInput, AnswersUncheckedCreateWithoutQuestionsInput> | AnswersCreateWithoutQuestionsInput[] | AnswersUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutQuestionsInput | AnswersCreateOrConnectWithoutQuestionsInput[]
    upsert?: AnswersUpsertWithWhereUniqueWithoutQuestionsInput | AnswersUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: AnswersCreateManyQuestionsInputEnvelope
    set?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    disconnect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    delete?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    update?: AnswersUpdateWithWhereUniqueWithoutQuestionsInput | AnswersUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: AnswersUpdateManyWithWhereWithoutQuestionsInput | AnswersUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
  }

  export type QuestionCommentsUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<QuestionCommentsCreateWithoutQuestionsInput, QuestionCommentsUncheckedCreateWithoutQuestionsInput> | QuestionCommentsCreateWithoutQuestionsInput[] | QuestionCommentsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionCommentsCreateOrConnectWithoutQuestionsInput | QuestionCommentsCreateOrConnectWithoutQuestionsInput[]
    upsert?: QuestionCommentsUpsertWithWhereUniqueWithoutQuestionsInput | QuestionCommentsUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: QuestionCommentsCreateManyQuestionsInputEnvelope
    set?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
    disconnect?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
    delete?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
    connect?: QuestionCommentsWhereUniqueInput | QuestionCommentsWhereUniqueInput[]
    update?: QuestionCommentsUpdateWithWhereUniqueWithoutQuestionsInput | QuestionCommentsUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: QuestionCommentsUpdateManyWithWhereWithoutQuestionsInput | QuestionCommentsUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: QuestionCommentsScalarWhereInput | QuestionCommentsScalarWhereInput[]
  }

  export type QuestionReferencesUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<QuestionReferencesCreateWithoutQuestionsInput, QuestionReferencesUncheckedCreateWithoutQuestionsInput> | QuestionReferencesCreateWithoutQuestionsInput[] | QuestionReferencesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionReferencesCreateOrConnectWithoutQuestionsInput | QuestionReferencesCreateOrConnectWithoutQuestionsInput[]
    upsert?: QuestionReferencesUpsertWithWhereUniqueWithoutQuestionsInput | QuestionReferencesUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: QuestionReferencesCreateManyQuestionsInputEnvelope
    set?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
    disconnect?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
    delete?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
    connect?: QuestionReferencesWhereUniqueInput | QuestionReferencesWhereUniqueInput[]
    update?: QuestionReferencesUpdateWithWhereUniqueWithoutQuestionsInput | QuestionReferencesUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: QuestionReferencesUpdateManyWithWhereWithoutQuestionsInput | QuestionReferencesUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: QuestionReferencesScalarWhereInput | QuestionReferencesScalarWhereInput[]
  }

  export type QuestionsCreateNestedOneWithoutQuestionReferencesInput = {
    create?: XOR<QuestionsCreateWithoutQuestionReferencesInput, QuestionsUncheckedCreateWithoutQuestionReferencesInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutQuestionReferencesInput
    connect?: QuestionsWhereUniqueInput
  }

  export type QuestionsUpdateOneWithoutQuestionReferencesNestedInput = {
    create?: XOR<QuestionsCreateWithoutQuestionReferencesInput, QuestionsUncheckedCreateWithoutQuestionReferencesInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutQuestionReferencesInput
    upsert?: QuestionsUpsertWithoutQuestionReferencesInput
    disconnect?: QuestionsWhereInput | boolean
    delete?: QuestionsWhereInput | boolean
    connect?: QuestionsWhereUniqueInput
    update?: XOR<XOR<QuestionsUpdateToOneWithWhereWithoutQuestionReferencesInput, QuestionsUpdateWithoutQuestionReferencesInput>, QuestionsUncheckedUpdateWithoutQuestionReferencesInput>
  }

  export type QuestionsCreateNestedOneWithoutQuestionCommentsInput = {
    create?: XOR<QuestionsCreateWithoutQuestionCommentsInput, QuestionsUncheckedCreateWithoutQuestionCommentsInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutQuestionCommentsInput
    connect?: QuestionsWhereUniqueInput
  }

  export type QuestionsUpdateOneWithoutQuestionCommentsNestedInput = {
    create?: XOR<QuestionsCreateWithoutQuestionCommentsInput, QuestionsUncheckedCreateWithoutQuestionCommentsInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutQuestionCommentsInput
    upsert?: QuestionsUpsertWithoutQuestionCommentsInput
    disconnect?: QuestionsWhereInput | boolean
    delete?: QuestionsWhereInput | boolean
    connect?: QuestionsWhereUniqueInput
    update?: XOR<XOR<QuestionsUpdateToOneWithWhereWithoutQuestionCommentsInput, QuestionsUpdateWithoutQuestionCommentsInput>, QuestionsUncheckedUpdateWithoutQuestionCommentsInput>
  }

  export type QuestionsCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionsCreateWithoutAnswersInput, QuestionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutAnswersInput
    connect?: QuestionsWhereUniqueInput
  }

  export type Answer_Image_LinksCreateNestedManyWithoutAnswersInput = {
    create?: XOR<Answer_Image_LinksCreateWithoutAnswersInput, Answer_Image_LinksUncheckedCreateWithoutAnswersInput> | Answer_Image_LinksCreateWithoutAnswersInput[] | Answer_Image_LinksUncheckedCreateWithoutAnswersInput[]
    connectOrCreate?: Answer_Image_LinksCreateOrConnectWithoutAnswersInput | Answer_Image_LinksCreateOrConnectWithoutAnswersInput[]
    createMany?: Answer_Image_LinksCreateManyAnswersInputEnvelope
    connect?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
  }

  export type Answer_Image_LinksUncheckedCreateNestedManyWithoutAnswersInput = {
    create?: XOR<Answer_Image_LinksCreateWithoutAnswersInput, Answer_Image_LinksUncheckedCreateWithoutAnswersInput> | Answer_Image_LinksCreateWithoutAnswersInput[] | Answer_Image_LinksUncheckedCreateWithoutAnswersInput[]
    connectOrCreate?: Answer_Image_LinksCreateOrConnectWithoutAnswersInput | Answer_Image_LinksCreateOrConnectWithoutAnswersInput[]
    createMany?: Answer_Image_LinksCreateManyAnswersInputEnvelope
    connect?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
  }

  export type QuestionsUpdateOneWithoutAnswersNestedInput = {
    create?: XOR<QuestionsCreateWithoutAnswersInput, QuestionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutAnswersInput
    upsert?: QuestionsUpsertWithoutAnswersInput
    disconnect?: QuestionsWhereInput | boolean
    delete?: QuestionsWhereInput | boolean
    connect?: QuestionsWhereUniqueInput
    update?: XOR<XOR<QuestionsUpdateToOneWithWhereWithoutAnswersInput, QuestionsUpdateWithoutAnswersInput>, QuestionsUncheckedUpdateWithoutAnswersInput>
  }

  export type Answer_Image_LinksUpdateManyWithoutAnswersNestedInput = {
    create?: XOR<Answer_Image_LinksCreateWithoutAnswersInput, Answer_Image_LinksUncheckedCreateWithoutAnswersInput> | Answer_Image_LinksCreateWithoutAnswersInput[] | Answer_Image_LinksUncheckedCreateWithoutAnswersInput[]
    connectOrCreate?: Answer_Image_LinksCreateOrConnectWithoutAnswersInput | Answer_Image_LinksCreateOrConnectWithoutAnswersInput[]
    upsert?: Answer_Image_LinksUpsertWithWhereUniqueWithoutAnswersInput | Answer_Image_LinksUpsertWithWhereUniqueWithoutAnswersInput[]
    createMany?: Answer_Image_LinksCreateManyAnswersInputEnvelope
    set?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
    disconnect?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
    delete?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
    connect?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
    update?: Answer_Image_LinksUpdateWithWhereUniqueWithoutAnswersInput | Answer_Image_LinksUpdateWithWhereUniqueWithoutAnswersInput[]
    updateMany?: Answer_Image_LinksUpdateManyWithWhereWithoutAnswersInput | Answer_Image_LinksUpdateManyWithWhereWithoutAnswersInput[]
    deleteMany?: Answer_Image_LinksScalarWhereInput | Answer_Image_LinksScalarWhereInput[]
  }

  export type Answer_Image_LinksUncheckedUpdateManyWithoutAnswersNestedInput = {
    create?: XOR<Answer_Image_LinksCreateWithoutAnswersInput, Answer_Image_LinksUncheckedCreateWithoutAnswersInput> | Answer_Image_LinksCreateWithoutAnswersInput[] | Answer_Image_LinksUncheckedCreateWithoutAnswersInput[]
    connectOrCreate?: Answer_Image_LinksCreateOrConnectWithoutAnswersInput | Answer_Image_LinksCreateOrConnectWithoutAnswersInput[]
    upsert?: Answer_Image_LinksUpsertWithWhereUniqueWithoutAnswersInput | Answer_Image_LinksUpsertWithWhereUniqueWithoutAnswersInput[]
    createMany?: Answer_Image_LinksCreateManyAnswersInputEnvelope
    set?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
    disconnect?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
    delete?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
    connect?: Answer_Image_LinksWhereUniqueInput | Answer_Image_LinksWhereUniqueInput[]
    update?: Answer_Image_LinksUpdateWithWhereUniqueWithoutAnswersInput | Answer_Image_LinksUpdateWithWhereUniqueWithoutAnswersInput[]
    updateMany?: Answer_Image_LinksUpdateManyWithWhereWithoutAnswersInput | Answer_Image_LinksUpdateManyWithWhereWithoutAnswersInput[]
    deleteMany?: Answer_Image_LinksScalarWhereInput | Answer_Image_LinksScalarWhereInput[]
  }

  export type AnswersCreateNestedOneWithoutAnswer_image_linksInput = {
    create?: XOR<AnswersCreateWithoutAnswer_image_linksInput, AnswersUncheckedCreateWithoutAnswer_image_linksInput>
    connectOrCreate?: AnswersCreateOrConnectWithoutAnswer_image_linksInput
    connect?: AnswersWhereUniqueInput
  }

  export type AnswersUpdateOneWithoutAnswer_image_linksNestedInput = {
    create?: XOR<AnswersCreateWithoutAnswer_image_linksInput, AnswersUncheckedCreateWithoutAnswer_image_linksInput>
    connectOrCreate?: AnswersCreateOrConnectWithoutAnswer_image_linksInput
    upsert?: AnswersUpsertWithoutAnswer_image_linksInput
    disconnect?: AnswersWhereInput | boolean
    delete?: AnswersWhereInput | boolean
    connect?: AnswersWhereUniqueInput
    update?: XOR<XOR<AnswersUpdateToOneWithWhereWithoutAnswer_image_linksInput, AnswersUpdateWithoutAnswer_image_linksInput>, AnswersUncheckedUpdateWithoutAnswer_image_linksInput>
  }

  export type QuestionsCreateNestedOneWithoutQuestion_image_linksInput = {
    create?: XOR<QuestionsCreateWithoutQuestion_image_linksInput, QuestionsUncheckedCreateWithoutQuestion_image_linksInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutQuestion_image_linksInput
    connect?: QuestionsWhereUniqueInput
  }

  export type QuestionsUpdateOneWithoutQuestion_image_linksNestedInput = {
    create?: XOR<QuestionsCreateWithoutQuestion_image_linksInput, QuestionsUncheckedCreateWithoutQuestion_image_linksInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutQuestion_image_linksInput
    upsert?: QuestionsUpsertWithoutQuestion_image_linksInput
    disconnect?: QuestionsWhereInput | boolean
    delete?: QuestionsWhereInput | boolean
    connect?: QuestionsWhereUniqueInput
    update?: XOR<XOR<QuestionsUpdateToOneWithWhereWithoutQuestion_image_linksInput, QuestionsUpdateWithoutQuestion_image_linksInput>, QuestionsUncheckedUpdateWithoutQuestion_image_linksInput>
  }

  export type QuestionsCreateNestedOneWithoutInsightfulInput = {
    create?: XOR<QuestionsCreateWithoutInsightfulInput, QuestionsUncheckedCreateWithoutInsightfulInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutInsightfulInput
    connect?: QuestionsWhereUniqueInput
  }

  export type QuestionsUpdateOneWithoutInsightfulNestedInput = {
    create?: XOR<QuestionsCreateWithoutInsightfulInput, QuestionsUncheckedCreateWithoutInsightfulInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutInsightfulInput
    upsert?: QuestionsUpsertWithoutInsightfulInput
    disconnect?: QuestionsWhereInput | boolean
    delete?: QuestionsWhereInput | boolean
    connect?: QuestionsWhereUniqueInput
    update?: XOR<XOR<QuestionsUpdateToOneWithWhereWithoutInsightfulInput, QuestionsUpdateWithoutInsightfulInput>, QuestionsUncheckedUpdateWithoutInsightfulInput>
  }

  export type UserCreateNestedOneWithoutFriendsInput = {
    create?: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutFriendsNestedInput = {
    create?: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendsInput
    upsert?: UserUpsertWithoutFriendsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendsInput, UserUpdateWithoutFriendsInput>, UserUncheckedUpdateWithoutFriendsInput>
  }

  export type UserCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutCertificationsNestedInput = {
    create?: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificationsInput
    upsert?: UserUpsertWithoutCertificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificationsInput, UserUpdateWithoutCertificationsInput>, UserUncheckedUpdateWithoutCertificationsInput>
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserCreateNestedOneWithoutEducationInput = {
    create?: XOR<UserCreateWithoutEducationInput, UserUncheckedCreateWithoutEducationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEducationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutEducationNestedInput = {
    create?: XOR<UserCreateWithoutEducationInput, UserUncheckedCreateWithoutEducationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEducationInput
    upsert?: UserUpsertWithoutEducationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEducationInput, UserUpdateWithoutEducationInput>, UserUncheckedUpdateWithoutEducationInput>
  }

  export type UserCreateNestedOneWithoutProfessionalExperienceInput = {
    create?: XOR<UserCreateWithoutProfessionalExperienceInput, UserUncheckedCreateWithoutProfessionalExperienceInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfessionalExperienceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutProfessionalExperienceNestedInput = {
    create?: XOR<UserCreateWithoutProfessionalExperienceInput, UserUncheckedCreateWithoutProfessionalExperienceInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfessionalExperienceInput
    upsert?: UserUpsertWithoutProfessionalExperienceInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfessionalExperienceInput, UserUpdateWithoutProfessionalExperienceInput>, UserUncheckedUpdateWithoutProfessionalExperienceInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SkillsCreateWithoutUserInput = {
    skill: string
  }

  export type SkillsUncheckedCreateWithoutUserInput = {
    id?: number
    skill: string
  }

  export type SkillsCreateOrConnectWithoutUserInput = {
    where: SkillsWhereUniqueInput
    create: XOR<SkillsCreateWithoutUserInput, SkillsUncheckedCreateWithoutUserInput>
  }

  export type SkillsCreateManyUserInputEnvelope = {
    data: SkillsCreateManyUserInput | SkillsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostsCreateWithoutUserInput = {
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    postImageLinks?: PostImageLinksCreateNestedManyWithoutPostsInput
    comments?: CommentsCreateNestedManyWithoutPostsInput
    likes?: LikesCreateNestedManyWithoutPostsInput
    reposts?: RepostsCreateNestedManyWithoutPostsInput
    shares?: SharesCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutUserInput = {
    id?: number
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    postImageLinks?: PostImageLinksUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentsUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikesUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RepostsUncheckedCreateNestedManyWithoutPostsInput
    shares?: SharesUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutUserInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput>
  }

  export type PostsCreateManyUserInputEnvelope = {
    data: PostsCreateManyUserInput | PostsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuestionsCreateWithoutUserInput = {
    question: string
    question_description: string
    asked_at?: Date | string
    question_image_links?: QuestionImageLinksCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulCreateNestedManyWithoutQuestionsInput
    answers?: AnswersCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateWithoutUserInput = {
    id?: number
    question: string
    question_description: string
    asked_at?: Date | string
    question_image_links?: QuestionImageLinksUncheckedCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulUncheckedCreateNestedManyWithoutQuestionsInput
    answers?: AnswersUncheckedCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsUncheckedCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsCreateOrConnectWithoutUserInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutUserInput, QuestionsUncheckedCreateWithoutUserInput>
  }

  export type QuestionsCreateManyUserInputEnvelope = {
    data: QuestionsCreateManyUserInput | QuestionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FriendsCreateWithoutUserInput = {

  }

  export type FriendsUncheckedCreateWithoutUserInput = {
    id?: number
  }

  export type FriendsCreateOrConnectWithoutUserInput = {
    where: FriendsWhereUniqueInput
    create: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput>
  }

  export type FriendsCreateManyUserInputEnvelope = {
    data: FriendsCreateManyUserInput | FriendsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CertificationsCreateWithoutUserInput = {
    certificateName?: string | null
    issuingOrganisation?: string | null
    issueDate?: string | null
    descreption?: string | null
    certificateURL?: string | null
    certificateMediaLink?: string | null
  }

  export type CertificationsUncheckedCreateWithoutUserInput = {
    id?: number
    certificateName?: string | null
    issuingOrganisation?: string | null
    issueDate?: string | null
    descreption?: string | null
    certificateURL?: string | null
    certificateMediaLink?: string | null
  }

  export type CertificationsCreateOrConnectWithoutUserInput = {
    where: CertificationsWhereUniqueInput
    create: XOR<CertificationsCreateWithoutUserInput, CertificationsUncheckedCreateWithoutUserInput>
  }

  export type CertificationsCreateManyUserInputEnvelope = {
    data: CertificationsCreateManyUserInput | CertificationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MembershipsCreateWithoutUserInput = {
    societyname?: string | null
    position?: string | null
    relatedDepartment?: string | null
    membershipId?: string | null
  }

  export type MembershipsUncheckedCreateWithoutUserInput = {
    id?: number
    societyname?: string | null
    position?: string | null
    relatedDepartment?: string | null
    membershipId?: string | null
  }

  export type MembershipsCreateOrConnectWithoutUserInput = {
    where: MembershipsWhereUniqueInput
    create: XOR<MembershipsCreateWithoutUserInput, MembershipsUncheckedCreateWithoutUserInput>
  }

  export type MembershipsCreateManyUserInputEnvelope = {
    data: MembershipsCreateManyUserInput | MembershipsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EducationCreateWithoutUserInput = {
    schoolName?: string | null
    degree?: string | null
    department?: string | null
    startDate?: string | null
    endDate?: string | null
    grade?: string | null
  }

  export type EducationUncheckedCreateWithoutUserInput = {
    id?: number
    schoolName?: string | null
    degree?: string | null
    department?: string | null
    startDate?: string | null
    endDate?: string | null
    grade?: string | null
  }

  export type EducationCreateOrConnectWithoutUserInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput>
  }

  export type EducationCreateManyUserInputEnvelope = {
    data: EducationCreateManyUserInput | EducationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfessionalExperienceCreateWithoutUserInput = {
    title?: string | null
    organisation?: string | null
    startDate?: string | null
    endDate?: string | null
    location?: string | null
  }

  export type ProfessionalExperienceUncheckedCreateWithoutUserInput = {
    id?: number
    title?: string | null
    organisation?: string | null
    startDate?: string | null
    endDate?: string | null
    location?: string | null
  }

  export type ProfessionalExperienceCreateOrConnectWithoutUserInput = {
    where: ProfessionalExperienceWhereUniqueInput
    create: XOR<ProfessionalExperienceCreateWithoutUserInput, ProfessionalExperienceUncheckedCreateWithoutUserInput>
  }

  export type ProfessionalExperienceCreateManyUserInputEnvelope = {
    data: ProfessionalExperienceCreateManyUserInput | ProfessionalExperienceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutUserInput = {

  }

  export type JobsUncheckedCreateWithoutUserInput = {
    id?: number
  }

  export type JobsCreateOrConnectWithoutUserInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutUserInput, JobsUncheckedCreateWithoutUserInput>
  }

  export type JobsCreateManyUserInputEnvelope = {
    data: JobsCreateManyUserInput | JobsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConferrencesCreateWithoutUserInput = {

  }

  export type ConferrencesUncheckedCreateWithoutUserInput = {
    id?: number
  }

  export type ConferrencesCreateOrConnectWithoutUserInput = {
    where: ConferrencesWhereUniqueInput
    create: XOR<ConferrencesCreateWithoutUserInput, ConferrencesUncheckedCreateWithoutUserInput>
  }

  export type ConferrencesCreateManyUserInputEnvelope = {
    data: ConferrencesCreateManyUserInput | ConferrencesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AchievementsAwardsCreateWithoutUserInput = {
    awardName?: string | null
    awardedBy?: string | null
    awardedOn?: string | null
    descreption?: string | null
  }

  export type AchievementsAwardsUncheckedCreateWithoutUserInput = {
    id?: number
    awardName?: string | null
    awardedBy?: string | null
    awardedOn?: string | null
    descreption?: string | null
  }

  export type AchievementsAwardsCreateOrConnectWithoutUserInput = {
    where: AchievementsAwardsWhereUniqueInput
    create: XOR<AchievementsAwardsCreateWithoutUserInput, AchievementsAwardsUncheckedCreateWithoutUserInput>
  }

  export type AchievementsAwardsCreateManyUserInputEnvelope = {
    data: AchievementsAwardsCreateManyUserInput | AchievementsAwardsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SkillsUpsertWithWhereUniqueWithoutUserInput = {
    where: SkillsWhereUniqueInput
    update: XOR<SkillsUpdateWithoutUserInput, SkillsUncheckedUpdateWithoutUserInput>
    create: XOR<SkillsCreateWithoutUserInput, SkillsUncheckedCreateWithoutUserInput>
  }

  export type SkillsUpdateWithWhereUniqueWithoutUserInput = {
    where: SkillsWhereUniqueInput
    data: XOR<SkillsUpdateWithoutUserInput, SkillsUncheckedUpdateWithoutUserInput>
  }

  export type SkillsUpdateManyWithWhereWithoutUserInput = {
    where: SkillsScalarWhereInput
    data: XOR<SkillsUpdateManyMutationInput, SkillsUncheckedUpdateManyWithoutUserInput>
  }

  export type SkillsScalarWhereInput = {
    AND?: SkillsScalarWhereInput | SkillsScalarWhereInput[]
    OR?: SkillsScalarWhereInput[]
    NOT?: SkillsScalarWhereInput | SkillsScalarWhereInput[]
    id?: IntFilter<"Skills"> | number
    userId?: IntNullableFilter<"Skills"> | number | null
    skill?: StringFilter<"Skills"> | string
  }

  export type PostsUpsertWithWhereUniqueWithoutUserInput = {
    where: PostsWhereUniqueInput
    update: XOR<PostsUpdateWithoutUserInput, PostsUncheckedUpdateWithoutUserInput>
    create: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput>
  }

  export type PostsUpdateWithWhereUniqueWithoutUserInput = {
    where: PostsWhereUniqueInput
    data: XOR<PostsUpdateWithoutUserInput, PostsUncheckedUpdateWithoutUserInput>
  }

  export type PostsUpdateManyWithWhereWithoutUserInput = {
    where: PostsScalarWhereInput
    data: XOR<PostsUpdateManyMutationInput, PostsUncheckedUpdateManyWithoutUserInput>
  }

  export type PostsScalarWhereInput = {
    AND?: PostsScalarWhereInput | PostsScalarWhereInput[]
    OR?: PostsScalarWhereInput[]
    NOT?: PostsScalarWhereInput | PostsScalarWhereInput[]
    id?: IntFilter<"Posts"> | number
    userId?: IntNullableFilter<"Posts"> | number | null
    title?: StringNullableFilter<"Posts"> | string | null
    description?: StringNullableFilter<"Posts"> | string | null
    posted_at?: DateTimeFilter<"Posts"> | Date | string
  }

  export type QuestionsUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionsWhereUniqueInput
    update: XOR<QuestionsUpdateWithoutUserInput, QuestionsUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionsCreateWithoutUserInput, QuestionsUncheckedCreateWithoutUserInput>
  }

  export type QuestionsUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionsWhereUniqueInput
    data: XOR<QuestionsUpdateWithoutUserInput, QuestionsUncheckedUpdateWithoutUserInput>
  }

  export type QuestionsUpdateManyWithWhereWithoutUserInput = {
    where: QuestionsScalarWhereInput
    data: XOR<QuestionsUpdateManyMutationInput, QuestionsUncheckedUpdateManyWithoutUserInput>
  }

  export type QuestionsScalarWhereInput = {
    AND?: QuestionsScalarWhereInput | QuestionsScalarWhereInput[]
    OR?: QuestionsScalarWhereInput[]
    NOT?: QuestionsScalarWhereInput | QuestionsScalarWhereInput[]
    id?: IntFilter<"Questions"> | number
    userId?: IntNullableFilter<"Questions"> | number | null
    question?: StringFilter<"Questions"> | string
    question_description?: StringFilter<"Questions"> | string
    asked_at?: DateTimeFilter<"Questions"> | Date | string
  }

  export type FriendsUpsertWithWhereUniqueWithoutUserInput = {
    where: FriendsWhereUniqueInput
    update: XOR<FriendsUpdateWithoutUserInput, FriendsUncheckedUpdateWithoutUserInput>
    create: XOR<FriendsCreateWithoutUserInput, FriendsUncheckedCreateWithoutUserInput>
  }

  export type FriendsUpdateWithWhereUniqueWithoutUserInput = {
    where: FriendsWhereUniqueInput
    data: XOR<FriendsUpdateWithoutUserInput, FriendsUncheckedUpdateWithoutUserInput>
  }

  export type FriendsUpdateManyWithWhereWithoutUserInput = {
    where: FriendsScalarWhereInput
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyWithoutUserInput>
  }

  export type FriendsScalarWhereInput = {
    AND?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
    OR?: FriendsScalarWhereInput[]
    NOT?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
    id?: IntFilter<"Friends"> | number
    userId?: IntNullableFilter<"Friends"> | number | null
  }

  export type CertificationsUpsertWithWhereUniqueWithoutUserInput = {
    where: CertificationsWhereUniqueInput
    update: XOR<CertificationsUpdateWithoutUserInput, CertificationsUncheckedUpdateWithoutUserInput>
    create: XOR<CertificationsCreateWithoutUserInput, CertificationsUncheckedCreateWithoutUserInput>
  }

  export type CertificationsUpdateWithWhereUniqueWithoutUserInput = {
    where: CertificationsWhereUniqueInput
    data: XOR<CertificationsUpdateWithoutUserInput, CertificationsUncheckedUpdateWithoutUserInput>
  }

  export type CertificationsUpdateManyWithWhereWithoutUserInput = {
    where: CertificationsScalarWhereInput
    data: XOR<CertificationsUpdateManyMutationInput, CertificationsUncheckedUpdateManyWithoutUserInput>
  }

  export type CertificationsScalarWhereInput = {
    AND?: CertificationsScalarWhereInput | CertificationsScalarWhereInput[]
    OR?: CertificationsScalarWhereInput[]
    NOT?: CertificationsScalarWhereInput | CertificationsScalarWhereInput[]
    id?: IntFilter<"Certifications"> | number
    userId?: IntNullableFilter<"Certifications"> | number | null
    certificateName?: StringNullableFilter<"Certifications"> | string | null
    issuingOrganisation?: StringNullableFilter<"Certifications"> | string | null
    issueDate?: StringNullableFilter<"Certifications"> | string | null
    descreption?: StringNullableFilter<"Certifications"> | string | null
    certificateURL?: StringNullableFilter<"Certifications"> | string | null
    certificateMediaLink?: StringNullableFilter<"Certifications"> | string | null
  }

  export type MembershipsUpsertWithWhereUniqueWithoutUserInput = {
    where: MembershipsWhereUniqueInput
    update: XOR<MembershipsUpdateWithoutUserInput, MembershipsUncheckedUpdateWithoutUserInput>
    create: XOR<MembershipsCreateWithoutUserInput, MembershipsUncheckedCreateWithoutUserInput>
  }

  export type MembershipsUpdateWithWhereUniqueWithoutUserInput = {
    where: MembershipsWhereUniqueInput
    data: XOR<MembershipsUpdateWithoutUserInput, MembershipsUncheckedUpdateWithoutUserInput>
  }

  export type MembershipsUpdateManyWithWhereWithoutUserInput = {
    where: MembershipsScalarWhereInput
    data: XOR<MembershipsUpdateManyMutationInput, MembershipsUncheckedUpdateManyWithoutUserInput>
  }

  export type MembershipsScalarWhereInput = {
    AND?: MembershipsScalarWhereInput | MembershipsScalarWhereInput[]
    OR?: MembershipsScalarWhereInput[]
    NOT?: MembershipsScalarWhereInput | MembershipsScalarWhereInput[]
    id?: IntFilter<"Memberships"> | number
    userId?: IntNullableFilter<"Memberships"> | number | null
    societyname?: StringNullableFilter<"Memberships"> | string | null
    position?: StringNullableFilter<"Memberships"> | string | null
    relatedDepartment?: StringNullableFilter<"Memberships"> | string | null
    membershipId?: StringNullableFilter<"Memberships"> | string | null
  }

  export type EducationUpsertWithWhereUniqueWithoutUserInput = {
    where: EducationWhereUniqueInput
    update: XOR<EducationUpdateWithoutUserInput, EducationUncheckedUpdateWithoutUserInput>
    create: XOR<EducationCreateWithoutUserInput, EducationUncheckedCreateWithoutUserInput>
  }

  export type EducationUpdateWithWhereUniqueWithoutUserInput = {
    where: EducationWhereUniqueInput
    data: XOR<EducationUpdateWithoutUserInput, EducationUncheckedUpdateWithoutUserInput>
  }

  export type EducationUpdateManyWithWhereWithoutUserInput = {
    where: EducationScalarWhereInput
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyWithoutUserInput>
  }

  export type EducationScalarWhereInput = {
    AND?: EducationScalarWhereInput | EducationScalarWhereInput[]
    OR?: EducationScalarWhereInput[]
    NOT?: EducationScalarWhereInput | EducationScalarWhereInput[]
    id?: IntFilter<"Education"> | number
    userId?: IntNullableFilter<"Education"> | number | null
    schoolName?: StringNullableFilter<"Education"> | string | null
    degree?: StringNullableFilter<"Education"> | string | null
    department?: StringNullableFilter<"Education"> | string | null
    startDate?: StringNullableFilter<"Education"> | string | null
    endDate?: StringNullableFilter<"Education"> | string | null
    grade?: StringNullableFilter<"Education"> | string | null
  }

  export type ProfessionalExperienceUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfessionalExperienceWhereUniqueInput
    update: XOR<ProfessionalExperienceUpdateWithoutUserInput, ProfessionalExperienceUncheckedUpdateWithoutUserInput>
    create: XOR<ProfessionalExperienceCreateWithoutUserInput, ProfessionalExperienceUncheckedCreateWithoutUserInput>
  }

  export type ProfessionalExperienceUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfessionalExperienceWhereUniqueInput
    data: XOR<ProfessionalExperienceUpdateWithoutUserInput, ProfessionalExperienceUncheckedUpdateWithoutUserInput>
  }

  export type ProfessionalExperienceUpdateManyWithWhereWithoutUserInput = {
    where: ProfessionalExperienceScalarWhereInput
    data: XOR<ProfessionalExperienceUpdateManyMutationInput, ProfessionalExperienceUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfessionalExperienceScalarWhereInput = {
    AND?: ProfessionalExperienceScalarWhereInput | ProfessionalExperienceScalarWhereInput[]
    OR?: ProfessionalExperienceScalarWhereInput[]
    NOT?: ProfessionalExperienceScalarWhereInput | ProfessionalExperienceScalarWhereInput[]
    id?: IntFilter<"ProfessionalExperience"> | number
    userId?: IntNullableFilter<"ProfessionalExperience"> | number | null
    title?: StringNullableFilter<"ProfessionalExperience"> | string | null
    organisation?: StringNullableFilter<"ProfessionalExperience"> | string | null
    startDate?: StringNullableFilter<"ProfessionalExperience"> | string | null
    endDate?: StringNullableFilter<"ProfessionalExperience"> | string | null
    location?: StringNullableFilter<"ProfessionalExperience"> | string | null
  }

  export type JobsUpsertWithWhereUniqueWithoutUserInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutUserInput, JobsUncheckedUpdateWithoutUserInput>
    create: XOR<JobsCreateWithoutUserInput, JobsUncheckedCreateWithoutUserInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutUserInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutUserInput, JobsUncheckedUpdateWithoutUserInput>
  }

  export type JobsUpdateManyWithWhereWithoutUserInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutUserInput>
  }

  export type JobsScalarWhereInput = {
    AND?: JobsScalarWhereInput | JobsScalarWhereInput[]
    OR?: JobsScalarWhereInput[]
    NOT?: JobsScalarWhereInput | JobsScalarWhereInput[]
    id?: IntFilter<"Jobs"> | number
    userId?: IntNullableFilter<"Jobs"> | number | null
  }

  export type ConferrencesUpsertWithWhereUniqueWithoutUserInput = {
    where: ConferrencesWhereUniqueInput
    update: XOR<ConferrencesUpdateWithoutUserInput, ConferrencesUncheckedUpdateWithoutUserInput>
    create: XOR<ConferrencesCreateWithoutUserInput, ConferrencesUncheckedCreateWithoutUserInput>
  }

  export type ConferrencesUpdateWithWhereUniqueWithoutUserInput = {
    where: ConferrencesWhereUniqueInput
    data: XOR<ConferrencesUpdateWithoutUserInput, ConferrencesUncheckedUpdateWithoutUserInput>
  }

  export type ConferrencesUpdateManyWithWhereWithoutUserInput = {
    where: ConferrencesScalarWhereInput
    data: XOR<ConferrencesUpdateManyMutationInput, ConferrencesUncheckedUpdateManyWithoutUserInput>
  }

  export type ConferrencesScalarWhereInput = {
    AND?: ConferrencesScalarWhereInput | ConferrencesScalarWhereInput[]
    OR?: ConferrencesScalarWhereInput[]
    NOT?: ConferrencesScalarWhereInput | ConferrencesScalarWhereInput[]
    id?: IntFilter<"Conferrences"> | number
    userId?: IntNullableFilter<"Conferrences"> | number | null
  }

  export type AchievementsAwardsUpsertWithWhereUniqueWithoutUserInput = {
    where: AchievementsAwardsWhereUniqueInput
    update: XOR<AchievementsAwardsUpdateWithoutUserInput, AchievementsAwardsUncheckedUpdateWithoutUserInput>
    create: XOR<AchievementsAwardsCreateWithoutUserInput, AchievementsAwardsUncheckedCreateWithoutUserInput>
  }

  export type AchievementsAwardsUpdateWithWhereUniqueWithoutUserInput = {
    where: AchievementsAwardsWhereUniqueInput
    data: XOR<AchievementsAwardsUpdateWithoutUserInput, AchievementsAwardsUncheckedUpdateWithoutUserInput>
  }

  export type AchievementsAwardsUpdateManyWithWhereWithoutUserInput = {
    where: AchievementsAwardsScalarWhereInput
    data: XOR<AchievementsAwardsUpdateManyMutationInput, AchievementsAwardsUncheckedUpdateManyWithoutUserInput>
  }

  export type AchievementsAwardsScalarWhereInput = {
    AND?: AchievementsAwardsScalarWhereInput | AchievementsAwardsScalarWhereInput[]
    OR?: AchievementsAwardsScalarWhereInput[]
    NOT?: AchievementsAwardsScalarWhereInput | AchievementsAwardsScalarWhereInput[]
    id?: IntFilter<"AchievementsAwards"> | number
    userId?: IntNullableFilter<"AchievementsAwards"> | number | null
    awardName?: StringNullableFilter<"AchievementsAwards"> | string | null
    awardedBy?: StringNullableFilter<"AchievementsAwards"> | string | null
    awardedOn?: StringNullableFilter<"AchievementsAwards"> | string | null
    descreption?: StringNullableFilter<"AchievementsAwards"> | string | null
  }

  export type UserCreateWithoutAchievementsAwardsInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsAwardsInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsAwardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsAwardsInput, UserUncheckedCreateWithoutAchievementsAwardsInput>
  }

  export type UserUpsertWithoutAchievementsAwardsInput = {
    update: XOR<UserUpdateWithoutAchievementsAwardsInput, UserUncheckedUpdateWithoutAchievementsAwardsInput>
    create: XOR<UserCreateWithoutAchievementsAwardsInput, UserUncheckedCreateWithoutAchievementsAwardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsAwardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsAwardsInput, UserUncheckedUpdateWithoutAchievementsAwardsInput>
  }

  export type UserUpdateWithoutAchievementsAwardsInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsAwardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutJobsInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJobsInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
  }

  export type UserUpsertWithoutJobsInput = {
    update: XOR<UserUpdateWithoutJobsInput, UserUncheckedUpdateWithoutJobsInput>
    create: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobsInput, UserUncheckedUpdateWithoutJobsInput>
  }

  export type UserUpdateWithoutJobsInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutConferrencesInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConferrencesInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConferrencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConferrencesInput, UserUncheckedCreateWithoutConferrencesInput>
  }

  export type UserUpsertWithoutConferrencesInput = {
    update: XOR<UserUpdateWithoutConferrencesInput, UserUncheckedUpdateWithoutConferrencesInput>
    create: XOR<UserCreateWithoutConferrencesInput, UserUncheckedCreateWithoutConferrencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConferrencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConferrencesInput, UserUncheckedUpdateWithoutConferrencesInput>
  }

  export type UserUpdateWithoutConferrencesInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConferrencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSkillsInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSkillsInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSkillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
  }

  export type UserUpsertWithoutSkillsInput = {
    update: XOR<UserUpdateWithoutSkillsInput, UserUncheckedUpdateWithoutSkillsInput>
    create: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSkillsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSkillsInput, UserUncheckedUpdateWithoutSkillsInput>
  }

  export type UserUpdateWithoutSkillsInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPostsInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type PostImageLinksCreateWithoutPostsInput = {
    postImageLink?: string | null
  }

  export type PostImageLinksUncheckedCreateWithoutPostsInput = {
    id?: number
    postImageLink?: string | null
  }

  export type PostImageLinksCreateOrConnectWithoutPostsInput = {
    where: PostImageLinksWhereUniqueInput
    create: XOR<PostImageLinksCreateWithoutPostsInput, PostImageLinksUncheckedCreateWithoutPostsInput>
  }

  export type PostImageLinksCreateManyPostsInputEnvelope = {
    data: PostImageLinksCreateManyPostsInput | PostImageLinksCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type CommentsCreateWithoutPostsInput = {
    comment: string
    commented_at?: Date | string
  }

  export type CommentsUncheckedCreateWithoutPostsInput = {
    id?: number
    comment: string
    commented_at?: Date | string
  }

  export type CommentsCreateOrConnectWithoutPostsInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutPostsInput, CommentsUncheckedCreateWithoutPostsInput>
  }

  export type CommentsCreateManyPostsInputEnvelope = {
    data: CommentsCreateManyPostsInput | CommentsCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type LikesCreateWithoutPostsInput = {
    liked_user_id?: number | null
  }

  export type LikesUncheckedCreateWithoutPostsInput = {
    id?: number
    liked_user_id?: number | null
  }

  export type LikesCreateOrConnectWithoutPostsInput = {
    where: LikesWhereUniqueInput
    create: XOR<LikesCreateWithoutPostsInput, LikesUncheckedCreateWithoutPostsInput>
  }

  export type LikesCreateManyPostsInputEnvelope = {
    data: LikesCreateManyPostsInput | LikesCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type RepostsCreateWithoutPostsInput = {
    reposted_user_id?: number | null
  }

  export type RepostsUncheckedCreateWithoutPostsInput = {
    id?: number
    reposted_user_id?: number | null
  }

  export type RepostsCreateOrConnectWithoutPostsInput = {
    where: RepostsWhereUniqueInput
    create: XOR<RepostsCreateWithoutPostsInput, RepostsUncheckedCreateWithoutPostsInput>
  }

  export type RepostsCreateManyPostsInputEnvelope = {
    data: RepostsCreateManyPostsInput | RepostsCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type SharesCreateWithoutPostsInput = {
    shared_user_id?: number | null
  }

  export type SharesUncheckedCreateWithoutPostsInput = {
    id?: number
    shared_user_id?: number | null
  }

  export type SharesCreateOrConnectWithoutPostsInput = {
    where: SharesWhereUniqueInput
    create: XOR<SharesCreateWithoutPostsInput, SharesUncheckedCreateWithoutPostsInput>
  }

  export type SharesCreateManyPostsInputEnvelope = {
    data: SharesCreateManyPostsInput | SharesCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostImageLinksUpsertWithWhereUniqueWithoutPostsInput = {
    where: PostImageLinksWhereUniqueInput
    update: XOR<PostImageLinksUpdateWithoutPostsInput, PostImageLinksUncheckedUpdateWithoutPostsInput>
    create: XOR<PostImageLinksCreateWithoutPostsInput, PostImageLinksUncheckedCreateWithoutPostsInput>
  }

  export type PostImageLinksUpdateWithWhereUniqueWithoutPostsInput = {
    where: PostImageLinksWhereUniqueInput
    data: XOR<PostImageLinksUpdateWithoutPostsInput, PostImageLinksUncheckedUpdateWithoutPostsInput>
  }

  export type PostImageLinksUpdateManyWithWhereWithoutPostsInput = {
    where: PostImageLinksScalarWhereInput
    data: XOR<PostImageLinksUpdateManyMutationInput, PostImageLinksUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostImageLinksScalarWhereInput = {
    AND?: PostImageLinksScalarWhereInput | PostImageLinksScalarWhereInput[]
    OR?: PostImageLinksScalarWhereInput[]
    NOT?: PostImageLinksScalarWhereInput | PostImageLinksScalarWhereInput[]
    id?: IntFilter<"PostImageLinks"> | number
    postsId?: IntNullableFilter<"PostImageLinks"> | number | null
    postImageLink?: StringNullableFilter<"PostImageLinks"> | string | null
  }

  export type CommentsUpsertWithWhereUniqueWithoutPostsInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutPostsInput, CommentsUncheckedUpdateWithoutPostsInput>
    create: XOR<CommentsCreateWithoutPostsInput, CommentsUncheckedCreateWithoutPostsInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutPostsInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutPostsInput, CommentsUncheckedUpdateWithoutPostsInput>
  }

  export type CommentsUpdateManyWithWhereWithoutPostsInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutPostsInput>
  }

  export type CommentsScalarWhereInput = {
    AND?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
    OR?: CommentsScalarWhereInput[]
    NOT?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
    id?: IntFilter<"Comments"> | number
    postsId?: IntNullableFilter<"Comments"> | number | null
    comment?: StringFilter<"Comments"> | string
    commented_at?: DateTimeFilter<"Comments"> | Date | string
  }

  export type LikesUpsertWithWhereUniqueWithoutPostsInput = {
    where: LikesWhereUniqueInput
    update: XOR<LikesUpdateWithoutPostsInput, LikesUncheckedUpdateWithoutPostsInput>
    create: XOR<LikesCreateWithoutPostsInput, LikesUncheckedCreateWithoutPostsInput>
  }

  export type LikesUpdateWithWhereUniqueWithoutPostsInput = {
    where: LikesWhereUniqueInput
    data: XOR<LikesUpdateWithoutPostsInput, LikesUncheckedUpdateWithoutPostsInput>
  }

  export type LikesUpdateManyWithWhereWithoutPostsInput = {
    where: LikesScalarWhereInput
    data: XOR<LikesUpdateManyMutationInput, LikesUncheckedUpdateManyWithoutPostsInput>
  }

  export type LikesScalarWhereInput = {
    AND?: LikesScalarWhereInput | LikesScalarWhereInput[]
    OR?: LikesScalarWhereInput[]
    NOT?: LikesScalarWhereInput | LikesScalarWhereInput[]
    id?: IntFilter<"Likes"> | number
    postsId?: IntNullableFilter<"Likes"> | number | null
    liked_user_id?: IntNullableFilter<"Likes"> | number | null
  }

  export type RepostsUpsertWithWhereUniqueWithoutPostsInput = {
    where: RepostsWhereUniqueInput
    update: XOR<RepostsUpdateWithoutPostsInput, RepostsUncheckedUpdateWithoutPostsInput>
    create: XOR<RepostsCreateWithoutPostsInput, RepostsUncheckedCreateWithoutPostsInput>
  }

  export type RepostsUpdateWithWhereUniqueWithoutPostsInput = {
    where: RepostsWhereUniqueInput
    data: XOR<RepostsUpdateWithoutPostsInput, RepostsUncheckedUpdateWithoutPostsInput>
  }

  export type RepostsUpdateManyWithWhereWithoutPostsInput = {
    where: RepostsScalarWhereInput
    data: XOR<RepostsUpdateManyMutationInput, RepostsUncheckedUpdateManyWithoutPostsInput>
  }

  export type RepostsScalarWhereInput = {
    AND?: RepostsScalarWhereInput | RepostsScalarWhereInput[]
    OR?: RepostsScalarWhereInput[]
    NOT?: RepostsScalarWhereInput | RepostsScalarWhereInput[]
    id?: IntFilter<"Reposts"> | number
    postsId?: IntNullableFilter<"Reposts"> | number | null
    reposted_user_id?: IntNullableFilter<"Reposts"> | number | null
  }

  export type SharesUpsertWithWhereUniqueWithoutPostsInput = {
    where: SharesWhereUniqueInput
    update: XOR<SharesUpdateWithoutPostsInput, SharesUncheckedUpdateWithoutPostsInput>
    create: XOR<SharesCreateWithoutPostsInput, SharesUncheckedCreateWithoutPostsInput>
  }

  export type SharesUpdateWithWhereUniqueWithoutPostsInput = {
    where: SharesWhereUniqueInput
    data: XOR<SharesUpdateWithoutPostsInput, SharesUncheckedUpdateWithoutPostsInput>
  }

  export type SharesUpdateManyWithWhereWithoutPostsInput = {
    where: SharesScalarWhereInput
    data: XOR<SharesUpdateManyMutationInput, SharesUncheckedUpdateManyWithoutPostsInput>
  }

  export type SharesScalarWhereInput = {
    AND?: SharesScalarWhereInput | SharesScalarWhereInput[]
    OR?: SharesScalarWhereInput[]
    NOT?: SharesScalarWhereInput | SharesScalarWhereInput[]
    id?: IntFilter<"Shares"> | number
    postsId?: IntNullableFilter<"Shares"> | number | null
    shared_user_id?: IntNullableFilter<"Shares"> | number | null
  }

  export type PostsCreateWithoutPostImageLinksInput = {
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    User?: UserCreateNestedOneWithoutPostsInput
    comments?: CommentsCreateNestedManyWithoutPostsInput
    likes?: LikesCreateNestedManyWithoutPostsInput
    reposts?: RepostsCreateNestedManyWithoutPostsInput
    shares?: SharesCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutPostImageLinksInput = {
    id?: number
    userId?: number | null
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    comments?: CommentsUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikesUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RepostsUncheckedCreateNestedManyWithoutPostsInput
    shares?: SharesUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutPostImageLinksInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutPostImageLinksInput, PostsUncheckedCreateWithoutPostImageLinksInput>
  }

  export type PostsUpsertWithoutPostImageLinksInput = {
    update: XOR<PostsUpdateWithoutPostImageLinksInput, PostsUncheckedUpdateWithoutPostImageLinksInput>
    create: XOR<PostsCreateWithoutPostImageLinksInput, PostsUncheckedCreateWithoutPostImageLinksInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutPostImageLinksInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutPostImageLinksInput, PostsUncheckedUpdateWithoutPostImageLinksInput>
  }

  export type PostsUpdateWithoutPostImageLinksInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutPostsNestedInput
    comments?: CommentsUpdateManyWithoutPostsNestedInput
    likes?: LikesUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUpdateManyWithoutPostsNestedInput
    shares?: SharesUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutPostImageLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentsUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikesUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUncheckedUpdateManyWithoutPostsNestedInput
    shares?: SharesUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsCreateWithoutCommentsInput = {
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    User?: UserCreateNestedOneWithoutPostsInput
    postImageLinks?: PostImageLinksCreateNestedManyWithoutPostsInput
    likes?: LikesCreateNestedManyWithoutPostsInput
    reposts?: RepostsCreateNestedManyWithoutPostsInput
    shares?: SharesCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutCommentsInput = {
    id?: number
    userId?: number | null
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    postImageLinks?: PostImageLinksUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikesUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RepostsUncheckedCreateNestedManyWithoutPostsInput
    shares?: SharesUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutCommentsInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutCommentsInput, PostsUncheckedCreateWithoutCommentsInput>
  }

  export type PostsUpsertWithoutCommentsInput = {
    update: XOR<PostsUpdateWithoutCommentsInput, PostsUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostsCreateWithoutCommentsInput, PostsUncheckedCreateWithoutCommentsInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutCommentsInput, PostsUncheckedUpdateWithoutCommentsInput>
  }

  export type PostsUpdateWithoutCommentsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutPostsNestedInput
    postImageLinks?: PostImageLinksUpdateManyWithoutPostsNestedInput
    likes?: LikesUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUpdateManyWithoutPostsNestedInput
    shares?: SharesUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    postImageLinks?: PostImageLinksUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikesUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUncheckedUpdateManyWithoutPostsNestedInput
    shares?: SharesUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsCreateWithoutLikesInput = {
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    User?: UserCreateNestedOneWithoutPostsInput
    postImageLinks?: PostImageLinksCreateNestedManyWithoutPostsInput
    comments?: CommentsCreateNestedManyWithoutPostsInput
    reposts?: RepostsCreateNestedManyWithoutPostsInput
    shares?: SharesCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutLikesInput = {
    id?: number
    userId?: number | null
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    postImageLinks?: PostImageLinksUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentsUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RepostsUncheckedCreateNestedManyWithoutPostsInput
    shares?: SharesUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutLikesInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutLikesInput, PostsUncheckedCreateWithoutLikesInput>
  }

  export type PostsUpsertWithoutLikesInput = {
    update: XOR<PostsUpdateWithoutLikesInput, PostsUncheckedUpdateWithoutLikesInput>
    create: XOR<PostsCreateWithoutLikesInput, PostsUncheckedCreateWithoutLikesInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutLikesInput, PostsUncheckedUpdateWithoutLikesInput>
  }

  export type PostsUpdateWithoutLikesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutPostsNestedInput
    postImageLinks?: PostImageLinksUpdateManyWithoutPostsNestedInput
    comments?: CommentsUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUpdateManyWithoutPostsNestedInput
    shares?: SharesUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    postImageLinks?: PostImageLinksUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUncheckedUpdateManyWithoutPostsNestedInput
    shares?: SharesUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsCreateWithoutRepostsInput = {
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    User?: UserCreateNestedOneWithoutPostsInput
    postImageLinks?: PostImageLinksCreateNestedManyWithoutPostsInput
    comments?: CommentsCreateNestedManyWithoutPostsInput
    likes?: LikesCreateNestedManyWithoutPostsInput
    shares?: SharesCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutRepostsInput = {
    id?: number
    userId?: number | null
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    postImageLinks?: PostImageLinksUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentsUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikesUncheckedCreateNestedManyWithoutPostsInput
    shares?: SharesUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutRepostsInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutRepostsInput, PostsUncheckedCreateWithoutRepostsInput>
  }

  export type PostsUpsertWithoutRepostsInput = {
    update: XOR<PostsUpdateWithoutRepostsInput, PostsUncheckedUpdateWithoutRepostsInput>
    create: XOR<PostsCreateWithoutRepostsInput, PostsUncheckedCreateWithoutRepostsInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutRepostsInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutRepostsInput, PostsUncheckedUpdateWithoutRepostsInput>
  }

  export type PostsUpdateWithoutRepostsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutPostsNestedInput
    postImageLinks?: PostImageLinksUpdateManyWithoutPostsNestedInput
    comments?: CommentsUpdateManyWithoutPostsNestedInput
    likes?: LikesUpdateManyWithoutPostsNestedInput
    shares?: SharesUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutRepostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    postImageLinks?: PostImageLinksUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikesUncheckedUpdateManyWithoutPostsNestedInput
    shares?: SharesUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsCreateWithoutSharesInput = {
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    User?: UserCreateNestedOneWithoutPostsInput
    postImageLinks?: PostImageLinksCreateNestedManyWithoutPostsInput
    comments?: CommentsCreateNestedManyWithoutPostsInput
    likes?: LikesCreateNestedManyWithoutPostsInput
    reposts?: RepostsCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutSharesInput = {
    id?: number
    userId?: number | null
    title?: string | null
    description?: string | null
    posted_at?: Date | string
    postImageLinks?: PostImageLinksUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentsUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikesUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RepostsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutSharesInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutSharesInput, PostsUncheckedCreateWithoutSharesInput>
  }

  export type PostsUpsertWithoutSharesInput = {
    update: XOR<PostsUpdateWithoutSharesInput, PostsUncheckedUpdateWithoutSharesInput>
    create: XOR<PostsCreateWithoutSharesInput, PostsUncheckedCreateWithoutSharesInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutSharesInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutSharesInput, PostsUncheckedUpdateWithoutSharesInput>
  }

  export type PostsUpdateWithoutSharesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutPostsNestedInput
    postImageLinks?: PostImageLinksUpdateManyWithoutPostsNestedInput
    comments?: CommentsUpdateManyWithoutPostsNestedInput
    likes?: LikesUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutSharesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    postImageLinks?: PostImageLinksUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikesUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UserCreateWithoutQuestionsInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionImageLinksCreateWithoutQuestionsInput = {

  }

  export type QuestionImageLinksUncheckedCreateWithoutQuestionsInput = {
    id?: number
  }

  export type QuestionImageLinksCreateOrConnectWithoutQuestionsInput = {
    where: QuestionImageLinksWhereUniqueInput
    create: XOR<QuestionImageLinksCreateWithoutQuestionsInput, QuestionImageLinksUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionImageLinksCreateManyQuestionsInputEnvelope = {
    data: QuestionImageLinksCreateManyQuestionsInput | QuestionImageLinksCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type InsightfulCreateWithoutQuestionsInput = {
    insightful_user_id?: string | null
  }

  export type InsightfulUncheckedCreateWithoutQuestionsInput = {
    id?: number
    insightful_user_id?: string | null
  }

  export type InsightfulCreateOrConnectWithoutQuestionsInput = {
    where: InsightfulWhereUniqueInput
    create: XOR<InsightfulCreateWithoutQuestionsInput, InsightfulUncheckedCreateWithoutQuestionsInput>
  }

  export type InsightfulCreateManyQuestionsInputEnvelope = {
    data: InsightfulCreateManyQuestionsInput | InsightfulCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type AnswersCreateWithoutQuestionsInput = {
    answered_user_id: string
    answer_description: string
    answer_image_links?: Answer_Image_LinksCreateNestedManyWithoutAnswersInput
  }

  export type AnswersUncheckedCreateWithoutQuestionsInput = {
    id?: number
    answered_user_id: string
    answer_description: string
    answer_image_links?: Answer_Image_LinksUncheckedCreateNestedManyWithoutAnswersInput
  }

  export type AnswersCreateOrConnectWithoutQuestionsInput = {
    where: AnswersWhereUniqueInput
    create: XOR<AnswersCreateWithoutQuestionsInput, AnswersUncheckedCreateWithoutQuestionsInput>
  }

  export type AnswersCreateManyQuestionsInputEnvelope = {
    data: AnswersCreateManyQuestionsInput | AnswersCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCommentsCreateWithoutQuestionsInput = {
    comment: string
    comment_user_id: number
  }

  export type QuestionCommentsUncheckedCreateWithoutQuestionsInput = {
    id?: number
    comment: string
    comment_user_id: number
  }

  export type QuestionCommentsCreateOrConnectWithoutQuestionsInput = {
    where: QuestionCommentsWhereUniqueInput
    create: XOR<QuestionCommentsCreateWithoutQuestionsInput, QuestionCommentsUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionCommentsCreateManyQuestionsInputEnvelope = {
    data: QuestionCommentsCreateManyQuestionsInput | QuestionCommentsCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type QuestionReferencesCreateWithoutQuestionsInput = {
    reference?: string | null
  }

  export type QuestionReferencesUncheckedCreateWithoutQuestionsInput = {
    id?: number
    reference?: string | null
  }

  export type QuestionReferencesCreateOrConnectWithoutQuestionsInput = {
    where: QuestionReferencesWhereUniqueInput
    create: XOR<QuestionReferencesCreateWithoutQuestionsInput, QuestionReferencesUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionReferencesCreateManyQuestionsInputEnvelope = {
    data: QuestionReferencesCreateManyQuestionsInput | QuestionReferencesCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutQuestionsInput = {
    update: XOR<UserUpdateWithoutQuestionsInput, UserUncheckedUpdateWithoutQuestionsInput>
    create: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuestionsInput, UserUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserUpdateWithoutQuestionsInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuestionImageLinksUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: QuestionImageLinksWhereUniqueInput
    update: XOR<QuestionImageLinksUpdateWithoutQuestionsInput, QuestionImageLinksUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuestionImageLinksCreateWithoutQuestionsInput, QuestionImageLinksUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionImageLinksUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: QuestionImageLinksWhereUniqueInput
    data: XOR<QuestionImageLinksUpdateWithoutQuestionsInput, QuestionImageLinksUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionImageLinksUpdateManyWithWhereWithoutQuestionsInput = {
    where: QuestionImageLinksScalarWhereInput
    data: XOR<QuestionImageLinksUpdateManyMutationInput, QuestionImageLinksUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type QuestionImageLinksScalarWhereInput = {
    AND?: QuestionImageLinksScalarWhereInput | QuestionImageLinksScalarWhereInput[]
    OR?: QuestionImageLinksScalarWhereInput[]
    NOT?: QuestionImageLinksScalarWhereInput | QuestionImageLinksScalarWhereInput[]
    id?: IntFilter<"QuestionImageLinks"> | number
    questionsId?: IntNullableFilter<"QuestionImageLinks"> | number | null
  }

  export type InsightfulUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: InsightfulWhereUniqueInput
    update: XOR<InsightfulUpdateWithoutQuestionsInput, InsightfulUncheckedUpdateWithoutQuestionsInput>
    create: XOR<InsightfulCreateWithoutQuestionsInput, InsightfulUncheckedCreateWithoutQuestionsInput>
  }

  export type InsightfulUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: InsightfulWhereUniqueInput
    data: XOR<InsightfulUpdateWithoutQuestionsInput, InsightfulUncheckedUpdateWithoutQuestionsInput>
  }

  export type InsightfulUpdateManyWithWhereWithoutQuestionsInput = {
    where: InsightfulScalarWhereInput
    data: XOR<InsightfulUpdateManyMutationInput, InsightfulUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type InsightfulScalarWhereInput = {
    AND?: InsightfulScalarWhereInput | InsightfulScalarWhereInput[]
    OR?: InsightfulScalarWhereInput[]
    NOT?: InsightfulScalarWhereInput | InsightfulScalarWhereInput[]
    id?: IntFilter<"Insightful"> | number
    questionsId?: IntNullableFilter<"Insightful"> | number | null
    insightful_user_id?: StringNullableFilter<"Insightful"> | string | null
  }

  export type AnswersUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: AnswersWhereUniqueInput
    update: XOR<AnswersUpdateWithoutQuestionsInput, AnswersUncheckedUpdateWithoutQuestionsInput>
    create: XOR<AnswersCreateWithoutQuestionsInput, AnswersUncheckedCreateWithoutQuestionsInput>
  }

  export type AnswersUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: AnswersWhereUniqueInput
    data: XOR<AnswersUpdateWithoutQuestionsInput, AnswersUncheckedUpdateWithoutQuestionsInput>
  }

  export type AnswersUpdateManyWithWhereWithoutQuestionsInput = {
    where: AnswersScalarWhereInput
    data: XOR<AnswersUpdateManyMutationInput, AnswersUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type AnswersScalarWhereInput = {
    AND?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
    OR?: AnswersScalarWhereInput[]
    NOT?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
    id?: IntFilter<"Answers"> | number
    questionsId?: IntNullableFilter<"Answers"> | number | null
    answered_user_id?: StringFilter<"Answers"> | string
    answer_description?: StringFilter<"Answers"> | string
  }

  export type QuestionCommentsUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: QuestionCommentsWhereUniqueInput
    update: XOR<QuestionCommentsUpdateWithoutQuestionsInput, QuestionCommentsUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuestionCommentsCreateWithoutQuestionsInput, QuestionCommentsUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionCommentsUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: QuestionCommentsWhereUniqueInput
    data: XOR<QuestionCommentsUpdateWithoutQuestionsInput, QuestionCommentsUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionCommentsUpdateManyWithWhereWithoutQuestionsInput = {
    where: QuestionCommentsScalarWhereInput
    data: XOR<QuestionCommentsUpdateManyMutationInput, QuestionCommentsUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type QuestionCommentsScalarWhereInput = {
    AND?: QuestionCommentsScalarWhereInput | QuestionCommentsScalarWhereInput[]
    OR?: QuestionCommentsScalarWhereInput[]
    NOT?: QuestionCommentsScalarWhereInput | QuestionCommentsScalarWhereInput[]
    id?: IntFilter<"QuestionComments"> | number
    questionsId?: IntNullableFilter<"QuestionComments"> | number | null
    comment?: StringFilter<"QuestionComments"> | string
    comment_user_id?: IntFilter<"QuestionComments"> | number
  }

  export type QuestionReferencesUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: QuestionReferencesWhereUniqueInput
    update: XOR<QuestionReferencesUpdateWithoutQuestionsInput, QuestionReferencesUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuestionReferencesCreateWithoutQuestionsInput, QuestionReferencesUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionReferencesUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: QuestionReferencesWhereUniqueInput
    data: XOR<QuestionReferencesUpdateWithoutQuestionsInput, QuestionReferencesUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionReferencesUpdateManyWithWhereWithoutQuestionsInput = {
    where: QuestionReferencesScalarWhereInput
    data: XOR<QuestionReferencesUpdateManyMutationInput, QuestionReferencesUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type QuestionReferencesScalarWhereInput = {
    AND?: QuestionReferencesScalarWhereInput | QuestionReferencesScalarWhereInput[]
    OR?: QuestionReferencesScalarWhereInput[]
    NOT?: QuestionReferencesScalarWhereInput | QuestionReferencesScalarWhereInput[]
    id?: IntFilter<"QuestionReferences"> | number
    questionsId?: IntNullableFilter<"QuestionReferences"> | number | null
    reference?: StringNullableFilter<"QuestionReferences"> | string | null
  }

  export type QuestionsCreateWithoutQuestionReferencesInput = {
    question: string
    question_description: string
    asked_at?: Date | string
    User?: UserCreateNestedOneWithoutQuestionsInput
    question_image_links?: QuestionImageLinksCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulCreateNestedManyWithoutQuestionsInput
    answers?: AnswersCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateWithoutQuestionReferencesInput = {
    id?: number
    userId?: number | null
    question: string
    question_description: string
    asked_at?: Date | string
    question_image_links?: QuestionImageLinksUncheckedCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulUncheckedCreateNestedManyWithoutQuestionsInput
    answers?: AnswersUncheckedCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsCreateOrConnectWithoutQuestionReferencesInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutQuestionReferencesInput, QuestionsUncheckedCreateWithoutQuestionReferencesInput>
  }

  export type QuestionsUpsertWithoutQuestionReferencesInput = {
    update: XOR<QuestionsUpdateWithoutQuestionReferencesInput, QuestionsUncheckedUpdateWithoutQuestionReferencesInput>
    create: XOR<QuestionsCreateWithoutQuestionReferencesInput, QuestionsUncheckedCreateWithoutQuestionReferencesInput>
    where?: QuestionsWhereInput
  }

  export type QuestionsUpdateToOneWithWhereWithoutQuestionReferencesInput = {
    where?: QuestionsWhereInput
    data: XOR<QuestionsUpdateWithoutQuestionReferencesInput, QuestionsUncheckedUpdateWithoutQuestionReferencesInput>
  }

  export type QuestionsUpdateWithoutQuestionReferencesInput = {
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutQuestionsNestedInput
    question_image_links?: QuestionImageLinksUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutQuestionReferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_image_links?: QuestionImageLinksUncheckedUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUncheckedUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUncheckedUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsCreateWithoutQuestionCommentsInput = {
    question: string
    question_description: string
    asked_at?: Date | string
    User?: UserCreateNestedOneWithoutQuestionsInput
    question_image_links?: QuestionImageLinksCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulCreateNestedManyWithoutQuestionsInput
    answers?: AnswersCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateWithoutQuestionCommentsInput = {
    id?: number
    userId?: number | null
    question: string
    question_description: string
    asked_at?: Date | string
    question_image_links?: QuestionImageLinksUncheckedCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulUncheckedCreateNestedManyWithoutQuestionsInput
    answers?: AnswersUncheckedCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsCreateOrConnectWithoutQuestionCommentsInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutQuestionCommentsInput, QuestionsUncheckedCreateWithoutQuestionCommentsInput>
  }

  export type QuestionsUpsertWithoutQuestionCommentsInput = {
    update: XOR<QuestionsUpdateWithoutQuestionCommentsInput, QuestionsUncheckedUpdateWithoutQuestionCommentsInput>
    create: XOR<QuestionsCreateWithoutQuestionCommentsInput, QuestionsUncheckedCreateWithoutQuestionCommentsInput>
    where?: QuestionsWhereInput
  }

  export type QuestionsUpdateToOneWithWhereWithoutQuestionCommentsInput = {
    where?: QuestionsWhereInput
    data: XOR<QuestionsUpdateWithoutQuestionCommentsInput, QuestionsUncheckedUpdateWithoutQuestionCommentsInput>
  }

  export type QuestionsUpdateWithoutQuestionCommentsInput = {
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutQuestionsNestedInput
    question_image_links?: QuestionImageLinksUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutQuestionCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_image_links?: QuestionImageLinksUncheckedUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUncheckedUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUncheckedUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsCreateWithoutAnswersInput = {
    question: string
    question_description: string
    asked_at?: Date | string
    User?: UserCreateNestedOneWithoutQuestionsInput
    question_image_links?: QuestionImageLinksCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateWithoutAnswersInput = {
    id?: number
    userId?: number | null
    question: string
    question_description: string
    asked_at?: Date | string
    question_image_links?: QuestionImageLinksUncheckedCreateNestedManyWithoutQuestionsInput
    insightful?: InsightfulUncheckedCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsUncheckedCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsCreateOrConnectWithoutAnswersInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutAnswersInput, QuestionsUncheckedCreateWithoutAnswersInput>
  }

  export type Answer_Image_LinksCreateWithoutAnswersInput = {
    answer_image_link?: string | null
  }

  export type Answer_Image_LinksUncheckedCreateWithoutAnswersInput = {
    id?: number
    answer_image_link?: string | null
  }

  export type Answer_Image_LinksCreateOrConnectWithoutAnswersInput = {
    where: Answer_Image_LinksWhereUniqueInput
    create: XOR<Answer_Image_LinksCreateWithoutAnswersInput, Answer_Image_LinksUncheckedCreateWithoutAnswersInput>
  }

  export type Answer_Image_LinksCreateManyAnswersInputEnvelope = {
    data: Answer_Image_LinksCreateManyAnswersInput | Answer_Image_LinksCreateManyAnswersInput[]
    skipDuplicates?: boolean
  }

  export type QuestionsUpsertWithoutAnswersInput = {
    update: XOR<QuestionsUpdateWithoutAnswersInput, QuestionsUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionsCreateWithoutAnswersInput, QuestionsUncheckedCreateWithoutAnswersInput>
    where?: QuestionsWhereInput
  }

  export type QuestionsUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuestionsWhereInput
    data: XOR<QuestionsUpdateWithoutAnswersInput, QuestionsUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionsUpdateWithoutAnswersInput = {
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutQuestionsNestedInput
    question_image_links?: QuestionImageLinksUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_image_links?: QuestionImageLinksUncheckedUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUncheckedUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUncheckedUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type Answer_Image_LinksUpsertWithWhereUniqueWithoutAnswersInput = {
    where: Answer_Image_LinksWhereUniqueInput
    update: XOR<Answer_Image_LinksUpdateWithoutAnswersInput, Answer_Image_LinksUncheckedUpdateWithoutAnswersInput>
    create: XOR<Answer_Image_LinksCreateWithoutAnswersInput, Answer_Image_LinksUncheckedCreateWithoutAnswersInput>
  }

  export type Answer_Image_LinksUpdateWithWhereUniqueWithoutAnswersInput = {
    where: Answer_Image_LinksWhereUniqueInput
    data: XOR<Answer_Image_LinksUpdateWithoutAnswersInput, Answer_Image_LinksUncheckedUpdateWithoutAnswersInput>
  }

  export type Answer_Image_LinksUpdateManyWithWhereWithoutAnswersInput = {
    where: Answer_Image_LinksScalarWhereInput
    data: XOR<Answer_Image_LinksUpdateManyMutationInput, Answer_Image_LinksUncheckedUpdateManyWithoutAnswersInput>
  }

  export type Answer_Image_LinksScalarWhereInput = {
    AND?: Answer_Image_LinksScalarWhereInput | Answer_Image_LinksScalarWhereInput[]
    OR?: Answer_Image_LinksScalarWhereInput[]
    NOT?: Answer_Image_LinksScalarWhereInput | Answer_Image_LinksScalarWhereInput[]
    id?: IntFilter<"Answer_Image_Links"> | number
    answersId?: IntNullableFilter<"Answer_Image_Links"> | number | null
    answer_image_link?: StringNullableFilter<"Answer_Image_Links"> | string | null
  }

  export type AnswersCreateWithoutAnswer_image_linksInput = {
    answered_user_id: string
    answer_description: string
    Questions?: QuestionsCreateNestedOneWithoutAnswersInput
  }

  export type AnswersUncheckedCreateWithoutAnswer_image_linksInput = {
    id?: number
    questionsId?: number | null
    answered_user_id: string
    answer_description: string
  }

  export type AnswersCreateOrConnectWithoutAnswer_image_linksInput = {
    where: AnswersWhereUniqueInput
    create: XOR<AnswersCreateWithoutAnswer_image_linksInput, AnswersUncheckedCreateWithoutAnswer_image_linksInput>
  }

  export type AnswersUpsertWithoutAnswer_image_linksInput = {
    update: XOR<AnswersUpdateWithoutAnswer_image_linksInput, AnswersUncheckedUpdateWithoutAnswer_image_linksInput>
    create: XOR<AnswersCreateWithoutAnswer_image_linksInput, AnswersUncheckedCreateWithoutAnswer_image_linksInput>
    where?: AnswersWhereInput
  }

  export type AnswersUpdateToOneWithWhereWithoutAnswer_image_linksInput = {
    where?: AnswersWhereInput
    data: XOR<AnswersUpdateWithoutAnswer_image_linksInput, AnswersUncheckedUpdateWithoutAnswer_image_linksInput>
  }

  export type AnswersUpdateWithoutAnswer_image_linksInput = {
    answered_user_id?: StringFieldUpdateOperationsInput | string
    answer_description?: StringFieldUpdateOperationsInput | string
    Questions?: QuestionsUpdateOneWithoutAnswersNestedInput
  }

  export type AnswersUncheckedUpdateWithoutAnswer_image_linksInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionsId?: NullableIntFieldUpdateOperationsInput | number | null
    answered_user_id?: StringFieldUpdateOperationsInput | string
    answer_description?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionsCreateWithoutQuestion_image_linksInput = {
    question: string
    question_description: string
    asked_at?: Date | string
    User?: UserCreateNestedOneWithoutQuestionsInput
    insightful?: InsightfulCreateNestedManyWithoutQuestionsInput
    answers?: AnswersCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateWithoutQuestion_image_linksInput = {
    id?: number
    userId?: number | null
    question: string
    question_description: string
    asked_at?: Date | string
    insightful?: InsightfulUncheckedCreateNestedManyWithoutQuestionsInput
    answers?: AnswersUncheckedCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsUncheckedCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsCreateOrConnectWithoutQuestion_image_linksInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutQuestion_image_linksInput, QuestionsUncheckedCreateWithoutQuestion_image_linksInput>
  }

  export type QuestionsUpsertWithoutQuestion_image_linksInput = {
    update: XOR<QuestionsUpdateWithoutQuestion_image_linksInput, QuestionsUncheckedUpdateWithoutQuestion_image_linksInput>
    create: XOR<QuestionsCreateWithoutQuestion_image_linksInput, QuestionsUncheckedCreateWithoutQuestion_image_linksInput>
    where?: QuestionsWhereInput
  }

  export type QuestionsUpdateToOneWithWhereWithoutQuestion_image_linksInput = {
    where?: QuestionsWhereInput
    data: XOR<QuestionsUpdateWithoutQuestion_image_linksInput, QuestionsUncheckedUpdateWithoutQuestion_image_linksInput>
  }

  export type QuestionsUpdateWithoutQuestion_image_linksInput = {
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutQuestionsNestedInput
    insightful?: InsightfulUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutQuestion_image_linksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    insightful?: InsightfulUncheckedUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUncheckedUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUncheckedUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsCreateWithoutInsightfulInput = {
    question: string
    question_description: string
    asked_at?: Date | string
    User?: UserCreateNestedOneWithoutQuestionsInput
    question_image_links?: QuestionImageLinksCreateNestedManyWithoutQuestionsInput
    answers?: AnswersCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateWithoutInsightfulInput = {
    id?: number
    userId?: number | null
    question: string
    question_description: string
    asked_at?: Date | string
    question_image_links?: QuestionImageLinksUncheckedCreateNestedManyWithoutQuestionsInput
    answers?: AnswersUncheckedCreateNestedManyWithoutQuestionsInput
    questionComments?: QuestionCommentsUncheckedCreateNestedManyWithoutQuestionsInput
    questionReferences?: QuestionReferencesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsCreateOrConnectWithoutInsightfulInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutInsightfulInput, QuestionsUncheckedCreateWithoutInsightfulInput>
  }

  export type QuestionsUpsertWithoutInsightfulInput = {
    update: XOR<QuestionsUpdateWithoutInsightfulInput, QuestionsUncheckedUpdateWithoutInsightfulInput>
    create: XOR<QuestionsCreateWithoutInsightfulInput, QuestionsUncheckedCreateWithoutInsightfulInput>
    where?: QuestionsWhereInput
  }

  export type QuestionsUpdateToOneWithWhereWithoutInsightfulInput = {
    where?: QuestionsWhereInput
    data: XOR<QuestionsUpdateWithoutInsightfulInput, QuestionsUncheckedUpdateWithoutInsightfulInput>
  }

  export type QuestionsUpdateWithoutInsightfulInput = {
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutQuestionsNestedInput
    question_image_links?: QuestionImageLinksUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutInsightfulInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_image_links?: QuestionImageLinksUncheckedUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUncheckedUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUncheckedUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type UserCreateWithoutFriendsInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriendsInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriendsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
  }

  export type UserUpsertWithoutFriendsInput = {
    update: XOR<UserUpdateWithoutFriendsInput, UserUncheckedUpdateWithoutFriendsInput>
    create: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendsInput, UserUncheckedUpdateWithoutFriendsInput>
  }

  export type UserUpdateWithoutFriendsInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCertificationsInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCertificationsInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCertificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
  }

  export type UserUpsertWithoutCertificationsInput = {
    update: XOR<UserUpdateWithoutCertificationsInput, UserUncheckedUpdateWithoutCertificationsInput>
    create: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificationsInput, UserUncheckedUpdateWithoutCertificationsInput>
  }

  export type UserUpdateWithoutCertificationsInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMembershipsInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEducationInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEducationInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    professionalExperience?: ProfessionalExperienceUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEducationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEducationInput, UserUncheckedCreateWithoutEducationInput>
  }

  export type UserUpsertWithoutEducationInput = {
    update: XOR<UserUpdateWithoutEducationInput, UserUncheckedUpdateWithoutEducationInput>
    create: XOR<UserCreateWithoutEducationInput, UserUncheckedCreateWithoutEducationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEducationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEducationInput, UserUncheckedUpdateWithoutEducationInput>
  }

  export type UserUpdateWithoutEducationInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEducationInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    professionalExperience?: ProfessionalExperienceUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfessionalExperienceInput = {
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsCreateNestedManyWithoutUserInput
    posts?: PostsCreateNestedManyWithoutUserInput
    questions?: QuestionsCreateNestedManyWithoutUserInput
    friends?: FriendsCreateNestedManyWithoutUserInput
    certifications?: CertificationsCreateNestedManyWithoutUserInput
    memberships?: MembershipsCreateNestedManyWithoutUserInput
    education?: EducationCreateNestedManyWithoutUserInput
    jobs?: JobsCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfessionalExperienceInput = {
    id?: number
    category: string
    email: string
    password: string
    name?: string | null
    gender?: string | null
    department?: string | null
    country?: string | null
    city?: string | null
    organisation_name?: string | null
    specialisation_field_of_study?: string | null
    register_number?: string | null
    verified?: boolean
    date_of_birth?: Date | string | null
    created_at?: Date | string
    skills?: SkillsUncheckedCreateNestedManyWithoutUserInput
    posts?: PostsUncheckedCreateNestedManyWithoutUserInput
    questions?: QuestionsUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUserInput
    certifications?: CertificationsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipsUncheckedCreateNestedManyWithoutUserInput
    education?: EducationUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobsUncheckedCreateNestedManyWithoutUserInput
    conferrences?: ConferrencesUncheckedCreateNestedManyWithoutUserInput
    achievementsAwards?: AchievementsAwardsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfessionalExperienceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfessionalExperienceInput, UserUncheckedCreateWithoutProfessionalExperienceInput>
  }

  export type UserUpsertWithoutProfessionalExperienceInput = {
    update: XOR<UserUpdateWithoutProfessionalExperienceInput, UserUncheckedUpdateWithoutProfessionalExperienceInput>
    create: XOR<UserCreateWithoutProfessionalExperienceInput, UserUncheckedCreateWithoutProfessionalExperienceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfessionalExperienceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfessionalExperienceInput, UserUncheckedUpdateWithoutProfessionalExperienceInput>
  }

  export type UserUpdateWithoutProfessionalExperienceInput = {
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUpdateManyWithoutUserNestedInput
    posts?: PostsUpdateManyWithoutUserNestedInput
    questions?: QuestionsUpdateManyWithoutUserNestedInput
    friends?: FriendsUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUpdateManyWithoutUserNestedInput
    education?: EducationUpdateManyWithoutUserNestedInput
    jobs?: JobsUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfessionalExperienceInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    organisation_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialisation_field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    register_number?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillsUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
    questions?: QuestionsUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUserNestedInput
    certifications?: CertificationsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipsUncheckedUpdateManyWithoutUserNestedInput
    education?: EducationUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutUserNestedInput
    conferrences?: ConferrencesUncheckedUpdateManyWithoutUserNestedInput
    achievementsAwards?: AchievementsAwardsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SkillsCreateManyUserInput = {
    id?: number
    skill: string
  }

  export type PostsCreateManyUserInput = {
    id?: number
    title?: string | null
    description?: string | null
    posted_at?: Date | string
  }

  export type QuestionsCreateManyUserInput = {
    id?: number
    question: string
    question_description: string
    asked_at?: Date | string
  }

  export type FriendsCreateManyUserInput = {
    id?: number
  }

  export type CertificationsCreateManyUserInput = {
    id?: number
    certificateName?: string | null
    issuingOrganisation?: string | null
    issueDate?: string | null
    descreption?: string | null
    certificateURL?: string | null
    certificateMediaLink?: string | null
  }

  export type MembershipsCreateManyUserInput = {
    id?: number
    societyname?: string | null
    position?: string | null
    relatedDepartment?: string | null
    membershipId?: string | null
  }

  export type EducationCreateManyUserInput = {
    id?: number
    schoolName?: string | null
    degree?: string | null
    department?: string | null
    startDate?: string | null
    endDate?: string | null
    grade?: string | null
  }

  export type ProfessionalExperienceCreateManyUserInput = {
    id?: number
    title?: string | null
    organisation?: string | null
    startDate?: string | null
    endDate?: string | null
    location?: string | null
  }

  export type JobsCreateManyUserInput = {
    id?: number
  }

  export type ConferrencesCreateManyUserInput = {
    id?: number
  }

  export type AchievementsAwardsCreateManyUserInput = {
    id?: number
    awardName?: string | null
    awardedBy?: string | null
    awardedOn?: string | null
    descreption?: string | null
  }

  export type SkillsUpdateWithoutUserInput = {
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type PostsUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    postImageLinks?: PostImageLinksUpdateManyWithoutPostsNestedInput
    comments?: CommentsUpdateManyWithoutPostsNestedInput
    likes?: LikesUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUpdateManyWithoutPostsNestedInput
    shares?: SharesUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    postImageLinks?: PostImageLinksUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikesUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RepostsUncheckedUpdateManyWithoutPostsNestedInput
    shares?: SharesUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsUpdateWithoutUserInput = {
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_image_links?: QuestionImageLinksUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_image_links?: QuestionImageLinksUncheckedUpdateManyWithoutQuestionsNestedInput
    insightful?: InsightfulUncheckedUpdateManyWithoutQuestionsNestedInput
    answers?: AnswersUncheckedUpdateManyWithoutQuestionsNestedInput
    questionComments?: QuestionCommentsUncheckedUpdateManyWithoutQuestionsNestedInput
    questionReferences?: QuestionReferencesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    question_description?: StringFieldUpdateOperationsInput | string
    asked_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsUpdateWithoutUserInput = {

  }

  export type FriendsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type FriendsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CertificationsUpdateWithoutUserInput = {
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    issuingOrganisation?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
    certificateURL?: NullableStringFieldUpdateOperationsInput | string | null
    certificateMediaLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    issuingOrganisation?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
    certificateURL?: NullableStringFieldUpdateOperationsInput | string | null
    certificateMediaLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    issuingOrganisation?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
    certificateURL?: NullableStringFieldUpdateOperationsInput | string | null
    certificateMediaLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MembershipsUpdateWithoutUserInput = {
    societyname?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    relatedDepartment?: NullableStringFieldUpdateOperationsInput | string | null
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MembershipsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyname?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    relatedDepartment?: NullableStringFieldUpdateOperationsInput | string | null
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MembershipsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    societyname?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    relatedDepartment?: NullableStringFieldUpdateOperationsInput | string | null
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationUpdateWithoutUserInput = {
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolName?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfessionalExperienceUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfessionalExperienceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfessionalExperienceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobsUpdateWithoutUserInput = {

  }

  export type JobsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type JobsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ConferrencesUpdateWithoutUserInput = {

  }

  export type ConferrencesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ConferrencesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementsAwardsUpdateWithoutUserInput = {
    awardName?: NullableStringFieldUpdateOperationsInput | string | null
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AchievementsAwardsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    awardName?: NullableStringFieldUpdateOperationsInput | string | null
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AchievementsAwardsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    awardName?: NullableStringFieldUpdateOperationsInput | string | null
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedOn?: NullableStringFieldUpdateOperationsInput | string | null
    descreption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostImageLinksCreateManyPostsInput = {
    id?: number
    postImageLink?: string | null
  }

  export type CommentsCreateManyPostsInput = {
    id?: number
    comment: string
    commented_at?: Date | string
  }

  export type LikesCreateManyPostsInput = {
    id?: number
    liked_user_id?: number | null
  }

  export type RepostsCreateManyPostsInput = {
    id?: number
    reposted_user_id?: number | null
  }

  export type SharesCreateManyPostsInput = {
    id?: number
    shared_user_id?: number | null
  }

  export type PostImageLinksUpdateWithoutPostsInput = {
    postImageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostImageLinksUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postImageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostImageLinksUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postImageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentsUpdateWithoutPostsInput = {
    comment?: StringFieldUpdateOperationsInput | string
    commented_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    commented_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    commented_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikesUpdateWithoutPostsInput = {
    liked_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LikesUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    liked_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LikesUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    liked_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepostsUpdateWithoutPostsInput = {
    reposted_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepostsUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reposted_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepostsUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reposted_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SharesUpdateWithoutPostsInput = {
    shared_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SharesUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    shared_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SharesUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    shared_user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionImageLinksCreateManyQuestionsInput = {
    id?: number
  }

  export type InsightfulCreateManyQuestionsInput = {
    id?: number
    insightful_user_id?: string | null
  }

  export type AnswersCreateManyQuestionsInput = {
    id?: number
    answered_user_id: string
    answer_description: string
  }

  export type QuestionCommentsCreateManyQuestionsInput = {
    id?: number
    comment: string
    comment_user_id: number
  }

  export type QuestionReferencesCreateManyQuestionsInput = {
    id?: number
    reference?: string | null
  }

  export type QuestionImageLinksUpdateWithoutQuestionsInput = {

  }

  export type QuestionImageLinksUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionImageLinksUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type InsightfulUpdateWithoutQuestionsInput = {
    insightful_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InsightfulUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    insightful_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InsightfulUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    insightful_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswersUpdateWithoutQuestionsInput = {
    answered_user_id?: StringFieldUpdateOperationsInput | string
    answer_description?: StringFieldUpdateOperationsInput | string
    answer_image_links?: Answer_Image_LinksUpdateManyWithoutAnswersNestedInput
  }

  export type AnswersUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    answered_user_id?: StringFieldUpdateOperationsInput | string
    answer_description?: StringFieldUpdateOperationsInput | string
    answer_image_links?: Answer_Image_LinksUncheckedUpdateManyWithoutAnswersNestedInput
  }

  export type AnswersUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    answered_user_id?: StringFieldUpdateOperationsInput | string
    answer_description?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionCommentsUpdateWithoutQuestionsInput = {
    comment?: StringFieldUpdateOperationsInput | string
    comment_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionCommentsUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    comment_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionCommentsUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    comment_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionReferencesUpdateWithoutQuestionsInput = {
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionReferencesUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionReferencesUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Answer_Image_LinksCreateManyAnswersInput = {
    id?: number
    answer_image_link?: string | null
  }

  export type Answer_Image_LinksUpdateWithoutAnswersInput = {
    answer_image_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Answer_Image_LinksUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer_image_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Answer_Image_LinksUncheckedUpdateManyWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer_image_link?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}